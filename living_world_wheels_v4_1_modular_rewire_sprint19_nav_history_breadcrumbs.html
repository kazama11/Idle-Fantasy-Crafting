<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Living World Wheels — v4.1</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 0; display: grid; grid-template-columns: 300px 1fr 440px; height: 100vh; }
    header { grid-column: 1 / -1; padding: 10px 14px; border-bottom: 1px solid #ddd; display:flex; flex-wrap:wrap; align-items:flex-start; position:relative; gap:10px; }
    header .tabs button { margin-right: 6px; }
    aside { border-right: 1px solid #ddd; padding: 12px; overflow:auto; }
    main { padding: 12px; overflow:auto; }
    .right { border-left: 1px solid #ddd; padding: 12px; overflow:auto; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .col { display:flex; flex-direction:column; gap:8px; }
    .muted { color:#666; font-size: 12px; }
    .card { border:1px solid #ddd; border-radius: 12px; padding:12px; margin:10px 0; background:#fff; }
    .list { display:flex; flex-direction:column; gap:8px; }
    .item { padding:10px; border:1px solid #e5e5e5; border-radius: 12px; cursor:pointer; background:#fff; }
    .item.active { border-color:#222; }
    
    .item.flash { 
      animation: flashPulse 1.4s ease-out 1;
      border-color:#222;
      box-shadow: 0 0 0 3px rgba(0,0,0,0.14);
    }
    @keyframes flashPulse {
      0%   { transform: scale(1); box-shadow: 0 0 0 0 rgba(0,0,0,0.22); background: #fff; }
      30%  { transform: scale(1.01); box-shadow: 0 0 0 6px rgba(0,0,0,0.12); background: #fafafa; }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0,0,0,0.0); background: #fff; }
    }
    @media (prefers-reduced-motion: reduce) {
      .item.flash {
        animation: none;
        box-shadow: none;
      }
    }
label { font-size: 12px; color:#444; }
    input, select, textarea, button { font: inherit; }
    input, select, textarea { width: 100%; padding: 9px; border-radius: 12px; border:1px solid #ddd; }
    textarea { min-height: 90px; resize: vertical; }
    button { padding: 9px 12px; border-radius: 12px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button.primary { border-color:#222; }
    button.danger { border-color:#b00; color:#b00; }
    button.ghost { border-color:#ddd; color:#222; }
    button.small { padding:6px 10px; font-size:12px; }
    .chips { display:flex; flex-wrap: wrap; gap:6px; }
    .chip { border:1px solid #ddd; border-radius: 999px; padding: 5px 10px; font-size: 12px; cursor:pointer; user-select:none; }
    .chip.on { border-color:#222; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    .hr { height:1px; background:#eee; margin:10px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .pill { font-size:12px; padding:4px 8px; border:1px solid #ddd; border-radius:999px; }
    .createBox {
      border: 2px dashed #ccc;
      border-radius: 14px;
      padding: 12px;
      background: #fafafa;
      margin-top: 10px;
    }
    .createBox .title {
      font-weight: 800;
      letter-spacing: .06em;
      font-size: 12px;
      color: #222;
    }
    .kbd { font-size:12px; padding:2px 6px; border:1px solid #ddd; border-radius:6px; background:#fff; }
    
    .progress { height: 10px; background: #eee; border-radius: 999px; overflow: hidden; }
    .progressFill { height: 100%; background: #222; width: 0%; }
    .actions { display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .badge { font-size:11px; padding:2px 8px; border:1px solid #ddd; border-radius:999px; background:#fafafa; }
details summary { cursor:pointer; }
  
    /* -------------------- NAV: Modes + Context Bar (Sprint 16) -------------------- */
    .modebar { gap:8px; flex-wrap:wrap; margin-top:8px; }
    .modeBtn { padding:6px 10px; border-radius:999px; border:1px solid #ddd; background:#fff; font-size:12px; }
    .modeBtn.primary { background:#222; color:#fff; border-color:#222; }
    .contextbar { gap:10px; flex-wrap:wrap; margin-top:6px; }
    .contextGroup { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .contextLabel { font-size:12px; color:#444; }
    .contextSelect { max-width:240px; }
    .contextPill { font-size:12px; padding:4px 10px; border:1px solid #ddd; border-radius:999px; background:#fafafa; }

  
    /* -------------------- NAV: Search + Recents (Sprint 17) -------------------- */
    .navResults { width: 100%; }
    .navPanel { border:1px solid #ddd; border-radius:14px; background:#fff; padding:10px; box-shadow: 0 8px 24px rgba(0,0,0,.06); }
    .navResultBtn { width:100%; text-align:left; padding:8px 10px; border:1px solid #eee; border-radius:12px; background:#fafafa; margin-top:6px; }
    .navResultBtn:hover { background:#f0f0f0; }
    .navSub { font-size:12px; color:#666; margin-top:2px; }
    .navSearch { padding:6px 10px; border-radius:999px; border:1px solid #ddd; background:#fff; font-size:12px; min-width:240px; }
    .recentRow { display:flex; gap:6px; flex-wrap:wrap; }

    /* -------------------- NAV: History + Breadcrumbs (Sprint 19) -------------------- */
    .navCrumbs { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .crumb { font-size:12px; padding:4px 8px; border:1px solid #ddd; border-radius:999px; background:#fff; }
    .crumb.active { background:#222; color:#fff; border-color:#222; }
    .crumbSep { color:#999; font-size:12px; padding:0 2px; }
    .navNavBtn { padding:4px 8px; border-radius:8px; border:1px solid #ddd; background:#fff; font-size:12px; }
    .navNavBtn:disabled { opacity:0.45; }
  </style>
</head>
<body>
  <header>
    <div class="tabs row">
      <button id="tabWorld" class="primary">World</button>
      <button id="tabChars">Characters</button>
      <button id="tabGen">Generator</button>
      <button id="tabCreate">Create</button>
      <button id="tabIntake">Intake</button>
      <button id="tabSettings">Index</button>
      <button id="tabSim">Sim</button>
          <button id="tabDocs">Docs</button>
</div>
    <div class="row" style="margin-left:auto;">
      <button id="btnExport">Export JSON</button>
      <button id="btnExportMD">Export Markdown</button>
      <label class="chip">
        Import JSON
        <input id="fileImport" type="file" accept="application/json" style="display:none"/>
      </label>
      <button id="btnReset" class="danger">Reset</button>
      <span class="muted">Autosaves</span>
    
    <div id="modeBar" class="row modebar"></div>
    <div id="contextBar" class="row contextbar"></div>
    <div id="navResults" class="navResults"></div>
</div>
  </header>

  <aside><div id="leftPane"></div></aside>
  <main><div id="mainPane"></div></main>
  <div class="right"><div id="rightPane"></div></div>

<script>

const APP_VERSION = "v4.1-modules";
const STATE_SCHEMA_VERSION = 9;

// We write to the newest key, but we can still read older keys for migration.
const STORAGE_KEY = "LWW_STATE_v3";
const STORAGE_KEY_FALLBACKS = ["LWW_STATE_v3", "LWW_STATE_v2"];

const uid = () => Math.random().toString(36).slice(2, 10) + "-" + Date.now().toString(36);
const nowISO = () => new Date().toISOString();
const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
const clamp10 = (n) => clamp(Number(n)||0, 0, 10);

const deep = (x) => JSON.parse(JSON.stringify(x));
const deepMerge = (target, src) => {
  const isObj = (v) => v && typeof v === 'object' && !Array.isArray(v);
  const out = isObj(target) ? target : {};
  if (!isObj(src)) return out;
  for (const k of Object.keys(src)) {
    const sv = src[k];
    const tv = out[k];
    out[k] = (isObj(sv) && isObj(tv)) ? deepMerge(tv, sv) : deep(sv);
  }
  return out;
};

// -------------------- PERFORMANCE: MEMOIZED QUANT CACHE --------------------
const _cache = {
  quant: new Map(),
  clear(){ this.quant.clear(); }
};

// Memoized Quant.compute - clears on entity update (via updatedAt)
function computeQuantCached(entity) {
  if (!entity?.id) return Quant.compute(entity);
  const key = `${entity.id}::${entity.updatedAt || ""}`;
  const hit = _cache.quant.get(key);
  if (hit) return hit;
  const result = Quant.compute(entity);
  _cache.quant.set(key, result);
  return result;
}
const $ = (q) => document.querySelector(q);
/** -------------------- GENERIC WHEEL MODAL (for any rollable action) -------------------- */
function ensureWheelModal(){
  let wrap = document.getElementById("wheelModal");
  if (wrap) return wrap;
  wrap = document.createElement("div");
  wrap.id = "wheelModal";
  wrap.style.cssText = [
    "position:fixed","inset:0","z-index:9999","display:none",
    "background:rgba(0,0,0,.55)","padding:14px","overflow:auto"
  ].join(";");
  wrap.innerHTML = `
    <div style="max-width:520px;margin:0 auto;">
      <div style="background:#fff;border-radius:16px;padding:12px;border:1px solid #ddd;">
        <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;">
          <div>
            <div id="wheelModalTitle" style="font-weight:900;font-size:14px;letter-spacing:.06em;">SPIN WHEEL</div>
            <div id="wheelModalSubtitle" style="color:#666;font-size:12px;">Weighted slices</div>
          </div>
          <div style="display:flex;gap:8px;">
            <button id="wheelModalSpin" style="padding:9px 12px;border-radius:12px;border:1px solid #222;background:#fff;cursor:pointer;font-weight:700;">SPIN</button>
            <button id="wheelModalClose" style="padding:9px 12px;border-radius:12px;border:1px solid #ccc;background:#fff;cursor:pointer;">Close</button>
          </div>
        </div>
        <div style="text-align:center;margin-top:10px;position:relative;">
          <div style="position:absolute; top:6px; left:50%; transform:translateX(-50%); z-index:5; font-size:22px;">▼</div>
          <canvas id="wheelModalCanvas" width="460" height="460" style="max-width:100%;height:auto;"></canvas>
        </div>
        <div id="wheelModalResult" style="margin-top:10px;color:#222;font-size:13px;"></div>
      </div>
    </div>
  `;
  document.body.appendChild(wrap);
  wrap.querySelector("#wheelModalClose").addEventListener("click", ()=>{ wrap.style.display = "none"; });
  // Click outside closes
  wrap.addEventListener("click", (ev)=>{
    if (ev.target === wrap) wrap.style.display = "none";
  });
  return wrap;
}

function wheelModalPick({ title="SPIN WHEEL", subtitle="Weighted slices", options=[], weights=[] }={}){
  return new Promise((resolve)=>{
    const wrap = ensureWheelModal();
    const titleEl = wrap.querySelector("#wheelModalTitle");
    const subEl = wrap.querySelector("#wheelModalSubtitle");
    const resEl = wrap.querySelector("#wheelModalResult");
    const canvas = wrap.querySelector("#wheelModalCanvas");
    const btnSpin = wrap.querySelector("#wheelModalSpin");
    const btnClose = wrap.querySelector("#wheelModalClose");

    titleEl.textContent = title;
    subEl.textContent = subtitle;
    resEl.textContent = "";

    const segs = Wheel.computeSegments(options, weights);
    Wheel.reset();
    Wheel.draw(canvas, segs);
    wrap.style.display = "block";

    let resolved = false;
    const doResolve = (value)=>{
      if (resolved) return;
      resolved = true;
      resolve(value);
    };

    const closeNow = ()=>{
      wrap.style.display = "none";
      doResolve(null);
    };

    // Ensure closing the modal never leaves callers hanging
    btnClose.onclick = closeNow;
    wrap.addEventListener("click", (ev)=>{
      if (ev.target === wrap) closeNow();
    });

    let done = false;
    const onDone = (winner)=>{
      if (done) return;
      done = true;
      resEl.innerHTML = `<b>Result:</b> ${winner?.label || "(none)"}`;
      // slight delay so the result is visible, then close
      setTimeout(()=>{
        wrap.style.display = "none";
        doResolve(winner);
      }, 180);
    };

    btnSpin.onclick = ()=>{
      if (!segs.length) return;
      Wheel.spin(canvas, segs, onDone);
    };
  });
}
/** -------------------- STARTUP GUARD & FATAL OVERLAY -------------------- */
function ensureFatalOverlay() {
  let el = document.getElementById("fatalOverlay");
  if (el) return el;
  el = document.createElement("div");
  el.id = "fatalOverlay";
  el.style.cssText = [
    "position:fixed","inset:0","z-index:99999","display:none",
    "background:rgba(10,10,10,0.86)","color:#fff","padding:16px",
    "font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif",
    "overflow:auto"
  ].join(";");
  el.innerHTML = `
    <div style="max-width:960px;margin:0 auto;">
      <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap;">
        <div>
          <div style="font-size:18px;font-weight:700;">Living World Wheels failed to start</div>
          <div style="opacity:.8;margin-top:4px;">App ${APP_VERSION} • Schema ${STATE_SCHEMA_VERSION}</div>
        </div>
        <div style="display:flex;gap:8px;">
          <button id="fatalResetBtn" style="padding:10px 12px;border-radius:10px;border:0;background:#fff;color:#000;font-weight:700;cursor:pointer;">Reset local data</button>
          <button id="fatalCloseBtn" style="padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.5);background:transparent;color:#fff;font-weight:700;cursor:pointer;">Close</button>
        </div>
      </div>
      <pre id="fatalStack" style="white-space:pre-wrap;margin-top:12px;padding:12px;border-radius:12px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);"></pre>
      <div style="opacity:.75;margin-top:10px;line-height:1.4;">
        Tip: If you recently updated the file, old saved data might be incompatible. Click “Reset local data”.
      </div>
    </div>
  `;
  document.body.appendChild(el);

  el.querySelector("#fatalResetBtn").addEventListener("click", ()=>{
    try { STORAGE_KEY_FALLBACKS.forEach(k=>localStorage.removeItem(k)); } catch {}
    location.reload();
  });
  el.querySelector("#fatalCloseBtn").addEventListener("click", ()=>{ el.style.display="none"; });
  return el;
}

function showFatal(err) {
  console.error(err);
  const el = ensureFatalOverlay();
  const pre = el.querySelector("#fatalStack");
  pre.textContent = (err && (err.stack || err.message)) ? String(err.stack || err.message) : String(err);
  el.style.display = "block";
}

// Catch async errors too
window.addEventListener("error", (ev)=>{ try{ showFatal(ev.error || ev.message || ev); }catch{} });
window.addEventListener("unhandledrejection", (ev)=>{ try{ showFatal(ev.reason || ev); }catch{} });


function el(tag, attrs={}, children=[]) {
  const node = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs||{})) {
    if (k === "class") node.className = v;
    else if (k === "text") node.textContent = v;
    else if (k === "html") node.innerHTML = v;
    else if (k === "style") node.setAttribute("style", v);
    else if (k === "value") node.value = v;
    else if (k === "checked") node.checked = !!v;
    else if (k === "disabled") node.disabled = !!v;
    else if (k === "readonly" || k === "readOnly") node.readOnly = !!v;
    else if (k === "selected") node.selected = !!v;
    else if (k.startsWith("on") && typeof v === "function") node[k] = v;
    else if (v != null) node.setAttribute(k, v);
  }
  if (!Array.isArray(children)) children = [children];
  children.filter(Boolean).forEach(ch => node.appendChild(typeof ch === "string" ? document.createTextNode(ch) : ch));
  return node;
}

function toast(message, duration = 2000) {
  let container = document.getElementById("toast-container");
  if (!container) {
    container = el("div", {id: "toast-container", style: "position:fixed; bottom:20px; left:50%; transform:translateX(-50%); z-index:10000; display:flex; flex-direction:column; gap:8px; align-items:center;"});
    document.body.appendChild(container);
  }
  const toastEl = el("div", {
    text: message,
    style: "background:rgba(0,0,0,0.8); color:white; padding:10px 16px; border-radius:999px; font-size:14px; box-shadow:0 4px 12px rgba(0,0,0,0.15);"
  });
  container.appendChild(toastEl);
  setTimeout(() => {
    toastEl.style.transition = "opacity 0.5s";
    toastEl.style.opacity = "0";
    setTimeout(() => toastEl.remove(), 500);
  }, duration);
}

// Generic helper: find object by .id in an array
function byId(arr, id){
  return (arr||[]).find(o=>o && o.id===id) || null;
}


// Convenience card helper used across panels
function card(title, children=[]) {
  if (!Array.isArray(children)) children = [children];
  const body = el("div",{style:"margin-top:8px; display:flex; flex-direction:column; gap:8px;"});
  children.filter(Boolean).forEach(ch => body.appendChild(ch));
  return el("div",{class:"card"},[
    el("div",{class:"h", text:title}),
    body
  ]);
}

function renderPreserveFocus() {
  const active = document.activeElement;
  const id = active?.id || null;
  const selStart = (active && "selectionStart" in active) ? active.selectionStart : null;
  const selEnd = (active && "selectionEnd" in active) ? active.selectionEnd : null;
  render();
  if (id) { // Re-apply focus and selection
    const again = document.getElementById(id);
    if (!again) return;
    again.focus({preventScroll:true});
    try {
      if (selStart != null && selEnd != null && "setSelectionRange" in again) again.setSelectionRange(selStart, selEnd);
    } catch {}
  }
}

/** -------------------- INDEX -------------------- */
const DEFAULT_FACET_DEFS_BY_TYPE = {
  skill: [
    {key:"power", label:"Power"},
    {key:"utility", label:"Utility"},
    {key:"reliability", label:"Reliability"},
    {key:"scope", label:"Scope"},
    {key:"frequency", label:"Frequency"},
    {key:"complexity", label:"Complexity"},
    {key:"upkeep", label:"Upkeep"},
    {key:"access", label:"Access"},
    {key:"rarity", label:"Rarity"},
  ],
  class: [
    {key:"power", label:"Power"},
    {key:"utility", label:"Utility"},
    {key:"reliability", label:"Reliability"},
    {key:"scope", label:"Scope"},
    {key:"frequency", label:"Frequency"},
    {key:"complexity", label:"Complexity"},
    {key:"upkeep", label:"Upkeep"},
    {key:"access", label:"Access"},
    {key:"rarity", label:"Rarity"},
  ],
  race: [
    {key:"utility", label:"Utility"},
    {key:"reliability", label:"Reliability"},
    {key:"access", label:"Access"},
    {key:"rarity", label:"Rarity"},
    {key:"scope", label:"Scope"},
  ],
  monster: [
    {key:"power", label:"Power"},
    {key:"reliability", label:"Reliability"},
    {key:"scope", label:"Scope"},
    {key:"rarity", label:"Rarity"},
  ],
  magic_school: [
    {key:"power", label:"Power"},
    {key:"utility", label:"Utility"},
    {key:"complexity", label:"Complexity"},
    {key:"access", label:"Access"},
    {key:"rarity", label:"Rarity"},
    {key:"scope", label:"Scope"},
  ],
  legend: [
    {key:"utility", label:"Utility"},
    {key:"scope", label:"Scope"},
    {key:"rarity", label:"Rarity"},
    {key:"access", label:"Access"},
  ],
  biome: [
    {key:"scope", label:"Scope"},
    {key:"rarity", label:"Rarity"},
  ],
  quant_profile: []
};

const DEFAULT_INDEX = {
  entityTypes: [
    {id:"biome", name:"Biome"},
    {id:"monster", name:"Monster"},
    {id:"legend", name:"Legend"},
    {id:"class", name:"Class"},
    {id:"skill", name:"Skill"},
    {id:"magic_school", name:"Magic School"},
    {id:"quant_profile", name:"Quant Profile"},
  ],
  tagCategories: [
    {id:"race", name:"Race"},
    {id:"domain", name:"Domain"},
    {id:"magic", name:"Magic"},
    {id:"tone", name:"Tone"},
    {id:"place", name:"Place"},
  ],
  tags: [
    {id:uid(), name:"human", categoryId:"race"},
    {id:uid(), name:"orc", categoryId:"race"},
    {id:uid(), name:"elf", categoryId:"race"},
    {id:uid(), name:"dwarf", categoryId:"race"},
    {id:uid(), name:"goblin", categoryId:"race"},
    {id:uid(), name:"martial", categoryId:"domain"},
    {id:uid(), name:"scouting", categoryId:"domain"},
    {id:uid(), name:"crafting", categoryId:"domain"},
    {id:uid(), name:"arcane", categoryId:"domain"},
    {id:uid(), name:"primal", categoryId:"domain"},
    {id:uid(), name:"social", categoryId:"domain"},
    {id:uid(), name:"runic", categoryId:"magic"},
    {id:uid(), name:"storm", categoryId:"magic"},
    {id:uid(), name:"blood", categoryId:"magic"},
    {id:uid(), name:"illusion", categoryId:"magic"},
  ],
  facetDefsByType: DEFAULT_FACET_DEFS_BY_TYPE,
  tagConflicts: [],
  linkTypes: [
    {id:"found_in", name:"Found in"},
    {id:"hunts", name:"Hunts"},
    {id:"fears", name:"Fears"},
    {id:"worshipped_by", name:"Worshipped by"},
    {id:"related", name:"Related"},
  ],
  templates: {
    biome: [
      {key:"summary", label:"Summary", kind:"textarea"},
      {key:"climate", label:"Climate", kind:"text"},
      {key:"features", label:"Features", kind:"textarea"},
      {key:"resources", label:"Resources", kind:"textarea"},
      {key:"hazards", label:"Hazards", kind:"textarea"},
    ],
    monster: [
      {key:"summary", label:"Summary", kind:"textarea"},
      {key:"appearance", label:"Appearance", kind:"textarea"},
      {key:"behavior", label:"Behavior", kind:"textarea"},
      {key:"weaknesses", label:"Weaknesses", kind:"textarea"},
      {key:"drops", label:"Drops / cores", kind:"textarea"},
    ],
    legend: [
      {key:"summary", label:"Summary", kind:"textarea"},
      {key:"tellings", label:"Where it's told", kind:"textarea"},
      {key:"truth", label:"Truth / twist", kind:"textarea"},
      {key:"hook", label:"Adventure hook", kind:"textarea"},
    ],
    class: [
      {key:"role", label:"Role (what do they do?)", kind:"textarea"},
      {key:"training", label:"Training (where it comes from)", kind:"textarea"},
      {key:"gear", label:"Gear tendencies", kind:"textarea"},
      {key:"signature", label:"Signature moves / style", kind:"textarea"},
      {key:"magic_notes", label:"Magic notes (blank if non-magical)", kind:"textarea"},
      {key:"starting_skills", label:"Starting skill ideas (optional)", kind:"textarea"},
    ],
    magic_school: [
      {key:"kind", label:"What kind of magic is this?", kind:"textarea"},
      {key:"strength", label:"General strength (1–10)", kind:"text"},
      {key:"usefulness", label:"Usefulness (1–10)", kind:"text"},
      {key:"rarity", label:"Rarity (1–10)", kind:"text"},
      {key:"scope", label:"Scope (Duel / Skirmish / Battle / Region)", kind:"text"},
      {key:"evolves", label:"Can it evolve through use? (yes/no)", kind:"text"},
      {key:"notes", label:"Evolution notes / vibe", kind:"textarea"},
    ],
    skill: [
      {key:"description", label:"What does it do?", kind:"textarea"},
      {key:"power", label:"Power (1–10)", kind:"text"},
      {key:"utility", label:"Utility (1–10)", kind:"text"},
      {key:"cooldown", label:"Cooldown / frequency (1–10)", kind:"text"},
      {key:"scope", label:"Scope (Duel / Skirmish / Battle / Utility)", kind:"text"},
      {key:"evolves", label:"Can it evolve? (yes/no)", kind:"text"},
      {key:"evolve_notes", label:"Evolution notes", kind:"textarea"},
    ],
    quant_profile: [
      {key:"powerUnits", label:"Power units curve (11 numbers for 0..10)", kind:"text"},
      {key:"scopeMult", label:"Scope multiplier curve (11 numbers for 0..10)", kind:"text"},
      {key:"prestigeUnits", label:"Prestige units curve (11 numbers for 0..10)", kind:"text"},
      {key:"useWeights", label:"Usefulness weights JSON (power, utility, reliability, frequency, scope)", kind:"textarea"},
      {key:"effortWeights", label:"Effort weights JSON (complexity, upkeep, access)", kind:"textarea"},
      {key:"notes", label:"Notes", kind:"textarea"},
    ]

  }
};

function seedEntity(typeId, name, fields={}, tagIds=[], links=[]) {
  return { id: uid(), typeId, name, fields, tagIds, links, pinned:false, createdAt: nowISO(), updatedAt: nowISO() };
}
function seedCharacter(name="Unnamed", tagNames=[], stats=null) {
  return {
    id: uid(),
    name,
    pinned:false,
    tagIds: [],
    classId: null,
    magicSchoolId: null,
    skillIds: [],
    stats: stats || {
      Physical: { STR: 4, AGI: 4, DUR: 4, END: 4, REF: 4 },
      Mental: { INT: 4, WIT: 4, FOC: 4, MEM: 4 },
      Social: { CHA: 4, EMP: 4, DECEIT: 4, AURA: 4 },
      Metaphysical: { WILL: 4, SOUL: 4, RES: 4, LUCK: 4 },
    },
    notes: "",
    draft: "",
    createdAt: nowISO(),
    updatedAt: nowISO(),
    _skillCandidates: null,
    _seedTagNames: tagNames
  };
}
function seedStep(name, source="manual", options=[]) {
  return { id: uid(), name, source, options };
}

const DEFAULT_WIZARD = {
  typeId: "skill",
  name: "",
  tagIds: [],
  quantProfileId: null, // null = world default
  facets: {
    power: 0, utility: 0, reliability: 0, scope: 0,
    complexity: 0, upkeep: 0, access: 0, frequency: 0, rarity: 0
  },
  fields: {}, // filled from templates; optional
  notes: ""
};


const DEFAULT_INTAKE = {
  typeId: "skill",
  includeTags: true,
  includeFacetSet: true,
  includeQuantProfiles: false,
  includeTemplates: true,
  generateCount: 6,
  richness: "balanced", // "short" | "balanced" | "rich"
  prompt: "",
  aiJson: "",
  commitMode: "create", // "create" | "update" | "draft"
  updateBehavior: "merge", // "merge" | "replace"
  drafts: [], // {id, ts, typeId, aiJson, prompt, preview}
  lastPreview: null,
  lastError: ""
};

// -------------------- SIM DEFAULTS --------------------
const DEFAULT_SIM = {
  clock: { tick: 0, lastTickAt: null },
  resources: { coin: 0, notes: 0 },  // keep tiny at first
  settings: {
    autoTick: false,
    tickMs: 1500,
    pinnedOnly: false,
    candidateLimit: 25,
    maxRuleFiringsPerTick: 25,
    maxLinksPerEntityPerKind: 9999,
    emergenceEnabled: true,
    emergenceMaxSpawnsPerTick: 2,
    stopOnRunaway: true,
    runaway: {
      maxRuleFirings: 80,
      maxLinksAdded: 25,
      maxAbsDelta: 25
    }
  },
  rules: [],     // later: store rules here
  events: [],    // ring buffer
  lastDiff: null, // small per-tick summary
  installedPacks: [], // pack ids installed
  packMeta: {}, // map packId -> {packId,name,version,enabled,installedAt}
  frozenEntityIds: [], // entity ids frozen (no rule eval + no mutations)
  ruleRuntime: {}, // per-rule runtime data (cooldowns, etc.)
  // TS: ObjectiveState[] - persisted gameplay goals (completion + claim)
  objectives: [],
  // TS: { [objectiveId: string]: { enabled?: boolean } } future-proof meta
  objectiveMeta: {},

  // TS: string[] - unlock ids the player has purchased
  unlockOwned: [],
  // TS: { [unlockId: string]: { purchasedAt?: string } } future-proof meta
  unlockMeta: {},

  // TS: CraftingState (Layer 1). Keeps the item-production loop small & debuggable.
  // In TS: type ForgeOutcome = "success" | "flaw" | "fail";
  crafting: {
    settings: {
      mode: "production", // "production" | "lab" (future)
      costCoinPerForge: 1, // coin cost per Forge action (0 = free)
      allowUnsafe: true, // allow forging with missing links; it will likely fail
      labExtraRisk: 15, // extra risk added when forging in lab mode (volatility)
      labExtraCostCoin: 1, // additional coin cost when in lab mode
      crisisCostCoin: 3, // coin cost for Crisis Forge (lab action)
      feedCostCoin: 1, // coin cost per Feed action (lab action)
    },
    upgrades: {
      toolsBonus: 0,        // +risk reduction / +stability on success
      extraRuneSlot: false, // allows 1 extra rune without penalty at low tiers
      labUnlocked: false,   // unlock: enable lab mode + crisis forge UI
      feedingUnlocked: false, // unlock: enable feeding actions
      artifactUnlocked: false // unlock: enable artifact-grade promotion checks
    },
    streaks: {
      consecutiveSuccesses: 0, // global streak across all items (objective-friendly)
      perItem: {} // itemId -> {successStreak:number, lastOutcome:string, lastTick:number}
    },
    failedAtByItemId: {}, // itemId -> tick when it last entered a FAILED state
    lastForge: null // {tick,itemId,outcome,risk,roll,summary,applied:{...}}
  },


  // TS: { [key: string]: number } - emergence de-dup keys (key -> tick created)
  emergenceSeen: {},
  // TS: { tick:number, spawns:Array<{entityId:string, kind:string, key:string}> } | null
  lastEmergence: null,

  ui: {
    selectedEntityId: null,
    ruleFilter: "",
    packFilter: "", // packId filter for rule list
    showCandidates: true,
    packInstallText: "", // TS: string (JSON)
    packInstallError: "", // TS: string
    eventFilter: { type:"", entity:"", ruleId:"", q:"" },
    // TS: MarketUIState { crafterId?:string, locationId?:string, lastQuote?:any }
    market: { crafterId:"", locationId:"", lastQuote:null }
  }
};


// -------------------- SIM PACK: interaction_basics v0 --------------------
const PACK_INTERACTION_BASICS = {
  packId: "interaction_basics",
  name: "Interaction Basics",
  version: "0.1.0",
  linkTypesToAdd: [
    {id:"synergy", name:"Synergy (skill→class)"},
    {id:"habitat", name:"Habitat (monster→biome)"},
    {id:"yields", name:"Yields (resource→biome)"},
    {id:"favored_terrain", name:"Favored terrain (class→biome)"},
  ],
  tagsToCreate: [
    { name:"adapted", category:"Tone" },
    { name:"overexposed", category:"Tone" },
    { name:"studied", category:"Tone" },
    { name:"hotspot", category:"Place" },
  ],
  rulesToAdd: [
    {
      id: "R-CLASS-NOTES-FROM-SYNERGY",
      name: "Class with many synergy skills yields research notes",
      when: { typeIs: "class", linkCount: { kindId: "synergy", gte: 2, fromTypeId: "skill" } },
      then: [{ resource: { key: "notes", add: 2 } }],
      limits: { maxPerTick: 4 },
      debug: { explain: "A class that has many linked skills becomes easier to study." }
    },
    {
      id: "R-SKILL-UTILITY-FROM-SYNERGY",
      name: "Skilled discipline: a linked skill grows in utility",
      when: { typeIs: "skill", outLinkCount: { kindId: "synergy", gte: 1, toTypeId: "class" } },
      then: [
        { facet: { key: "utility", add: 1 } },
        { tag: { add: "studied" } }
      ],
      limits: { maxPerTick: 6 },
      debug: { explain: "Skills that find a home in a class sharpen over time." }
    },
    {
      id: "R-BIOME-COIN-FROM-HABITATS",
      name: "Busy habitat biomes attract coin",
      when: { typeIs: "biome", linkCount: { kindId: "habitat", gte: 2, fromTypeId: "monster" } },
      then: [{ resource: { key: "coin", add: 2 } }, { tag: { add: "hotspot" } }],
      limits: { maxPerTick: 4 },
      debug: { explain: "If many monsters are tied to a biome, it becomes economically 'active'." }
    },
    {
      id: "R-BIOME-RARITY-FROM-HABITATS",
      name: "Crowded habitats push biome rarity upward",
      when: { typeIs: "biome", linkCount: { kindId: "habitat", gte: 3, fromTypeId: "monster" } },
      then: [{ facet: { key: "rarity", add: 1 } }, { tag: { add: "overexposed" } }],
      limits: { maxPerTick: 2 },
      debug: { explain: "Overlinked biomes become stranger (and noisier) in the generator." }
    },
    {
      id: "R-MONSTER-ADAPTED-FROM-HABITAT",
      name: "Monsters linked to habitats become adapted",
      when: { typeIs: "monster", outLinkCount: { kindId: "habitat", gte: 1, toTypeId: "biome" } },
      then: [{ tag: { add: "adapted" } }],
      limits: { maxPerTick: 10 },
      debug: { explain: "A monster anchored to a habitat starts to fit it better." }
    },
    {
      id: "R-CLASS-COIN-FROM-FAVORED-TERRAIN",
      name: "Classes with favored terrain attract patrons (coin)",
      when: { typeIs: "class", outLinkCount: { kindId: "favored_terrain", gte: 1, toTypeId: "biome" } },
      then: [{ resource: { key: "coin", add: 1 } }],
      limits: { maxPerTick: 6 },
      debug: { explain: "A class tied to a place gets hired where it fits." }
    }
  ]
};

// -------------------- SIM PACK: trade_basics v0 (unlocked via Unlocks) --------------------
const PACK_TRADE_BASICS = {
  packId: "trade_basics",
  name: "Trade Basics",
  version: "0.1.0",
  linkTypesToAdd: [
    {id:"trades_with", name:"Trades with"},
    {id:"produces", name:"Produces (resource→entity)"},
    {id:"consumes", name:"Consumes (resource→entity)"}
  ],
  tagsToCreate: [
    {name:"merchant", categoryName:"Role"},
    {name:"scarce", categoryName:"Tone"},
    {name:"surplus", categoryName:"Tone"}
  ],
  rulesToAdd: [
    // TS: RuleV0 - if an entity has >=2 trades_with links, grant coin; if consumes links pile up, add scarce
    { id:"R-TRADE-COIN", name:"Trade activity generates coin",
      when:{ outLinkCount:{ kindId:"trades_with", gte:2 } },
      then:[ {resource:{key:"coin", add:2}} ],
      limits:{ maxPerTick:3 }
    },
    { id:"R-CONSUME-SCARCE", name:"Heavy consumption marks scarcity",
      when:{ outLinkCount:{ kindId:"consumes", gte:2 } },
      then:[ {tag:{add:"scarce"}} ],
      limits:{ maxPerTick:2 }
    }
  ]
};

// -------------------- SIM PACK: ecology_basics v0 (unlocked via Unlocks) --------------------
const PACK_ECOLOGY_BASICS = {
  packId: "ecology_basics",
  name: "Ecology Basics",
  version: "0.1.0",
  linkTypesToAdd: [
    {id:"predator_of", name:"Predator of"},
    {id:"prey_of", name:"Prey of"}
  ],
  tagsToCreate: [
    {name:"apex", categoryName:"Role"},
    {name:"fragile", categoryName:"Tone"}
  ],
  rulesToAdd: [
    // TS: RuleV0 - predators create pressure; prey density creates abundance (coin) but can cause fragility
    { id:"R-APEX-PRESSURE", name:"Predators raise hazard pressure (notes)",
      when:{ outLinkCount:{ kindId:"predator_of", gte:1 } },
      then:[ {resource:{key:"notes", add:1}}, {tag:{add:"apex"}} ],
      limits:{ maxPerTick:4 }
    },
    { id:"R-PREY-BOOM", name:"Prey booms create coin",
      when:{ outLinkCount:{ kindId:"prey_of", gte:2 } },
      then:[ {resource:{key:"coin", add:2}} ],
      limits:{ maxPerTick:3 }
    }
  ]
};


function applySimPack(pack, opts){
  if (!pack || typeof pack !== "object") return { ok:false, reason:"bad pack" };
  if (!state?.sim) return { ok:false, reason:"no sim" };
  const replaceRules = !!opts?.replaceRules;
  state.sim.installedPacks = state.sim.installedPacks || [];
  if (state.sim.installedPacks.includes(pack.packId)) return { ok:true, already:true };

  // -------------------- PACK EXTENSIONS (index scaffolding) --------------------
  // These are optional fields on PackV0 used by later sprints.
  // They are ignored by PackValidator, but applySimPack can merge them safely.
  //
  // TS-READY NOTES:
  // - entityTypesToAdd: Array<{id:string,name:string}>
  // - facetDefsToAdd: { [typeId:string]: Array<{key:string,label?:string,enabled?:boolean,mapsTo?:string,labels?:string[]}> }
  // - templatesToAdd: { [typeId:string]: Array<{key:string,label:string,kind:"text"|"textarea"|"number"}> }
  const etAdd = Array.isArray(pack.entityTypesToAdd) ? pack.entityTypesToAdd : [];
  if (etAdd.length){
    state.index.entityTypes = state.index.entityTypes || [];
    const have = new Set(state.index.entityTypes.map(t=>t.id));
    etAdd.forEach(t=>{
      if (!t || typeof t !== "object") return;
      const id = String(t.id||"").trim();
      const name = String(t.name||id).trim();
      if (!id) return;
      if (!have.has(id)){
        state.index.entityTypes.push({id, name});
        have.add(id);
      }
      // Ensure facet defs container exists for this type.
      state.index.facetDefsByType = state.index.facetDefsByType || {};
      if (!Array.isArray(state.index.facetDefsByType[id])) state.index.facetDefsByType[id] = [];
      // Ensure templates container exists for this type.
      state.index.templates = state.index.templates || {};
      if (!Array.isArray(state.index.templates[id])) state.index.templates[id] = [];
    });
  }

  const facetAdd = (pack.facetDefsToAdd && typeof pack.facetDefsToAdd==="object") ? pack.facetDefsToAdd : null;
  if (facetAdd){
    state.index.facetDefsByType = state.index.facetDefsByType || {};
    for (const [typeId, defs] of Object.entries(facetAdd)){
      if (!Array.isArray(defs)) continue;
      if (!Array.isArray(state.index.facetDefsByType[typeId])) state.index.facetDefsByType[typeId] = [];
      const tgt = state.index.facetDefsByType[typeId];
      const haveKeys = new Set(tgt.map(d=>d?.key).filter(Boolean));
      defs.forEach(d=>{
        if (!d || typeof d !== "object") return;
        const k = String(d.key||"").trim();
        if (!k) return;
        if (haveKeys.has(k)) return;
        // Keep only known-ish fields; UI can ignore extras.
        tgt.push({ key: k, label: d.label || k });
        haveKeys.add(k);
      });
    }
  }

  const tmplAdd = (pack.templatesToAdd && typeof pack.templatesToAdd==="object") ? pack.templatesToAdd : null;
  if (tmplAdd){
    state.index.templates = state.index.templates || {};
    for (const [typeId, arr] of Object.entries(tmplAdd)){
      if (!Array.isArray(arr)) continue;
      if (!Array.isArray(state.index.templates[typeId])) state.index.templates[typeId] = [];
      const tgt = state.index.templates[typeId];
      const haveKeys = new Set(tgt.map(t=>t?.key).filter(Boolean));
      arr.forEach(t=>{
        if (!t || typeof t !== "object") return;
        const k = String(t.key||"").trim();
        if (!k) return;
        if (haveKeys.has(k)) return;
        tgt.push({ key: k, label: String(t.label||k), kind: t.kind || "text" });
        haveKeys.add(k);
      });
    }
  }



  // Ensure link types
  const ltIds = new Set((state.index.linkTypes||[]).map(x=>x.id));
  (pack.linkTypesToAdd||[]).forEach(lt=>{
    if (lt?.id && !ltIds.has(lt.id)) { state.index.linkTypes.push({id: lt.id, name: lt.name||lt.id}); ltIds.add(lt.id); }
  });

  // Ensure tags & categories, map tag name -> id
  const catByName = {};
  (state.index.tagCategories||[]).forEach(c=>{ if (c?.name) catByName[c.name.toLowerCase()] = c.id; });

  const tagIdByName = {};
  (state.index.tags||[]).forEach(t=>{ if (t?.name) tagIdByName[t.name.toLowerCase()] = t.id; });

  (pack.tagsToCreate||[]).forEach(t=>{
    const name = (t?.name||"").trim().toLowerCase();
    if (!name) return;
    if (tagIdByName[name]) return;
    const cname = (t?.category||"Unsorted").trim() || "Unsorted";
    let cid = catByName[cname.toLowerCase()];
    if (!cid) {
      cid = uid();
      state.index.tagCategories.push({ id: cid, name: cname });
      catByName[cname.toLowerCase()] = cid;
    }
    const tid = uid();
    state.index.tags.push({ id: tid, name, categoryId: cid });
    tagIdByName[name] = tid;
  });

  // Normalize rule tag refs (allow tag names in packs)
  const normalizeTag = (x)=>{
    if (!x) return x;
    if (typeof x === "string") {
      const maybeId = (state.index.tags||[]).some(t=>t.id===x);
      if (maybeId) return x;
      const id = tagIdByName[x.toLowerCase()];
      return id || x;
    }
    if (typeof x === "object" && x.id) return x.id;
    return x;
  };

  const normalizeRule = (r)=>{
    const rr = deep(r);
    rr.packId = pack.packId; // TS: string
    rr.source = "pack"; // TS: "pack" | "manual"
    rr.enabled = (rr.enabled!==false);
    rr.when = rr.when || {};
    rr.then = rr.then || [];
    if (Array.isArray(rr.when.tagsAll)) rr.when.tagsAll = rr.when.tagsAll.map(normalizeTag);
    if (Array.isArray(rr.when.tagsAny)) rr.when.tagsAny = rr.when.tagsAny.map(normalizeTag);
    if (Array.isArray(rr.when.tagsNone)) rr.when.tagsNone = rr.when.tagsNone.map(normalizeTag);
    (rr.then||[]).forEach(eff=>{
      if (eff?.tag?.add) eff.tag.add = normalizeTag(eff.tag.add);
    });
    return rr;
  };

  const newRules = (pack.rulesToAdd||[]).map(normalizeRule);

  if (replaceRules) state.sim.rules = [];
  state.sim.rules = (state.sim.rules||[]).concat(newRules);

  state.sim.installedPacks.push(pack.packId);
  return { ok:true };
}



// -------------------- SIM PACK: item_schema_v0 (Layer 1) --------------------
/**
 * Item system (Layer 1) is intentionally small:
 * - "Item" is the crafted thing.
 * - "Material" / "Core" / "Rune" are components linked from the Item.
 * - Forge actions mutate facets + tags and emit events (debuggable).
 *
 * TS-READY NOTES:
 * - Tags with ":" in the name are allowed; they slugify into ids internally.
 * - Packs may also include entityTypesToAdd / facetDefsToAdd / templatesToAdd (see applySimPack extension).
 */
const PACK_ITEM_SCHEMA_V0 = {
  packId: "item_schema_v0",
  name: "Item Schema (Layer 1)",
  version: "0.1.0",
  entityTypesToAdd: [
    {id:"item", name:"Item"},
    {id:"material", name:"Material"},
    {id:"core", name:"Core"},
    {id:"rune", name:"Rune"},
  ],
  linkTypesToAdd: [
    {id:"item_uses_material", name:"Uses material (item→material)"},
    {id:"item_has_core", name:"Has core (item→core)"},
    {id:"item_has_rune", name:"Has rune (item→rune)"},
  ],
  tagsToCreate: [
    // Crafting intent + state
    { name:"crafted", category:"Craft" },
    { name:"prototype", category:"Craft" },

    // Condition states (mutually exclusive by convention)
    { name:"condition:stable", category:"Craft" },
    { name:"condition:flawed", category:"Craft" },
    { name:"condition:failed", category:"Craft" },

    // Quality tiers (soft; you can break this on purpose)
    { name:"quality:raw", category:"Craft" },
    { name:"quality:standard", category:"Craft" },
    { name:"quality:excellent", category:"Craft" },

    // Component vibes
    { name:"affinity:neutral", category:"Magic" },
  ],
  facetDefsToAdd: {
    item: [
      {key:"tier", label:"Tier"},
      {key:"quality", label:"Quality"},
      {key:"stability", label:"Stability"},
      {key:"complexity", label:"Complexity"},
      {key:"corruption", label:"Corruption"},
      {key:"rarity", label:"Rarity"},
      {key:"scope", label:"Scope"},
    ],
    material: [
      {key:"purity", label:"Purity"},
      {key:"hardness", label:"Hardness"},
      {key:"rarity", label:"Rarity"},
      {key:"attunement", label:"Attunement"},
    ],
    core: [
      {key:"potency", label:"Potency"},
      {key:"volatility", label:"Volatility"},
      {key:"rarity", label:"Rarity"},
    ],
    rune: [
      {key:"charge", label:"Charge"},
      {key:"clarity", label:"Clarity"},
      {key:"rarity", label:"Rarity"},
    ],
  },
  templatesToAdd: {
    item: [
      {key:"summary", label:"Summary", kind:"textarea"},
      {key:"function", label:"Function", kind:"textarea"},
      {key:"quirks", label:"Quirks / failure modes", kind:"textarea"},
    ],
    material: [
      {key:"summary", label:"Summary", kind:"textarea"},
      {key:"source", label:"Source", kind:"text"},
      {key:"notes", label:"Notes", kind:"textarea"},
    ],
    core: [
      {key:"summary", label:"Summary", kind:"textarea"},
      {key:"element", label:"Element / theme", kind:"text"},
      {key:"notes", label:"Notes", kind:"textarea"},
    ],
    rune: [
      {key:"summary", label:"Summary", kind:"textarea"},
      {key:"pattern", label:"Pattern", kind:"text"},
      {key:"notes", label:"Notes", kind:"textarea"},
    ],
  },
  rulesToAdd: []
};


// -------------------- SIM PACK: item_production_v0 (Layer 1) --------------------
/**
 * Adds light “production loop” rules that sit on top of Forge outcomes.
 * You can disable the pack to stop these rules without disabling crafting itself.
 */
const PACK_ITEM_PRODUCTION_V0 = {
  packId: "item_production_v0",
  name: "Item Production (Layer 1)",
  version: "0.1.0",
  tagsToCreate: [
    { name:"shopworthy", category:"Craft" },
  ],
  rulesToAdd: [
    {
      id: "R-ITEM-NOTES-FROM-STABLE-QUALITY",
      name: "Stable, high-quality items generate research notes",
      when: { typeIs: "item", tagsAll: ["condition:stable"], facet: { key:"quality", gte: 6 } },
      then: [{ resource: { key: "notes", add: 1 } }, { tag: { add: "shopworthy" } }],
      limits: { maxPerTick: 3 },
      debug: { explain: "Once an item is stable and good enough, people can study and copy it." }
    },
    {
      id: "R-ITEM-COIN-FROM-SHOPWORTHY",
      name: "Shopworthy items trickle coin",
      when: { typeIs: "item", tagsAll: ["shopworthy"], facet: { key:"tier", gte: 1 } },
      then: [{ resource: { key: "coin", add: 1 } }],
      limits: { maxPerTick: 4 },
      debug: { explain: "Simple economy: decent items can be sold or traded." }
    }
  ]
};


// -------------------- SIM PACK: item_adv_materials_v0 (Layer 1) --------------------
/**
 * Optional tag vocabulary for element/affinity experimentation.
 * This does not *drive* the world by itself—it's just the language you can link and rule against.
 */
const PACK_ITEM_ADV_MATERIALS_V0 = {
  packId: "item_adv_materials_v0",
  name: "Advanced Material Affinities (Layer 1)",
  version: "0.1.0",
  tagsToCreate: [
    { name:"affinity:fire", category:"Magic" },
    { name:"affinity:storm", category:"Magic" },
    { name:"affinity:ice", category:"Magic" },
    { name:"affinity:wood", category:"Magic" },
    { name:"affinity:iron", category:"Magic" },
    { name:"affinity:void", category:"Magic" },
    { name:"affinity:illusion", category:"Magic" },
    { name:"affinity:necromancy", category:"Magic" },
  ],
  rulesToAdd: []
};



// -------------------- SIM PACK: item_lab_v0 (Layer 2) --------------------
/**
 * Layer 2 adds *optional* laboratory actions:
 * - experimental forging (higher volatility; can create quirks)
 * - feeding (material feed) as a controlled mutation lever
 *
 * IMPORTANT: This pack is still "local-only" (items + resources). No macro-world effects.
 *
 * TS-READY NOTES:
 * - Keep action gating via UnlockStore (unlockOwned) rather than ad-hoc flags.
 * - Tag ids are resolved by name at install time (see applySimPack normalization).
 */
const PACK_ITEM_LAB_V0 = {
  packId: "item_lab_v0",
  name: "Item Lab (Layer 2)",
  version: "0.1.0",
  linkTypesToAdd: [
    {id:"item_fed_with", name:"Fed with (item→component)"},
  ],
  tagsToCreate: [
    { name:"lab:eligible", category:"Craft" },
    { name:"lab:tainted", category:"Craft" },
    { name:"condition:unstable", category:"Craft" },
  ],
  rulesToAdd: []
};


// -------------------- SIM PACK: item_artifact_v0 (Layer 2) --------------------
/**
 * Artifact-grade is still contained: it makes items *interesting* without driving the whole world.
 * Character-grade (Layer 3) is where world-driving is allowed.
 *
 * This pack adds:
 * - artifact-grade tag
 * - quirk vocabulary
 * - a harmless rule: artifact-grade items produce extra notes (study value)
 * - a link kind to express variants (used by emergence spawns)
 */
const PACK_ITEM_ARTIFACT_V0 = {
  packId: "item_artifact_v0",
  name: "Item Artifacts (Layer 2)",
  version: "0.1.0",
  linkTypesToAdd: [
    {id:"variant_of", name:"Variant of (thing→thing)"},
  ],
  tagsToCreate: [
    { name:"artifact:grade", category:"Craft" },
    { name:"artifact:named", category:"Craft" },

    // Quirk vocabulary (small but evocative)
    { name:"quirk:hunger", category:"Craft" },
    { name:"quirk:echo", category:"Craft" },
    { name:"quirk:spite", category:"Craft" },
    { name:"quirk:stormcall", category:"Craft" },
    { name:"quirk:mirror", category:"Craft" },

    { name:"condition:cursed", category:"Craft" },
  ],
  rulesToAdd: [
    {
      id: "R-ARTIFACT-NOTES-FROM-STUDY",
      name: "Artifact-grade items generate extra notes",
      when: { typeIs: "item", tagsAll: ["artifact:grade"], facet: { key:"stability", gte: 4 } },
      then: [{ resource: { key: "notes", add: 2 } }],
      limits: { maxPerTick: 2 },
      debug: { explain: "Artifact-grade items attract study and copying attempts." }
    }
  ]
};


// -------------------- SIM PACK: market_schema_v0 (Economy + Reputation) --------------------
/**
 * TS-READY NOTES:
 * Pack intent: introduce Characters + Locations + sale attribution without making items world-driving.
 * - Entity types: character, location
 * - Link kinds: crafted_by, crafted_at, listed_at, sold_to, located_in
 * - Character: global fame is stored as facets fame_pos/fame_neg (0..10)
 * - Local reputation is stored on character.fields.localRep[locationId] = {pos:number, neg:number}
 */
const PACK_MARKET_SCHEMA_V0 = {
  packId: "market_schema_v0",
  name: "Market Schema (Production Economy)",
  version: "0.1.0",
  entityTypesToAdd: [
    {id:"character", name:"Character"},
    {id:"location", name:"Location"},
  ],
  linkTypesToAdd: [
    {id:"crafted_by", name:"Crafted by (item→character)"},
    {id:"crafted_at", name:"Crafted at (item→location)"},
    {id:"listed_at", name:"Listed at (item→location)"},
    {id:"sold_to", name:"Sold to (item→character)"},
    {id:"located_in", name:"Located in (character→location)"},
  ],
  tagsToCreate: [
    { name:"item:finalized", category:"Craft" },
    { name:"item:sold", category:"Craft" },
    { name:"role:hero", category:"Social" },
    { name:"role:villain", category:"Social" },
  ],
  facetDefsToAdd: {
    character: [
      { key:"fame_pos", label:"Fame +", enabled:true },
      { key:"fame_neg", label:"Fame -", enabled:true },
    ],
    location: [
      { key:"renown", label:"Renown", enabled:true },
    ]
  },
  templatesToAdd: {
    character: [
      { key:"bio", label:"Bio", kind:"textarea" },
    ],
    location: [
      { key:"region", label:"Region", kind:"text" },
      { key:"market_note", label:"Market note", kind:"text" },
    ]
  }
};


function installDefaultSimPacks(){
  if (!state?.sim) return;
  const rs = state.sim.rules || [];
  const isStarter =
    rs.length === 2 &&
    rs.some(r=>r.id==="R-COIN-ON-BIOME") &&
    rs.some(r=>r.id==="R-BIOME-RARITY-FROM-HABITATS");
  applySimPack(PACK_INTERACTION_BASICS, { replaceRules: isStarter });
  // Layer 1: make item types/links available by default (no rules unless you install the production pack).
  applySimPack(PACK_ITEM_SCHEMA_V0, { replaceRules: false });
}


const DEFAULT_STATE = {
  index: DEFAULT_INDEX,
  quant: { defaultProfileId: null, visualWheel: false },
  world: {
    entities: [
      seedEntity("quant_profile", "Default World Scale", { powerUnits:"0,1,2,3,5,8,13,21,34,55,89", scopeMult:"1.00,1.05,1.10,1.20,1.35,1.55,1.80,2.10,2.50,3.20,4.20", prestigeUnits:"0,2,4,7,10,14,19,25,40,55,65", useWeights: JSON.stringify({power:0.25,utility:0.30,reliability:0.20,frequency:0.15,scope:0.10},null,2), effortWeights: JSON.stringify({complexity:0.45,upkeep:0.35,access:0.20},null,2), notes:"Default quant profile for this world." }, []),
      seedEntity("biome", "Gildenvale Woods", {
        summary: "A temperate forest with mossed stone ridges and soft, old magic.",
        climate: "Mild, wet",
        features: "Ridge-stones, spring-fed pools",
        resources: "Hardwood, herbs, deer",
        hazards: "Whisper-mists at dawn",
      }, []),
      seedEntity("monster", "Mireglass Leech", {
        summary: "A translucent leech that drinks heat and leaves glassy scars.",
        appearance: "Clear body, filament teeth",
        behavior: "Ambushes in still water",
        weaknesses: "Salt, fire, dryness",
        drops: "Mire core (weak), leech-filament",
      }, []),
      seedEntity("legend", "The Candle That Won’t Go Out", {
        summary: "A candle said to burn even underwater, guiding the lost to safety—or deeper ruin.",
        tellings: "Told to children in taverns near marsh roads.",
        truth: "Real, but it marks old sinkholes.",
        hook: "A missing caravan followed the candle’s glow.",
      }, []),
      seedEntity("class", "Scout", { role:"Finds paths, avoids threats, maps the unknown.", training:"Wilderness scouts, street routes, border patrols.", gear:"Light cloak, knife, sling, chalk.", signature:"Silent step, quick ambushes.", magic_notes:"", starting_skills:"Quickstep Feint; Trail-Sense" }, []),
      seedEntity("class", "Fighter", { role:"Frontline force; wins space with steel and nerve.", training:"Militia, mercenary lines, arena pits.", gear:"Weapon + armor, travel kit.", signature:"Disarm, shield bash, line-hold.", magic_notes:"", starting_skills:"Brace; Riposte" }, []),
      seedEntity("class", "Crafter", { role:"Makes tools, repairs, builds; turns scraps into leverage.", training:"Apprenticeships, guild work.", gear:"Toolkit, measuring cord, oils.", signature:"Quick repair, improv device.", magic_notes:"", starting_skills:"Patchwork Fix; Jury-rig" }, []),
      seedEntity("magic_school", "Runic Craft", { kind:"Symbols and bindings etched into matter.", strength:"5", usefulness:"7", rarity:"6", scope:"Skirmish", evolves:"yes", notes:"Runes can ‘settle’ over weeks, becoming stronger and stranger." }, []),
      seedEntity("magic_school", "Storm Calling", { kind:"Pressure, charge, wind shear; loud, volatile.", strength:"7", usefulness:"6", rarity:"7", scope:"Battlefield", evolves:"yes", notes:"Scales with weather and emotional intensity." }, []),
      seedEntity("skill", "Quickstep Feint", { description:"A sudden half-step that turns a strike into a miss.", power:"4", utility:"6", cooldown:"2", scope:"Duel", evolves:"yes", evolve_notes:"Becomes multi-step and misdirection-heavy with mastery." }, []),
      seedEntity("skill", "Barkskin Habit", { description:"A practiced bracing technique that reduces blunt trauma.", power:"5", utility:"5", cooldown:"1", scope:"Skirmish", evolves:"yes", evolve_notes:"Turns into a stance that shrugs off impacts; leaves bruised bark-marks." }, []),
    ],
    selectedEntityId: null,
    filter: { typeId: "biome", text: "", tags: [], pinnedOnly:false },
    lastRoll: null,
  },
  characters: {
    list: [ seedCharacter("Quarry-Born Scout", ["orc"], {
      Physical: { STR: 5, AGI: 6, DUR: 5, END: 5, REF: 6 },
      Mental: { INT: 4, WIT: 5, FOC: 4, MEM: 4 },
      Social: { CHA: 3, EMP: 4, DECEIT: 3, AURA: 3 },
      Metaphysical: { WILL: 5, SOUL: 4, RES: 4, LUCK: 4 }
    }) ],
    selectedId: null,
    filterText: "",
    pinnedOnly: false
  },
  generator: {
    steps: [
      seedStep("Race", "manual", [
        { id: uid(), label:"Human", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Orc", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Elf", baseWeight: 0.9, tagIds: [], notes:"" },
        { id: uid(), label:"Dwarf", baseWeight: 0.9, tagIds: [], notes:"" },
        { id: uid(), label:"Goblin", baseWeight: 0.8, tagIds: [], notes:"" },
      ]),
      seedStep("Home", "manual", [
        { id: uid(), label:"Hearthmere", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Stonehold", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Gildenvale", baseWeight: 1.0, tagIds: [], notes:"" },
      ]),
      seedStep("Class", "library:class", []),
      seedStep("Magic School", "library:magic_school", []),
      seedStep("Trait", "manual", [
        { id: uid(), label:"Mischievous", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Honourable", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Curious", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Stoic", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Ambitious", baseWeight: 0.9, tagIds: [], notes:"" },
        { id: uid(), label:"Cursed", baseWeight: 0.6, tagIds: [], notes:"" },
      ]),
      seedStep("Immediate Goal", "manual", [
        { id: uid(), label:"Explore", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Purchase a weapon", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Find work", baseWeight: 1.0, tagIds: [], notes:"" },
        { id: uid(), label:"Learn more magic", baseWeight: 0.9, tagIds: [], notes:"" },
        { id: uid(), label:"Trick someone", baseWeight: 0.7, tagIds: [], notes:"" },
      ]),
    ],
    currentStepIndex: 0,
    lastResult: null,
    candidates: null,
    history: [],
    locks: {},
    undoStack: [],
    run: { draft: "" },
    rules: {
      synergyBoost: 0.30,
      maxSynergyCount: 3,
      inversePenalty: 0.20,
      maxInverseCount: 1,
      explainWeights: true,
      softRollCount: 3
    }
  },
  sim: deep(DEFAULT_SIM),
  ui: { tab: "gen", wizard: deep(DEFAULT_WIZARD), mode: "run", focusMode: true, nav: { recent: [], history: [], index: -1 }, navQuery: "" }
};

function loadState() {
  for (const key of STORAGE_KEY_FALLBACKS) {
    const raw = localStorage.getItem(key);
    if (!raw) continue;
    try { return JSON.parse(raw); } catch { /* keep trying */ }
  }
  return deep(DEFAULT_STATE);
}

function saveState() {
  try {
    if (!state.meta) state.meta = {};
    state.meta.schemaVersion = STATE_SCHEMA_VERSION;
    state.meta.appVersion = APP_VERSION;
    state.meta.savedAt = nowISO();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    console.warn("saveState failed", e);
  }
}

// Clear caches on save
const __originalSaveState = saveState;
saveState = function() {
  try { _cache.clear(); } catch {}
  return __originalSaveState();
};

/** -------------------- STATE MIGRATION (for older localStorage) -------------------- */
function migrateState(s) {
  // Basic shape
  if (!s || typeof s !== "object") return deep(DEFAULT_STATE);

  // Ensure top-level keys exist
  if (!s.index) s.index = deep(DEFAULT_INDEX);
  if (!s.index.facetDefsByType) s.index.facetDefsByType = deep(DEFAULT_FACET_DEFS_BY_TYPE);
  // Ensure facet defs exist for all known types
  for (const t of (s.index.entityTypes||[])) {
    if (!s.index.facetDefsByType[t.id]) s.index.facetDefsByType[t.id] = deep(DEFAULT_FACET_DEFS_BY_TYPE[t.id]||[]);
  }

  // Normalize facet defs (mapsTo/enabled) so Quant can stay robust.
  const CANON_QUANT = ["power","utility","reliability","scope","frequency","complexity","upkeep","access","rarity"];
  for (const [tid, arr] of Object.entries(s.index.facetDefsByType||{})) {
    if (!Array.isArray(arr)) { s.index.facetDefsByType[tid] = []; continue; }
    arr.forEach(d=>{
      if (!d || typeof d !== "object") return;
      if (typeof d.enabled !== "boolean") d.enabled = (d.enabled !== false);
      const key = (d.key||"").trim();
      const mt = (d.mapsTo==null ? "" : String(d.mapsTo)).trim();
      if (!mt) d.mapsTo = CANON_QUANT.includes(key) ? key : "";
      else if (!CANON_QUANT.includes(mt)) d.mapsTo = CANON_QUANT.includes(key) ? key : "";
    });
  }
  if (!s.ui) s.ui = { tab: "gen", wizard: deep(DEFAULT_WIZARD) };
  if (!s.ui.facetType) s.ui.facetType = "skill";
  if (!s.ui.wizard) s.ui.wizard = deep(DEFAULT_WIZARD);
  if (!s.ui.intake) s.ui.intake = deep(DEFAULT_INTAKE);
  // Intake prompt builder defaults
  if (typeof s.ui.intake.includeTemplates !== "boolean") s.ui.intake.includeTemplates = true;
  if (typeof s.ui.intake.generateCount !== "number") s.ui.intake.generateCount = 6;
  if (!s.ui.intake.richness) s.ui.intake.richness = "balanced";

  // -------------------- NAV MIGRATION (Sprint 16) --------------------
  // TS: ui.mode is a small state machine that drives a streamlined "what should I do now" layout.
  if (!s.ui.mode) s.ui.mode = "run"; // build | run | trade | debug | meta
  if (typeof s.ui.focusMode !== "boolean") s.ui.focusMode = true;

  // -------------------- NAV SEARCH MIGRATION (Sprint 17) --------------------
  // TS: nav is ephemeral UI state; keep persisted fields tiny.
  if (!s.ui.nav) s.ui.nav = { recent: [] };
  if (!Array.isArray(s.ui.nav.recent)) s.ui.nav.recent = [];
  // -------------------- NAV HISTORY MIGRATION (Sprint 19) --------------------
  // TS: nav.history is a linear stack for back/forward + breadcrumbs.
  if (!Array.isArray(s.ui.nav.history)) s.ui.nav.history = [];
  if (typeof s.ui.nav.index !== "number") s.ui.nav.index = s.ui.nav.history.length ? (s.ui.nav.history.length - 1) : -1;
  if (typeof s.ui.navQuery !== "string") s.ui.navQuery = "";


  if (!s.world) s.world = { entities: [], selectedEntityId:null, filter:{typeId:"biome", text:"", tags:[], pinnedOnly:false}, lastRoll:null };
  if (!s.characters) s.characters = { list: [], selectedId:null, filterText:"", pinnedOnly:false };
  if (!s.generator) s.generator = deep(DEFAULT_STATE.generator);

  // Ensure quant settings exist
  if (!s.quant) s.quant = { defaultProfileId: null, visualWheel: false };
  if (typeof s.quant.visualWheel !== "boolean") s.quant.visualWheel = false;

  // -------------------- SIM MIGRATION --------------------
  if (!s.sim) s.sim = deep(DEFAULT_SIM);
  if (!s.sim.clock) s.sim.clock = deep(DEFAULT_SIM.clock);
  if (!s.sim.resources) s.sim.resources = deep(DEFAULT_SIM.resources);
  if (!s.sim.settings) s.sim.settings = deep(DEFAULT_SIM.settings);
  if (!Array.isArray(s.sim.rules)) s.sim.rules = [];
  if (!Array.isArray(s.sim.events)) s.sim.events = [];
  if (!("lastDiff" in s.sim)) s.sim.lastDiff = null;
  if (!s.sim.ui) s.sim.ui = deep(DEFAULT_SIM.ui);
  if (!s.sim.ui.eventFilter) s.sim.ui.eventFilter = deep(DEFAULT_SIM.ui.eventFilter);
  if (!s.sim.ui.market) s.sim.ui.market = deep(DEFAULT_SIM.ui.market);
  if (!("crafterId" in s.sim.ui.market)) s.sim.ui.market.crafterId = "";
  if (!("locationId" in s.sim.ui.market)) s.sim.ui.market.locationId = "";
  if (!("lastQuote" in s.sim.ui.market)) s.sim.ui.market.lastQuote = null;

  // -------------------- CRAFTING MIGRATION (Layer 1) --------------------
  if (!s.sim.crafting) s.sim.crafting = deep(DEFAULT_SIM.crafting);
  if (!s.sim.crafting.settings) s.sim.crafting.settings = deep(DEFAULT_SIM.crafting.settings);
  if (!s.sim.crafting.upgrades) s.sim.crafting.upgrades = deep(DEFAULT_SIM.crafting.upgrades);
  if (!s.sim.crafting.streaks) s.sim.crafting.streaks = deep(DEFAULT_SIM.crafting.streaks);
  if (!s.sim.crafting.streaks.perItem || typeof s.sim.crafting.streaks.perItem !== "object") s.sim.crafting.streaks.perItem = {};
  if (!s.sim.crafting.failedAtByItemId || typeof s.sim.crafting.failedAtByItemId !== "object") s.sim.crafting.failedAtByItemId = {};
  if (!("lastForge" in s.sim.crafting)) s.sim.crafting.lastForge = null;

// Crafting: backfill newly added settings/upgrades fields (for older saves)
// TS: Record<string, any> merges; keep defaults stable for later TS migration.
for (const [k,v] of Object.entries(DEFAULT_SIM.crafting.settings)){
  if (!(k in s.sim.crafting.settings)) s.sim.crafting.settings[k] = deep(v);
}
for (const [k,v] of Object.entries(DEFAULT_SIM.crafting.upgrades)){
  if (!(k in s.sim.crafting.upgrades)) s.sim.crafting.upgrades[k] = deep(v);
}



  if (!Array.isArray(s.sim.installedPacks)) s.sim.installedPacks = [];

  if (!s.sim.packMeta || typeof s.sim.packMeta !== "object") s.sim.packMeta = {};
  // Backfill pack metadata for older saves
  (s.sim.installedPacks||[]).forEach(pid=>{
    if (!pid) return;
    if (!s.sim.packMeta[pid]) s.sim.packMeta[pid] = { packId: pid, name: pid, version: "", enabled: true, installedAt: null };
    if (!("enabled" in s.sim.packMeta[pid])) s.sim.packMeta[pid].enabled = true;
  });

  // UI fields (TS: keep stable keys for later migration to TypeScript)
  if (!("packFilter" in s.sim.ui)) s.sim.ui.packFilter = "";
  if (!("packInstallText" in s.sim.ui)) s.sim.ui.packInstallText = "";
  if (!("packInstallError" in s.sim.ui)) s.sim.ui.packInstallError = "";

if (!Array.isArray(s.sim.objectives)) s.sim.objectives = [];
  if (!s.sim.objectiveMeta || typeof s.sim.objectiveMeta !== "object") s.sim.objectiveMeta = {};
if (!Array.isArray(s.sim.unlockOwned)) s.sim.unlockOwned = [];
  if (!s.sim.unlockMeta || typeof s.sim.unlockMeta !== "object") s.sim.unlockMeta = {};
  // Emergence (Sprint 9)
  if (!s.sim.emergenceSeen || typeof s.sim.emergenceSeen !== "object") s.sim.emergenceSeen = {};
  if (!("lastEmergence" in s.sim)) s.sim.lastEmergence = null;
  if (!("emergenceEnabled" in s.sim.settings)) s.sim.settings.emergenceEnabled = true;
  if (!("emergenceMaxSpawnsPerTick" in s.sim.settings)) s.sim.settings.emergenceMaxSpawnsPerTick = 2;

  // Seed starter objectives (Sprint 7) only if none exist.
  // TS: ObjectiveState shape: {id,name,desc,reward,data,completedAt,claimedAt}
  if (s.sim.objectives.length === 0){
    s.sim.objectives = [
      { id:"OBJ-STABLE-CLUSTER", name:"Stable Cluster", desc:"Maintain one coherent biome↔monsters↔class↔skills cluster for 5 ticks.", reward:{notes:5}, data:{streak:0}, completedAt:null, claimedAt:null },
      { id:"OBJ-RUNAWAY-RECOVER", name:"Runaway & Recover", desc:"Trigger a runaway, then survive 3 ticks without runaway.", reward:{notes:8}, data:{stage:"needRunaway", recover:0}, completedAt:null, claimedAt:null },
      { id:"OBJ-CROSSDOMAIN-RIPPLE", name:"Cross-domain Ripple", desc:"In one tick, have a rule cause both a resource delta and a facet delta.", reward:{notes:6}, data:{done:false}, completedAt:null, claimedAt:null },
    ];
  }



  if (!Array.isArray(s.sim.frozenEntityIds)) s.sim.frozenEntityIds = [];
  if (!s.sim.ruleRuntime || typeof s.sim.ruleRuntime !== "object") s.sim.ruleRuntime = {};
  if (typeof s.sim.settings.maxLinksPerEntityPerKind !== "number") s.sim.settings.maxLinksPerEntityPerKind = DEFAULT_SIM.settings.maxLinksPerEntityPerKind;

  // clamp numeric settings (defensive)
  s.sim.settings.tickMs = Math.max(150, Number(s.sim.settings.tickMs || DEFAULT_SIM.settings.tickMs));
  s.sim.settings.maxRuleFiringsPerTick = Math.max(1, Math.min(999, Number(s.sim.settings.maxRuleFiringsPerTick || DEFAULT_SIM.settings.maxRuleFiringsPerTick)));
  s.sim.settings.pinnedOnly = !!s.sim.settings.pinnedOnly;
  s.sim.settings.candidateLimit = Math.max(5, Math.min(200, Number(s.sim.settings.candidateLimit || DEFAULT_SIM.settings.candidateLimit)));
  s.sim.settings.maxLinksPerEntityPerKind = Math.max(1, Math.min(9999, Number(s.sim.settings.maxLinksPerEntityPerKind || DEFAULT_SIM.settings.maxLinksPerEntityPerKind)));
  s.sim.settings.emergenceEnabled = !!s.sim.settings.emergenceEnabled;
  s.sim.settings.emergenceMaxSpawnsPerTick = Math.max(0, Math.min(50, Number(s.sim.settings.emergenceMaxSpawnsPerTick || DEFAULT_SIM.settings.emergenceMaxSpawnsPerTick)));


  // -------------------- SIM: STARTER RULES (only if none) --------------------
  if (!Array.isArray(s.sim.rules) || s.sim.rules.length === 0) {
    // NOTE: these are starter toys; replace later with your real rule packs.
    // Safe even if tags are missing; they just won’t match.
    s.sim.rules = [
      {
        id: "R-COIN-ON-BIOME",
        name: "Biomes drip coin (debug bait)",
        when: { typeIs: "biome" },
        then: [{ resource: { key: "coin", add: 1 } }],
        limits: { maxPerTick: 3 }
      },
      {
        id: "R-BIOME-RARITY-FROM-HABITATS",
        name: "Many habitats increases biome rarity (toy)",
        when: { typeIs: "biome", linkCount: { kindId: "habitat", gte: 2, fromTypeId: "monster" } },
        then: [{ facet: { key: "rarity", add: 1 } }],
        limits: { maxPerTick: 2 }
      }
    ];
  }

  // Ensure Index scaffolding exists
  if (!Array.isArray(s.index.entityTypes)) s.index.entityTypes = deep(DEFAULT_INDEX.entityTypes);
  if (!Array.isArray(s.index.tagCategories)) s.index.tagCategories = deep(DEFAULT_INDEX.tagCategories);
  if (!Array.isArray(s.index.tags)) s.index.tags = [];
  if (!Array.isArray(s.index.linkTypes)) s.index.linkTypes = deep(DEFAULT_INDEX.linkTypes);

  // Ensure a Meta tag category + quarantined tag for patch tools
  const metaCatExisting = (s.index.tagCategories||[]).find(c=>c && c.name==="Meta");
  let metaCatId = metaCatExisting?.id;
  if (!metaCatId){
    metaCatId = "meta";
    if ((s.index.tagCategories||[]).some(c=>c.id===metaCatId)) metaCatId = uid();
    s.index.tagCategories.push({id: metaCatId, name:"Meta"});
  }
  const qName = "quarantined";
  const hasQ = (s.index.tags||[]).some(t=>String(t?.name||"").toLowerCase()===qName);
  if (!hasQ){
    let qId = "tag_quarantined";
    if ((s.index.tags||[]).some(t=>t.id===qId)) qId = uid();
    s.index.tags.push({id: qId, name: qName, categoryId: metaCatId});
  }


  // -------------------- LINK TYPE EXTENSIONS (safe add) --------------------
  const NEED_LINK_TYPES = [
    {id:"synergy", name:"Synergy (skill→class)"},
    {id:"habitat", name:"Habitat (monster→biome)"},
    {id:"yields", name:"Yields (resource→biome)"},
    {id:"favored_terrain", name:"Favored terrain (class→biome)"},
    {id:"enables", name:"Enables"},
    {id:"blocks", name:"Blocks"},
  ];

  const linkTypeIds = new Set((s.index.linkTypes||[]).map(x=>x.id));
  for (const lt of NEED_LINK_TYPES) {
    if (!linkTypeIds.has(lt.id)) s.index.linkTypes.push(lt);
  }
  if (!s.index.templates) s.index.templates = deep(DEFAULT_INDEX.templates);
  if (!Array.isArray(s.index.tagConflicts)) s.index.tagConflicts = [];

  // Ensure quant_profile entity type + template exist
  const hasQPType = s.index.entityTypes.some(t=>t.id==="quant_profile");
  if (!hasQPType) s.index.entityTypes.unshift({id:"quant_profile", name:"Quant Profile"});
  if (!s.index.templates.quant_profile) {
    s.index.templates.quant_profile = [
      {key:"powerUnits", label:"PowerUnits (11 comma-separated numbers for 0..10)", kind:"textarea"},
      {key:"scopeMult", label:"ScopeMult (11 comma-separated numbers for 0..10)", kind:"textarea"},
      {key:"prestigeUnits", label:"PrestigeUnits (11 comma-separated numbers for 0..10)", kind:"textarea"},
      {key:"useWeights", label:"Usefulness Weights (JSON)", kind:"textarea"},
      {key:"effortWeights", label:"Effort Weights (JSON)", kind:"textarea"},
      {key:"notes", label:"Notes", kind:"textarea"},
    ];
  }

  // Ensure world entities exist array
  if (!Array.isArray(s.world.entities)) s.world.entities = [];

  // Clamp any stored facet values to 0..10 (and normalize empties)
  const clampFacetVal = (v)=>{
    if (v==="" || v==null) return "";
    const n = Number(v);
    if (!Number.isFinite(n)) return "";
    return clamp(n, 0, 10);
  };
  s.world.entities.forEach(e=>{
    if (!e || typeof e !== "object") return;
    if (!e.fields) e.fields = {};
    if (e.fields.__facets && typeof e.fields.__facets === "object") {
      for (const k of Object.keys(e.fields.__facets)) {
        e.fields.__facets[k] = clampFacetVal(e.fields.__facets[k]);
      }
    }
  });

  // Ensure a default quant profile exists
  const qp = s.world.entities.find(e=>e.typeId==="quant_profile");
  if (!qp) {
    s.world.entities.unshift(seedEntity("quant_profile", "Default World Scale", {
      powerUnits:"0,1,2,3,5,8,13,21,34,55,89",
      scopeMult:"1.00,1.05,1.10,1.20,1.35,1.55,1.80,2.10,2.50,3.20,4.20",
      prestigeUnits:"0,2,4,7,10,14,19,25,40,55,65",
      useWeights: JSON.stringify({power:0.25,utility:0.30,reliability:0.20,frequency:0.15,scope:0.10},null,2),
      effortWeights: JSON.stringify({complexity:0.45,upkeep:0.35,access:0.20},null,2),
      notes:"Auto-created on migration."
    }, []));
  }

  // Ensure world filter has a valid type
  const typeIds = new Set(s.index.entityTypes.map(t=>t.id));
  if (!s.world.filter) s.world.filter = { typeId: "biome", text:"", tags:[], pinnedOnly:false };
  if (!("lastRoll" in s.world)) s.world.lastRoll = null;
  if (!typeIds.has(s.world.filter.typeId)) s.world.filter.typeId = "biome";

  // Ensure characters list exists and has expected keys
  if (!Array.isArray(s.characters.list)) s.characters.list = [];
  s.characters.list.forEach(c=>{
    if (!c.id) c.id = uid();
    if (!Array.isArray(c.tagIds)) c.tagIds = [];
    if (!Array.isArray(c.skillIds)) c.skillIds = [];
    if (!c.stats) c.stats = {};
    if (!("notes" in c)) c.notes = "";
    if (!("draft" in c)) c.draft = "";
  });

  // Ensure generator steps exist and are well-formed
  if (!Array.isArray(s.generator.steps) || !s.generator.steps.length) {
    s.generator.steps = deep(DEFAULT_STATE.generator.steps);
  }
  if (typeof s.generator.currentStepIndex !== "number") s.generator.currentStepIndex = 0;
  if (!s.generator.locks) s.generator.locks = {};
  if (!Array.isArray(s.generator.history)) s.generator.history = [];
  if (!s.generator.rules) s.generator.rules = deep(DEFAULT_STATE.generator.rules);
  if (!s.generator.run) s.generator.run = { draft:"" };

  // Make sure every manual option has tagIds
  s.generator.steps.forEach(st=>{
    if (!st.id) st.id = uid();
    if (!st.source) st.source = "manual";
    if (!Array.isArray(st.options)) st.options = [];
    st.options.forEach(o=>{
      if (!o.id) o.id = uid();
      if (!Array.isArray(o.tagIds)) o.tagIds = [];
      if (o.baseWeight === undefined) o.baseWeight = 1.0;
    });
  });

  return s;
}

let state;
try {
  state = migrateState(loadState());
  // stamp meta early
  if (!state.meta) state.meta = {};
  state.meta.schemaVersion = STATE_SCHEMA_VERSION;
  state.meta.appVersion = APP_VERSION;
  normalizeSeeds();
  installDefaultSimPacks();
  saveState();
} catch (e) {
  // Fall back to a safe blank state and show details.
  state = deep(DEFAULT_STATE);
  try { state = migrateState(state); } catch {}
  try { saveState(); } catch {}
  showFatal(e);
}


function tagById(id){ return state.index.tags.find(t=>t.id===id) || null; }
function tagName(id){ return tagById(id)?.name || "(tag?)"; }
function tagsInCategory(categoryId){ return state.index.tags.filter(t=>t.categoryId===categoryId); }
function entityById(id){ return state.world.entities.find(e=>e.id===id) || null; }
function entityTypeName(typeId){ return state.index.entityTypes.find(t=>t.id===typeId)?.name || typeId; }
function entityLabel(id){
  const e = entityById(id);
  if (!e) return "(missing)";
  return `${e.name} — ${entityTypeName(e.typeId)}`;
}

/* -------------------- MODULAR SCAFFOLD (pre-sprints) --------------------
These modules are intentionally small, data-first, and debuggable.
They are added BEFORE the sprint work, so future features can plug in cleanly.

Rule: only WorldMutator should write to state; everything else should plan + emit events.
-------------------------------------------------------------------------- */

const EventBus = (function(){
  const subs = new Set();
  const MAX_EVENTS = 2000;

  function emit(type, payload={}){
    const ev = {
      id: uid(),
      at: nowISO(),
      tick: state?.sim?.clock?.tick || 0,
      type,
      ...payload
    };
    const list = state.sim.events;
    list.push(ev);
    if (list.length > MAX_EVENTS) list.splice(0, list.length - MAX_EVENTS);
    for (const fn of subs) { try { fn(ev); } catch {} }
    return ev;
  }

  function query({types=null, entityId=null, ruleId=null, limit=80}={}){
    const list = state.sim.events || [];
    const out = [];
    const wantTypes = types && new Set(types);
    for (let i=list.length-1; i>=0 && out.length<limit; i--){
      const ev = list[i];
      if (wantTypes && !wantTypes.has(ev.type)) continue;
      if (ruleId && ev.ruleId !== ruleId) continue;
      if (entityId){
        const hit = (ev.entityId===entityId) || (ev.fromId===entityId) || (ev.toId===entityId);
        if (!hit) continue;
      }
      out.push(ev);
    }
    return out;
  }

  function subscribe(fn){
    subs.add(fn);
    return ()=>subs.delete(fn);
  }

  return { emit, query, subscribe };
})();

const RefResolver = (function(){
  function slugify(s){
    return String(s||"")
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  function tag(refOrName){
    if (!refOrName) return null;
    if (typeof refOrName === "object" && refOrName.id) return refOrName.id;
    const x = String(refOrName);
    if ((state.index.tags||[]).some(t=>t.id===x)) return x;
    const name = x.trim().toLowerCase();
    const found = (state.index.tags||[]).find(t=>String(t.name||"").toLowerCase()===name);
    return found ? found.id : null;
  }

  function linkType(id){
    if (!id) return null;
    return (state.index.linkTypes||[]).some(t=>t.id===id) ? id : null;
  }

  function entity(refOrHandle){
    if (!refOrHandle) return null;
    if (typeof refOrHandle === "object" && refOrHandle.id) return refOrHandle.id;
    const x = String(refOrHandle);
    if (entityById(x)) return x;
    const parts = x.split("::");
    if (parts.length === 2){
      const [typeId, slug] = parts;
      const s = slug.trim().toLowerCase();
      const e = (state.world.entities||[]).find(ent=>{
        if (ent.typeId !== typeId) return false;
        const entSlug = (ent.fields && ent.fields.slug) ? String(ent.fields.slug) : slugify(ent.name);
        return entSlug === s;
      });
      return e ? e.id : null;
    }
    return null;
  }

  return { tag, entity, linkType, slugify };
})();

const GraphIndex = (function(){
  let cache = null;

  function rebuild(){
    const inbound = new Map();   // toId -> kindId -> fromTypeId -> count
    const outbound = new Map();  // fromId -> kindId -> toTypeId -> count
    const degree = new Map();    // id -> outgoing count

    for (const e of (state.world.entities||[])){
      const links = e.links || [];
      degree.set(e.id, links.length);

      for (const l of links){
        const to = entityById(l.toId);
        const toType = to ? to.typeId : null;

        // outbound
        if (!outbound.has(e.id)) outbound.set(e.id, new Map());
        const o1 = outbound.get(e.id);
        if (!o1.has(l.kindId)) o1.set(l.kindId, new Map());
        const o2 = o1.get(l.kindId);
        const keyTo = toType || "*";
        o2.set(keyTo, (o2.get(keyTo)||0) + 1);

        // inbound
        if (!inbound.has(l.toId)) inbound.set(l.toId, new Map());
        const i1 = inbound.get(l.toId);
        if (!i1.has(l.kindId)) i1.set(l.kindId, new Map());
        const i2 = i1.get(l.kindId);
        const keyFrom = e.typeId || "*";
        i2.set(keyFrom, (i2.get(keyFrom)||0) + 1);
      }
    }

    cache = { inbound, outbound, degree };
    return cache;
  }

  function ensure(){ return cache || rebuild(); }

  function inCount(toId, kindId, fromTypeId=null){
    const c = ensure();
    const i1 = c.inbound.get(toId); if (!i1) return 0;
    const i2 = i1.get(kindId); if (!i2) return 0;
    if (!fromTypeId) { let sum = 0; for (const v of i2.values()) sum += v; return sum; }
    return i2.get(fromTypeId) || 0;
  }

  function outCount(fromId, kindId, toTypeId=null){
    const c = ensure();
    const o1 = c.outbound.get(fromId); if (!o1) return 0;
    const o2 = o1.get(kindId); if (!o2) return 0;
    if (!toTypeId) { let sum = 0; for (const v of o2.values()) sum += v; return sum; }
    return o2.get(toTypeId) || 0;
  }

  function topDegree(n=10){
    const c = ensure();
    return Array.from(c.degree.entries())
      .sort((a,b)=>b[1]-a[1])
      .slice(0,n)
      .map(([id,deg])=>({id,deg,label:entityLabel(id)}));
  }

  return { rebuild, inCount, outCount, topDegree };
})();

const WorldMutator = (function(){
  function isBlocked(entityId){
    const id = String(entityId||"");
    if (!id) return false;
    const frozen = Array.isArray(state.sim.frozenEntityIds) && state.sim.frozenEntityIds.includes(id);
    if (frozen) return true;
    const qid = RefResolver.tag("quarantined");
    if (!qid) return false;
    const e = entityById(id);
    return !!(e && (e.tagIds||[]).includes(qid));
  }

  function addResource(key, delta, meta={}){
    const k = String(key);
    const d = Number(delta||0);
    const before = Number(state.sim.resources[k]||0);
    const after = before + d;
    state.sim.resources[k] = after;
    EventBus.emit("RESOURCE_DELTA", {resource:k, delta:d, before, after, ...meta});
    return {before, after};
  }

  function addTag(entityId, tagId, meta={}){
    if (isBlocked(entityId)) { EventBus.emit("WARN",{msg:"addTag blocked", entityId, tagId, ...meta}); return false; }
    const e = entityById(entityId);
    if (!e) { EventBus.emit("WARN",{msg:"addTag missing entity", entityId, ...meta}); return false; }
    const tid = RefResolver.tag(tagId) || tagId;
    e.tagIds = e.tagIds || [];
    if (e.tagIds.includes(tid)) return false;
    e.tagIds.push(tid);
    e.updatedAt = nowISO();
    EventBus.emit("TAG_ADDED", {entityId:e.id, tagId:tid, ...meta});
    return true;
  }

  function removeTag(entityId, tagId, meta={}){
    if (isBlocked(entityId)) { EventBus.emit("WARN",{msg:"removeTag blocked", entityId, tagId, ...meta}); return false; }
    const e = entityById(entityId);
    if (!e) { EventBus.emit("WARN",{msg:"removeTag missing entity", entityId, ...meta}); return false; }
    const tid = RefResolver.tag(tagId) || tagId;
    e.tagIds = e.tagIds || [];
    const ix = e.tagIds.indexOf(tid);
    if (ix === -1) return false;
    e.tagIds.splice(ix, 1);
    e.updatedAt = nowISO();
    EventBus.emit("TAG_REMOVED", {entityId:e.id, tagId:tid, ...meta});
    return true;
  }

  function addFacet(entityId, facetKey, delta, meta={}){
    if (isBlocked(entityId)) { EventBus.emit("WARN",{msg:"addFacet blocked", entityId, facetKey, ...meta}); return null; }
    const e = entityById(entityId);
    if (!e) { EventBus.emit("WARN",{msg:"addFacet missing entity", entityId, ...meta}); return null; }
    e.fields = e.fields || {};
    e.fields.__facets = e.fields.__facets || {};
    const k = String(facetKey);
    const before = clamp10(e.fields.__facets[k] ?? 0);
    const after = clamp10(before + Number(delta||0));
    e.fields.__facets[k] = after;
    e.updatedAt = nowISO();
    EventBus.emit("FACET_DELTA", {entityId:e.id, facet:k, before, after, ...meta});
    return {before, after};
  }

  function addLink(fromId, kindId, toId, meta={}){
    if (isBlocked(fromId) || isBlocked(toId)) { EventBus.emit("WARN",{msg:"addLink blocked", fromId, toId, kindId, ...meta}); return false; }
    const from = entityById(fromId);
    if (!from) { EventBus.emit("WARN",{msg:"addLink missing from", fromId, toId, kindId, ...meta}); return false; }
    const lt = RefResolver.linkType(kindId) || kindId;
    from.links = from.links || [];
    const cap = Number(state.sim.settings.maxLinksPerEntityPerKind || 9999);
    if (cap < 9999){
      const existing = from.links.filter(l=>l && l.kindId===lt).length;
      if (existing >= cap){
        EventBus.emit("LINK_CAP_REACHED", {fromId: from.id, kindId: lt, cap, toId, ...meta});
        return false;
      }
    }
    from.links.push({kindId: lt, toId, note: meta.note || ""});
    from.updatedAt = nowISO();
    EventBus.emit("LINK_ADDED", {fromId: from.id, toId, kindId: lt, ...meta});
    return true;
  }

  function spawnEntity(spec, meta={}){
    const ent = {
      id: uid(),
      typeId: spec.typeId,
      name: spec.name || "(unnamed)",
      fields: spec.fields || {},
      tagIds: spec.tagIds || [],
      links: spec.links || [],
      pinned: false,
      createdAt: nowISO(),
      updatedAt: nowISO()
    };
    state.world.entities.push(ent);
    EventBus.emit("ENTITY_SPAWNED", {entityId: ent.id, typeId: ent.typeId, name: ent.name, ...meta});
    return ent.id;
  }

  return { addResource, addTag, removeTag, addFacet, addLink, spawnEntity, isBlocked };
})();

const DiffTracker = (function(){
  let diff = null;

  function begin(){
    diff = { tick: state.sim.clock.tick || 0, deltas: [], fired: 0, linksAdded: 0, maxAbsDelta: 0 };
    return diff;
  }
  function add(label, delta){
    if (!diff) begin();
    const d = Number(delta||0);
    diff.deltas.push({label, delta:d});
    diff.maxAbsDelta = Math.max(diff.maxAbsDelta, Math.abs(d));
  }
  function markFired(){ if (!diff) begin(); diff.fired++; }
  function markLinkAdded(){ if (!diff) begin(); diff.linksAdded++; }
  function commit(){ state.sim.lastDiff = diff; return diff; }
  function current(){ return diff; }

  return { begin, add, markFired, markLinkAdded, commit, current };
})();

const MatcherLib = (function(){
  function match(when, ctx, graph){
    const w = when || {};
    if (w.typeIs && ctx.entity?.typeId !== w.typeIs) return false;

    const tags = ctx.tags || new Set(ctx.entity?.tagIds || []);
    function normTag(x){ return RefResolver.tag(x) || x; }

    if (Array.isArray(w.tagsAll) && w.tagsAll.length){
      for (const t of w.tagsAll) if (!tags.has(normTag(t))) return false;
    }
    if (Array.isArray(w.tagsAny) && w.tagsAny.length){
      let ok = false;
      for (const t of w.tagsAny) { if (tags.has(normTag(t))) { ok = true; break; } }
      if (!ok) return false;
    }
    if (Array.isArray(w.tagsNone) && w.tagsNone.length){
      for (const t of w.tagsNone) if (tags.has(normTag(t))) return false;
    }

    if (w.linkCountIn){
      const { kindId, gte=1, lte=null, fromTypeId=null } = w.linkCountIn;
      const n = graph.inCount(ctx.entity.id, kindId, fromTypeId);
      if (n < gte) return false;
      if (lte !== null && n > lte) return false;
    }
    if (w.linkCountOut){
      const { kindId, gte=1, lte=null, toTypeId=null } = w.linkCountOut;
      const n = graph.outCount(ctx.entity.id, kindId, toTypeId);
      if (n < gte) return false;
      if (lte !== null && n > lte) return false;
    }

    if (w.facet){
      const { key, gte=null, lte=null } = w.facet;
      const val = Number(ctx.entity?.fields?.__facets?.[key] ?? 0);
      if (gte !== null && val < gte) return false;
      if (lte !== null && val > lte) return false;
    }

    return true;
  }
  return { match };
})();

const RuleEngine = (function(){
  function enabledRules(rules){
    const meta = state.sim.packMeta || {};
    return (rules||[]).filter(r=>{
      if (!r) return false;
      if (r.enabled === false) return false;
      const pid = r.packId;
      if (pid && meta[pid] && meta[pid].enabled === false) return false;
      return true;
    });
  }

  function evaluate({candidates, rules, graph, maxRuleFiringsPerTick, tick=null}){
    const out = [];
    const curTick = (tick === null) ? (state.sim.clock.tick || 0) : Number(tick||0);
    const rs = enabledRules(rules);
    const maxFires = Number(maxRuleFiringsPerTick || state.sim.settings.maxRuleFiringsPerTick || 25);
    const firedByRule = new Map();
    state.sim.ruleRuntime = state.sim.ruleRuntime && typeof state.sim.ruleRuntime==='object' ? state.sim.ruleRuntime : {};

    for (const ent of candidates){
      if (WorldMutator.isBlocked(ent.id)) continue;
      const ctx = { entity: ent, tags: new Set(ent.tagIds||[]) };
      for (const rule of rs){
        if (out.length >= maxFires) break;
        const perTick = Number((rule.limits||{}).maxPerTick || 999);
        const soFar = firedByRule.get(rule.id) || 0;
        if (soFar >= perTick) continue;
        const cd = Number((rule.limits||{}).cooldownTicks || 0);
        if (cd > 0){
          const rt = state.sim.ruleRuntime[rule.id] || (state.sim.ruleRuntime[rule.id] = {lastFiredTick: null});
          if (rt.lastFiredTick !== null && (curTick - Number(rt.lastFiredTick||0)) < cd) continue;
        }
        if (!MatcherLib.match(rule.when, ctx, graph)) continue;

        firedByRule.set(rule.id, soFar + 1);
        if (Number((rule.limits||{}).cooldownTicks||0) > 0){
          const rt = state.sim.ruleRuntime[rule.id] || (state.sim.ruleRuntime[rule.id] = {lastFiredTick: null});
          rt.lastFiredTick = curTick;
        }
        out.push({ ruleId: rule.id, entityId: ent.id, rule, ctx });
      }
      if (out.length >= maxFires) break;
    }
    return out;
  }

  return { evaluate };
})();

const EffectApplier = (function(){
  function apply(fired){
    const tickReport = { fired: 0, linksAdded: 0, maxAbsDelta: 0 };
    for (const fr of fired){
      tickReport.fired++;
      DiffTracker.markFired();
      EventBus.emit("RULE_FIRED", {ruleId: fr.ruleId, entityId: fr.entityId, name: fr.rule?.name || fr.ruleId});

      for (const eff of (fr.rule.then || [])){
        if (eff.resource){
          const {key, add} = eff.resource;
          WorldMutator.addResource(key, add, {ruleId: fr.ruleId, entityId: fr.entityId});
          DiffTracker.add(`res.${key}`, Number(add||0));
          tickReport.maxAbsDelta = Math.max(tickReport.maxAbsDelta, Math.abs(Number(add||0)));
        }
        if (eff.tag?.add){
          const tid = RefResolver.tag(eff.tag.add);
          if (!tid) EventBus.emit("WARN", {ruleId: fr.ruleId, entityId: fr.entityId, msg:`Unknown tag: ${eff.tag.add}`});
          else WorldMutator.addTag(fr.entityId, tid, {ruleId: fr.ruleId});
        }
        if (eff.facet){
          const {key, add} = eff.facet;
          const r = WorldMutator.addFacet(fr.entityId, key, add, {ruleId: fr.ruleId});
          if (r) DiffTracker.add(`${entityById(fr.entityId)?.name||"entity"}.${key}`, r.after - r.before);
        }
        if (eff.link){
          const fromId = RefResolver.entity(eff.link.fromId || eff.link.from) || eff.link.fromId || eff.link.from;
          const toId = RefResolver.entity(eff.link.toId || eff.link.to) || eff.link.toId || eff.link.to;
          if (fromId && toId){
            WorldMutator.addLink(fromId, eff.link.kindId, toId, {ruleId: fr.ruleId, note: eff.link.note || ""});
            DiffTracker.markLinkAdded();
            tickReport.linksAdded++;
          }
        }
        if (eff.emit){
          EventBus.emit(eff.emit.type, {ruleId: fr.ruleId, entityId: fr.entityId, data: eff.emit.data});
        }
      }
    }
    const cur = DiffTracker.current();
    if (cur) tickReport.maxAbsDelta = Math.max(tickReport.maxAbsDelta, cur.maxAbsDelta||0);
    return tickReport;
  }
  return { apply };
})();

const RunawayDetector = (function(){
  function check(){
    const diff = state.sim.lastDiff;
    const R = state.sim.settings.runaway || {};
    const runaway =
      (diff && diff.fired > (R.maxRuleFirings||80)) ||
      (diff && diff.linksAdded > (R.maxLinksAdded||25)) ||
      (diff && diff.maxAbsDelta > (R.maxAbsDelta||25));
    if (!runaway) return null;

    const suspects = {
      topDegree: GraphIndex.topDegree(5),
      topRulesByFires: (function(){
        const tick = state.sim.clock.tick || 0;
        const fires = EventBus.query({types:["RULE_FIRED"], tick, limit: 500});
        const m = {};
        for (const ev of fires) m[ev.ruleId||"(none)"] = (m[ev.ruleId||"(none)"]||0)+1;
        return Object.entries(m).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([ruleId,n])=>({ruleId,n}));
      })()
    };
    const ev = EventBus.emit("RUNAWAY_DETECTED", {
      fired: diff?.fired || 0,
      linksAdded: diff?.linksAdded || 0,
      maxAbsDelta: diff?.maxAbsDelta || 0,
      suspects
    });
    if (state.sim.settings.stopOnRunaway) state.sim.settings.autoTick = false;
    return {event: ev, suspects};
  }
  return { check };
})();

const Inspector = (function(){
  function traceEntity(entityId, {limit=80}={}){
    const events = EventBus.query({entityId, limit});
    const byRule = {};
    for (const ev of events){
      const rid = ev.ruleId || "(none)";
      byRule[rid] = (byRule[rid]||0) + 1;
    }
    const topRules = Object.entries(byRule)
      .sort((a,b)=>b[1]-a[1])
      .slice(0,5)
      .map(([ruleId,n])=>({ruleId,n}));

    const birth = events.find(e=>e.type==="ENTITY_SPAWNED" && e.entityId===entityId) || null;

    const summary = topRules.map(x=>`${x.ruleId}: ${x.n}`).join(", ");
    return { entityId, events, topRules, birth, summary };
  }

  function traceValue(path, {limit=80}={}){
    const m = String(path||"").match(/^res\.(.+)$/);
    if (!m) return {path, events:[], summary:"Unsupported path"};
    const key = m[1];
    const events = EventBus.query({types:["RESOURCE_DELTA"], limit:limit*3}).filter(e=>e.resource===key).slice(0,limit);
    const summary = `resource ${key}: ${events.length} deltas`;
    return { path, events, summary };
  }

  return { traceEntity, traceValue };
})();


const PatchTools = (function(){
  function isFrozen(entityId){
    return Array.isArray(state.sim.frozenEntityIds) && state.sim.frozenEntityIds.includes(String(entityId||""));
  }
  function freeze(entityId){
    const id = String(entityId||"");
    if (!id) return false;
    state.sim.frozenEntityIds = state.sim.frozenEntityIds || [];
    if (state.sim.frozenEntityIds.includes(id)) return false;
    state.sim.frozenEntityIds.push(id);
    EventBus.emit("ENTITY_FROZEN", {entityId:id});
    return true;
  }
  function unfreeze(entityId){
    const id = String(entityId||"");
    state.sim.frozenEntityIds = state.sim.frozenEntityIds || [];
    const ix = state.sim.frozenEntityIds.indexOf(id);
    if (ix === -1) return false;
    state.sim.frozenEntityIds.splice(ix, 1);
    EventBus.emit("ENTITY_UNFROZEN", {entityId:id});
    return true;
  }
  function clearFrozen(){
    const n = (state.sim.frozenEntityIds||[]).length;
    state.sim.frozenEntityIds = [];
    EventBus.emit("FROZEN_CLEARED", {count:n});
    return n;
  }
  function quarantinedTagId(){
    return RefResolver.tag("quarantined");
  }
  function isQuarantined(entityId){
    const e = entityById(entityId);
    const qid = quarantinedTagId();
    return !!(e && qid && (e.tagIds||[]).includes(qid));
  }
  function toggleQuarantine(entityId){
    const qid = quarantinedTagId();
    if (!qid) { EventBus.emit("WARN",{msg:"Missing quarantined tag"}); return false; }
    if (isQuarantined(entityId)){
      WorldMutator.removeTag(entityId, qid, {note:"patch"});
      return false;
    } else {
      WorldMutator.addTag(entityId, qid, {note:"patch"});
      return true;
    }
  }
  return { isFrozen, freeze, unfreeze, clearFrozen, isQuarantined, toggleQuarantine };
})();


const SimClock = (function(){
  let lastAutoAtMs = 0;

  function getCandidates({pinnedOnly=null, limit=null}={}){
    const po = (pinnedOnly === null) ? !!state.sim.settings.pinnedOnly : !!pinnedOnly;
    const lim = Number(limit || state.sim.settings.candidateLimit || 25);
    const ents = state.world.entities || [];
    if (po){
      const pinned = ents.filter(e=>e.pinned);
      return pinned.length ? pinned.slice(0, lim) : ents.slice(0, lim);
    }
    // prefer pinned first, then fill
    const pinned = ents.filter(e=>e.pinned);
    const rest = ents.filter(e=>!e.pinned);
    return pinned.concat(rest).slice(0, lim);
  }

  function tickOnce({candidates=null}={}){
    const tick = state.sim.clock.tick || 0;
    EventBus.emit("TICK_START", {tick});

    GraphIndex.rebuild();
    DiffTracker.begin();

    const cand = candidates || getCandidates();
    const fired = RuleEngine.evaluate({
      candidates: cand,
      rules: RuleRegistry.list({enabledOnly:true}),
      graph: GraphIndex,
      maxRuleFiringsPerTick: state.sim.settings.maxRuleFiringsPerTick,
      tick
    });

    const tickReport = EffectApplier.apply(fired);
    const diff = DiffTracker.commit();

    state.sim.clock.lastTickAt = nowISO();

    const runaway = RunawayDetector.check();

    // Objectives run inside the same tick number (before we advance the clock).
    const objectiveUpdates = ObjectiveEngine.evaluateTick({
      tick,
      runaway: !!runaway,
      graph: GraphIndex,
      diff,
      tickReport
    });

    const emergence = EmergenceEngine.onTick({tick, runaway: !!runaway, runawayInfo: runaway});

    EventBus.emit("TICK_END", {
      tick,
      fired: diff?.fired || 0,
      linksAdded: diff?.linksAdded || 0,
      maxAbsDelta: diff?.maxAbsDelta || 0,
      runaway: !!runaway,
      objectiveUpdates: objectiveUpdates.length,
      emergenceSpawns: (emergence?.spawns||[]).length
    });

    // advance tick AFTER processing (events in this tick share the same tick number)
    state.sim.clock.tick = tick + 1;

    return { tick, candidates: cand.length, firedCount: fired.length, tickReport, diff, runaway, objectiveUpdates, emergence };
  }

  function maybeAutoTick(){
    if (!state?.sim?.settings?.autoTick) return;
    const ms = Number(state.sim.settings.tickMs || 1500);
    const now = Date.now();
    if (now - lastAutoAtMs < ms) return;
    lastAutoAtMs = now;

    tickOnce();
    saveState();
    renderPreserveFocus();
  }

  function setAuto(on){
    state.sim.settings.autoTick = !!on;
    if (on) lastAutoAtMs = 0;
  }

  function setTickMs(ms){
    state.sim.settings.tickMs = Math.max(150, Number(ms || 1500));
  }

  return { tickOnce, maybeAutoTick, getCandidates, setAuto, setTickMs };
})();

// -------------------- PACKS (Sprint 6) --------------------
/**
 * TS-READY NOTES:
 * - Keep pack schema stable: PackV0 { packId, name, version, linkTypesToAdd?, tagsToCreate?, rulesToAdd? }.
 * - Prefer explicit string ids; avoid mixing tag names and ids where possible.
 * - In TS: define unions for Effect types and Matcher shapes.
 */
const PackValidator = (function(){
  /** @returns {string[]} error messages */
  function validate(pack){
    const errs = [];
    if (!pack || typeof pack !== "object") return ["Pack must be an object"];
    if (!pack.packId || typeof pack.packId !== "string") errs.push("packId must be a string");
    if (!pack.name || typeof pack.name !== "string") errs.push("name must be a string");
    if (!pack.version || typeof pack.version !== "string") errs.push("version must be a string");

    const pid = String(pack.packId||"").trim();
    if (pid && !/^[a-z0-9_\-]+$/i.test(pid)) errs.push("packId should be alphanumeric/_/-");

    const lts = pack.linkTypesToAdd || [];
    if (!Array.isArray(lts)) errs.push("linkTypesToAdd must be an array");
    else {
      lts.forEach((lt,i)=>{
        if (!lt || typeof lt !== "object") errs.push(`linkTypesToAdd[${i}] must be an object`);
        else {
          if (!lt.id || typeof lt.id !== "string") errs.push(`linkTypesToAdd[${i}].id missing`);
          if (!lt.name || typeof lt.name !== "string") errs.push(`linkTypesToAdd[${i}].name missing`);
        }
      });
    }

    const tags = pack.tagsToCreate || [];
    if (!Array.isArray(tags)) errs.push("tagsToCreate must be an array");
    else {
      tags.forEach((t,i)=>{
        if (!t || typeof t !== "object") errs.push(`tagsToCreate[${i}] must be an object`);
        else {
          if (!t.name || typeof t.name !== "string") errs.push(`tagsToCreate[${i}].name missing`);
          if (!t.category || typeof t.category !== "string") errs.push(`tagsToCreate[${i}].category missing`);
        }
      });
    }

    const rules = pack.rulesToAdd || [];
    if (!Array.isArray(rules)) errs.push("rulesToAdd must be an array");
    else {
      const ids = new Set();
      rules.forEach((r,i)=>{
        if (!r || typeof r !== "object") errs.push(`rulesToAdd[${i}] must be an object`);
        else {
          if (!r.id || typeof r.id !== "string") errs.push(`rulesToAdd[${i}].id missing`);
          else {
            if (ids.has(r.id)) errs.push(`Duplicate rule id in pack: ${r.id}`);
            ids.add(r.id);
          }
          if (!r.when || typeof r.when !== "object") errs.push(`rulesToAdd[${i}].when missing`);
          if (!Array.isArray(r.then)) errs.push(`rulesToAdd[${i}].then must be an array`);
        }
      });
    }

    return errs;
  }
  return { validate };
})();

const PackManager = (function(){
  function listPacks(){
    const ids = state.sim.installedPacks || [];
    const meta = state.sim.packMeta || {};
    return ids.map(id=>meta[id] || {packId:id, name:id, version:"", enabled:true, installedAt:null});
  }

  function isInstalled(packId){
    return (state.sim.installedPacks||[]).includes(packId);
  }

  function install(pack, {replaceRules=false}={}){
    const errs = PackValidator.validate(pack);
    if (errs.length){
      EventBus.emit("PACK_INSTALL_FAILED", {packId: pack?.packId||"(unknown)", errors: errs});
      return {ok:false, errors: errs};
    }
    const pid = pack.packId;

    // Apply (idempotent)
    const r = applySimPack(pack, {replaceRules});
    if (!r.ok){
      EventBus.emit("PACK_INSTALL_FAILED", {packId: pid, errors: [r.reason||"apply failed"]});
      return {ok:false, errors:[r.reason||"apply failed"]};
    }

    // Write metadata
    state.sim.packMeta = state.sim.packMeta || {};
    if (!state.sim.packMeta[pid]){
      state.sim.packMeta[pid] = { packId: pid, name: pack.name, version: pack.version, enabled: true, installedAt: nowISO() };
    } else {
      // update name/version, keep enabled
      state.sim.packMeta[pid].name = pack.name;
      state.sim.packMeta[pid].version = pack.version;
      if (!("enabled" in state.sim.packMeta[pid])) state.sim.packMeta[pid].enabled = true;
      if (!state.sim.packMeta[pid].installedAt) state.sim.packMeta[pid].installedAt = nowISO();
    }

    // Ensure all rules from this pack have packId stamp (older installs)
    (state.sim.rules||[]).forEach(rule=>{
      if (rule && rule.source==="pack" && !rule.packId) rule.packId = pid;
    });

    EventBus.emit("PACK_INSTALLED", {packId: pid, name: pack.name, version: pack.version});
    return {ok:true, already: !!r.already};
  }

  function enable(packId, enabled){
    state.sim.packMeta = state.sim.packMeta || {};
    const m = state.sim.packMeta[packId] || (state.sim.packMeta[packId] = {packId:packId, name:packId, version:"", enabled:true, installedAt:null});
    m.enabled = !!enabled;
    EventBus.emit(enabled ? "PACK_ENABLED" : "PACK_DISABLED", {packId});
    return true;
  }

  function packEnabled(packId){
    if (!packId) return true;
    const m = state.sim.packMeta && state.sim.packMeta[packId];
    return !(m && m.enabled === false);
  }

  return { listPacks, isInstalled, install, enable, packEnabled };
})();

// -------------------- OBJECTIVES (Sprint 7) --------------------
/**
 * TS-READY NOTES:
 * - ObjectiveState persists player progress.
 * - In TS: type ObjectiveReward = Partial<Record<"coin"|"notes", number>>.
 * - ObjectiveState = { id, name, desc, reward, data, completedAt, claimedAt }.
 */

/** @typedef {{ coin?: number, notes?: number }} ObjectiveReward */
/** @typedef {{ id: string, name: string, desc: string, reward: ObjectiveReward, data: any, completedAt: string|null, claimedAt: string|null }} ObjectiveState */

const RewardApplier = (function(){
  /** Grant resources for an objective (TS: keep meta shape stable). */
  function grant(reward, meta={}){
    if (!reward || typeof reward !== "object") return {ok:false, reason:"no reward"};
    const deltas = [];
    for (const k of Object.keys(reward)){
      const v = Number(reward[k]||0);
      if (!v) continue;
      WorldMutator.addResource(k, v, { source:"objective", objectiveId: meta.objectiveId||"", tick: meta.tick });
      deltas.push({key:k, delta:v});
    }
    EventBus.emit("REWARD_GRANTED", { objectiveId: meta.objectiveId||"", deltas, tick: meta.tick });
    return {ok:true, deltas};
  }
  return { grant };
})();

const ObjectiveEngine = (function(){
  // Definitions are pure logic; state lives in state.sim.objectives.
  const DEFS = [
    {
      id:"OBJ-STABLE-CLUSTER",
      name:"Stable Cluster",
      desc:"Maintain one coherent biome↔monsters↔class↔skills cluster for 5 ticks.",
      reward:{notes:5},
      check: function(ctx, st){
        st.data = st.data || {};
        const hit = findStableCluster();
        if (hit){
          st.data.streak = Number(st.data.streak||0) + 1;
          st.data.lastHit = hit;
        } else {
          st.data.streak = 0;
          st.data.lastHit = null;
        }
        const streak = Number(st.data.streak||0);
        const target = 5;
        return {
          changed: true,
          progressText: hit ? `streak ${streak}/${target} (biome ${hit.biomeName}, class ${hit.className})` : "no valid cluster this tick",
          complete: streak >= target
        };
      }
    },
    {
      id:"OBJ-RUNAWAY-RECOVER",
      name:"Runaway & Recover",
      desc:"Trigger a runaway, then survive 3 ticks without runaway.",
      reward:{notes:8},
      check: function(ctx, st){
        st.data = st.data || {};
        st.data.stage = st.data.stage || "needRunaway"; // TS: "needRunaway" | "recovering"
        st.data.recover = Number(st.data.recover||0);
        let changed = false;

        if (st.data.stage === "needRunaway"){
          if (ctx.runaway){
            st.data.stage = "recovering";
            st.data.recover = 0;
            changed = true;
          }
          return { changed:true, progressText: ctx.runaway ? "runaway triggered — now recover 0/3" : "waiting for runaway", complete:false };
        }

        // recovering
        if (ctx.runaway){
          st.data.recover = 0;
          changed = true;
        } else {
          st.data.recover += 1;
          changed = true;
        }
        const target = 3;
        const r = st.data.recover;
        return { changed, progressText: `recovering ${r}/${target}` + (ctx.runaway ? " (reset by runaway)" : ""), complete: r >= target };
      }
    },
    {
      id:"OBJ-CROSSDOMAIN-RIPPLE",
      name:"Cross-domain Ripple",
      desc:"In one tick, have a rule cause both a resource delta and a facet delta.",
      reward:{notes:6},
      check: function(ctx, st){
        st.data = st.data || {};
        if (st.data.done) return { changed:false, progressText:"done", complete:true };
        const evs = eventsForTick(ctx.tick, 800);
        const byRule = {};
        for (const ev of evs){
          if (!ev.ruleId) continue;
          if (ev.type !== "RESOURCE_DELTA" && ev.type !== "FACET_DELTA") continue;
          byRule[ev.ruleId] = byRule[ev.ruleId] || new Set();
          byRule[ev.ruleId].add(ev.type);
        }
        const hit = Object.entries(byRule).find(([rid,set])=>set.has("RESOURCE_DELTA") && set.has("FACET_DELTA"));
        if (hit){
          st.data.done = true;
          st.data.ruleId = hit[0];
          return { changed:true, progressText:`hit via ${hit[0]}`, complete:true };
        }
        return { changed:true, progressText:"no cross-domain ripple yet", complete:false };
      }
    },

    // -------------------- CRAFTING OBJECTIVES (Layer 1) --------------------
    {
      id:"OBJ-FORGE-FIRST-STABLE",
      name:"Forge: first stable item",
      desc:"Get any Item into a stable condition via the Forge.",
      reward:{notes:5},
      check: function(meta){
        const stable = RefResolver.tag("condition:stable");
        if (!stable) return {changed:true, progressText:"(missing tag: condition:stable)", complete:false};
        const hit = (state.world.entities||[]).find(e=>e.typeId==="item" && (e.tagIds||[]).includes(stable));
        if (hit) return {changed:true, progressText:`stable: ${hit.name}`, complete:true};
        return {changed:true, progressText:"no stable item yet", complete:false};
      }
    },
    {
      id:"OBJ-FORGE-3-SUCCESS-STREAK",
      name:"Forge: 3 successes in a row",
      desc:"Get 3 successful forge outcomes in a row (global streak).",
      reward:{notes:7},
      check: function(meta){
        const n = Number(state.sim?.crafting?.streaks?.consecutiveSuccesses||0);
        if (n >= 3) return {changed:true, progressText:`streak ${n}`, complete:true};
        return {changed:true, progressText:`streak ${n}/3`, complete:false};
      }
    },
    {
      id:"OBJ-FORGE-RECOVER-FAILED-5T",
      name:"Forge: recover a failed item",
      desc:"Turn a failed item stable again within 5 ticks of failure.",
      reward:{notes:10},
      check: function(meta){
        const tick = state.sim.clock.tick || 0;
        const stable = RefResolver.tag("condition:stable");
        const failedAt = state.sim?.crafting?.failedAtByItemId || {};
        for (const [itemId, t0] of Object.entries(failedAt)){
          const e = entityById(itemId);
          if (!e || e.typeId!=="item") continue;
          const age = tick - Number(t0||0);
          if (age < 0) continue;
          const isStable = stable && (e.tagIds||[]).includes(stable);
          if (isStable && age <= 5){
            return {changed:true, progressText:`recovered ${e.name} in ${age} ticks`, complete:true};
          }
        }
        return {changed:true, progressText:"no recovery within 5 ticks yet", complete:false};
      }
    },

  ];

  function defs(){ return DEFS.slice(); }

  function ensure(){
    state.sim.objectives = state.sim.objectives || [];
    // Add missing objectives (id-stable)
    const have = new Set(state.sim.objectives.map(o=>o.id));
    for (const d of DEFS){
      if (!have.has(d.id)){
        state.sim.objectives.push({ id:d.id, name:d.name, desc:d.desc, reward: deep(d.reward||{}), data:{}, completedAt:null, claimedAt:null });
      }
    }
    // Backfill names/desc in case of updates
    for (const o of state.sim.objectives){
      const d = DEFS.find(x=>x.id===o.id);
      if (!d) continue;
      if (!o.name) o.name = d.name;
      if (!o.desc) o.desc = d.desc;
      if (!o.reward) o.reward = deep(d.reward||{});
      if (!o.data) o.data = {};
      if (!("completedAt" in o)) o.completedAt = null;
      if (!("claimedAt" in o)) o.claimedAt = null;
    }
  }

  function get(id){
    ensure();
    return (state.sim.objectives||[]).find(o=>o.id===id) || null;
  }

  function isCompleted(st){ return !!st?.completedAt; }
  function isClaimed(st){ return !!st?.claimedAt; }

  function evaluateTick(ctx){
    ensure();
    const updates = [];
    for (const d of DEFS){
      const st = get(d.id);
      if (!st) continue;
      if (isCompleted(st)) continue;

      const res = d.check(ctx, st) || {};
      if (res.changed){
        EventBus.emit("OBJECTIVE_PROGRESS", { objectiveId: st.id, name: st.name, progress: res.progressText||"", tick: ctx.tick });
        updates.push({objectiveId: st.id, progress: res.progressText||""});
      }
      if (res.complete){
        st.completedAt = nowISO();
        EventBus.emit("OBJECTIVE_COMPLETED", { objectiveId: st.id, name: st.name, reward: st.reward||{}, tick: ctx.tick });
      }
    }
    return updates;
  }

  function claim(objectiveId){
    const st = get(objectiveId);
    if (!st) return {ok:false, reason:"missing"};
    if (!isCompleted(st)) return {ok:false, reason:"not completed"};
    if (isClaimed(st)) return {ok:false, reason:"already claimed"};
    st.claimedAt = nowISO();
    const r = RewardApplier.grant(st.reward||{}, {objectiveId: st.id, tick: state.sim.clock.tick||0});
    return {ok:true, reward:r, objectiveId: st.id};
  }

  // Helpers (kept local for TS extraction later)
  function eventsForTick(tick, limit=800){
    const out = [];
    const list = state.sim.events || [];
    for (let i=list.length-1; i>=0 && out.length<limit; i--){
      const ev = list[i];
      if (ev.tick !== tick) {
        if (out.length) break; // stop once we’ve collected this tick’s tail
        continue;
      }
      out.push(ev);
    }
    return out;
  }

  function hasExactLink(fromId, kindId, toId){
    const e = entityById(fromId);
    if (!e) return false;
    const links = e.links || [];
    return links.some(l=>l && l.kindId===kindId && l.toId===toId);
  }

  function findStableCluster(){
    const ents = state.world.entities || [];
    const biomes = ents.filter(e=>e.typeId==="biome");
    const classes = ents.filter(e=>e.typeId==="class");
    for (const b of biomes){
      const habitat = GraphIndex.inCount(b.id, "habitat", "monster");
      if (habitat < 2) continue;
      for (const c of classes){
        // Must be favored to THIS biome (exact link), not just any biome.
        if (!hasExactLink(c.id, "favored_terrain", b.id)) continue;
        const skills = GraphIndex.inCount(c.id, "synergy", "skill");
        if (skills < 2) continue;
        return { biomeId: b.id, biomeName: b.name, classId: c.id, className: c.name, habitatCount: habitat, skillCount: skills };
      }
    }
    return null;
  }

  return { defs, ensure, get, evaluateTick, claim, isCompleted, isClaimed };
})();



// -------------------- UNLOCKS (Sprint 8) --------------------
/**
 * TS-READY NOTES:
 * Unlock schema (UnlockDef):
 * { id: string, name: string, desc: string, cost: { notes?: number, coin?: number }, apply: (meta)=>void }
 *
 * Persisted state:
 * - state.sim.unlockOwned: string[]
 * - state.sim.unlockMeta: { [unlockId:string]: { purchasedAt?: string } }
 */
const UnlockStore = (function(){
  /** @type {Array<any>} */ // TS: UnlockDef[]
  const UNLOCKS = [
    {
      id:"UNL-TRADE-BASICS",
      name:"Unlock: Trade Basics pack",
      desc:"Adds trade link types and simple economy rules (coin from trade activity).",
      cost:{notes:8},
      apply: function(meta){
        PackManager.install(PACK_TRADE_BASICS);
        EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-TRADE-BASICS", kind:"pack", packId: PACK_TRADE_BASICS.packId, tick: meta.tick});
      }
    },
    {
      id:"UNL-ECOLOGY-BASICS",
      name:"Unlock: Ecology Basics pack",
      desc:"Adds predator/prey link types and light ecology pressure rules.",
      cost:{notes:12},
      apply: function(meta){
        PackManager.install(PACK_ECOLOGY_BASICS);
        EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-ECOLOGY-BASICS", kind:"pack", packId: PACK_ECOLOGY_BASICS.packId, tick: meta.tick});
      }
    },
    {
      id:"UNL-EXTRA-PATCH-BUDGET",
      name:"Unlock: Extra patch budget",
      desc:"Raises the per-tick max rule firings cap (lets you explore higher volatility safely).",
      cost:{notes:6},
      apply: function(meta){
        // TS: This is a simple persistent upgrade; keep numeric values stable for later TS migration.
        state.sim.settings.maxRuleFiringsPerTick = Math.min(200, Number(state.sim.settings.maxRuleFiringsPerTick||25) + 25);
        EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-EXTRA-PATCH-BUDGET", kind:"setting", key:"maxRuleFiringsPerTick", tick: meta.tick});
      }
    }
    ,
    // -------------------- CRAFTING UNLOCKS (Layer 1) --------------------
    {
      id:"UNL-ITEM-TOOLS",
      name:"Unlock: Better forging tools",
      desc:"Reduces forge risk slightly and improves stability on success.",
      cost:{notes:10, coin:5},
      apply: function(meta){
        state.sim.crafting.upgrades.toolsBonus = Number(state.sim.crafting.upgrades.toolsBonus||0) + 1;
        EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-ITEM-TOOLS", kind:"crafting_upgrade", key:"toolsBonus", tick: meta.tick});
      }
    },
    {
      id:"UNL-ITEM-RUNE-SLOT",
      name:"Unlock: Extra rune slot",
      desc:"Allows one additional rune on low-tier items without extra risk.",
      cost:{notes:12, coin:8},
      apply: function(meta){
        state.sim.crafting.upgrades.extraRuneSlot = true;
        EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-ITEM-RUNE-SLOT", kind:"crafting_upgrade", key:"extraRuneSlot", tick: meta.tick});
      }
    },
    {
      id:"UNL-ITEM-ADV_MATERIALS",
      name:"Unlock: Advanced material affinities pack",
      desc:"Adds a larger affinity vocabulary (fire, storm, void, etc.) for experimentation.",
      cost:{notes:9},
      apply: function(meta){
        PackManager.install(PACK_ITEM_ADV_MATERIALS_V0);
        EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-ITEM-ADV_MATERIALS", kind:"pack", packId: PACK_ITEM_ADV_MATERIALS_V0.packId, tick: meta.tick});
      }
    }

,
// -------------------- CRAFTING UNLOCKS (Layer 2) --------------------
{
  id:"UNL-ITEM-LAB",
  name:"Unlock: Laboratory mode",
  desc:"Enables Lab mode forging (higher volatility) and adds the Item Lab pack.",
  cost:{notes:18, coin:10},
  apply: function(meta){
    state.sim.crafting.upgrades.labUnlocked = true;
    PackManager.install(PACK_ITEM_LAB_V0);
    EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-ITEM-LAB", kind:"crafting_upgrade", key:"labUnlocked", tick: meta.tick});
  }
},
{
  id:"UNL-ITEM-FEEDING",
  name:"Unlock: Feeding actions",
  desc:"Allows feeding materials/cores into items during Lab mode (controlled mutation lever).",
  cost:{notes:14, coin:12},
  apply: function(meta){
    state.sim.crafting.upgrades.feedingUnlocked = true;
    EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-ITEM-FEEDING", kind:"crafting_upgrade", key:"feedingUnlocked", tick: meta.tick});
  }
},
{
  id:"UNL-ITEM-ARTIFACTS",
  name:"Unlock: Artifact-grade promotion",
  desc:"Adds Artifact-grade tags/quirks and enables artifact promotion checks (still local-only).",
  cost:{notes:22, coin:15},
  apply: function(meta){
    state.sim.crafting.upgrades.artifactUnlocked = true;
    PackManager.install(PACK_ITEM_ARTIFACT_V0);
    EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-ITEM-ARTIFACTS", kind:"crafting_upgrade", key:"artifactUnlocked", tick: meta.tick});
  }
}


  
    ,
    {
      id:"UNL-MARKET-BASICS",
      name:"Unlock: Market Basics",
      desc:"Adds Characters + Locations schema and enables finalized items to be priced and sold (with reputation & fame).",
      cost:{notes:10},
      apply: function(meta){
        PackManager.install(PACK_MARKET_SCHEMA_V0);
        EventBus.emit("UNLOCK_APPLIED", {unlockId:"UNL-MARKET-BASICS", kind:"pack", packId: PACK_MARKET_SCHEMA_V0.packId, tick: meta.tick});
      }
    }
];

  function ownedSet(){
    return new Set(state.sim.unlockOwned || []);
  }

  function canAfford(u){
    const notes = Number(state.sim.resources.notes||0);
    const coin = Number(state.sim.resources.coin||0);
    const needN = Number(u.cost?.notes||0);
    const needC = Number(u.cost?.coin||0);
    return notes >= needN && coin >= needC;
  }

  function listAll(){
    const owned = ownedSet();
    return UNLOCKS.map(u=>{
      const isOwned = owned.has(u.id);
      return {
        ...u,
        owned: isOwned,
        canAfford: !isOwned && canAfford(u)
      };
    });
  }

  function buy(unlockId){
    const u = UNLOCKS.find(x=>x.id===unlockId);
    if (!u) return {ok:false, reason:"unknown unlock"};
    state.sim.unlockOwned = state.sim.unlockOwned || [];
    if (state.sim.unlockOwned.includes(u.id)) return {ok:false, reason:"already owned"};

    if (!canAfford(u)) return {ok:false, reason:"cannot afford"};

    // Spend cost (through WorldMutator so we get normal events + provenance)
    const tick = state.sim.clock.tick || 0;
    const needN = Number(u.cost?.notes||0);
    const needC = Number(u.cost?.coin||0);
    if (needN) WorldMutator.addResource("notes", -needN, {source:"unlock", unlockId:u.id, tick});
    if (needC) WorldMutator.addResource("coin", -needC, {source:"unlock", unlockId:u.id, tick});

    state.sim.unlockOwned.push(u.id);
    state.sim.unlockMeta = state.sim.unlockMeta || {};
    state.sim.unlockMeta[u.id] = { purchasedAt: nowISO() };

    EventBus.emit("UNLOCK_PURCHASED", {unlockId:u.id, name:u.name, cost:u.cost, tick});

    // Apply effect
    try { u.apply({tick}); } catch(e){ EventBus.emit("WARN", {msg:"unlock apply failed", unlockId:u.id, err:String(e), tick}); }

    return {ok:true};
  }

  return { listAll, buy };
})();
const RuleRegistry = (function(){
  function list({enabledOnly=true, packId=null}={}){
    const rules = state.sim.rules || [];
    return rules.filter(r=>{
      if (!r) return false;
      if (packId && r.packId !== packId) return false;
      const packOk = PackManager.packEnabled(r.packId);
      if (!packOk) return false;
      if (enabledOnly && r.enabled === false) return false;
      return true;
    });
  }
  return { list };
})();

// (placeholders removed; implemented modules defined later per sprint)



// -------------------- EMERGENCE (Sprint 9) --------------------
/**
 * EmergenceEngine turns interaction patterns into NEW ENTITIES.
 * TS-READY NOTES:
 * - Keep output deterministic given the same state + tick.
 * - Use state.sim.emergenceSeen to de-dup spawns across saves.
 * - Spawn provenance should be stored in event payloads (ENTITY_SPAWNED + EMERGENCE_TRIGGERED).
 */
const EmergenceEngine = (function(){
  function ensureTagCategory(name){
    const nm = String(name||"").trim();
    if (!nm) return null;
    state.index.tagCategories = state.index.tagCategories || [];
    const found = state.index.tagCategories.find(c=>String(c||"").toLowerCase()===nm.toLowerCase());
    if (found) return found;
    state.index.tagCategories.push(nm);
    return nm;
  }

  function ensureTag(name, category="Tone"){
    const nm = String(name||"").trim();
    if (!nm) return null;
    ensureTagCategory(category);
    state.index.tags = state.index.tags || [];
    const existing = state.index.tags.find(t=>String(t.name||"").toLowerCase()===nm.toLowerCase());
    if (existing) return existing.id;
    const id = uid();
    state.index.tags.push({id, name:nm, category});
    return id;
  }

  function ensureLinkType(id, name){
    const ltId = String(id||"").trim();
    if (!ltId) return null;
    state.index.linkTypes = state.index.linkTypes || [];
    if (state.index.linkTypes.some(x=>x.id===ltId)) return ltId;
    state.index.linkTypes.push({id: ltId, name: name || ltId});
    return ltId;
  }

  function seen(key){
    const k = String(key||"");
    if (!k) return false;
    state.sim.emergenceSeen = state.sim.emergenceSeen || {};
    return (k in state.sim.emergenceSeen);
  }
  function markSeen(key, tick){
    const k = String(key||"");
    if (!k) return;
    state.sim.emergenceSeen = state.sim.emergenceSeen || {};
    state.sim.emergenceSeen[k] = Number(tick||0);
  }

  function pickInboundMonsterForBiome(biomeId){
    for (const e of (state.world.entities||[])){
      if (e.typeId !== 'monster') continue;
      for (const l of (e.links||[])){
        if (l.kindId === 'habitat' && l.toId === biomeId) return e;
      }
    }
    return null;
  }

  function spawnMonsterVariant({biome, tick}){
    const key = `emerge:monsterVariant:${biome.id}`;
    if (seen(key)) return null;

    const base = pickInboundMonsterForBiome(biome.id);
    const emergentTid = ensureTag('emergent', 'Tone');
    const adaptedTid = RefResolver.tag('adapted') || ensureTag('adapted','Tone');

    ensureLinkType('variant_of', 'Variant of');

    const name = base ? `${base.name} (${biome.name} Variant)` : `${biome.name} Spawn`;
    const entId = WorldMutator.spawnEntity({
      typeId: 'monster',
      name,
      tagIds: [emergentTid, adaptedTid].filter(Boolean),
      fields: { __emergence: { kind:'monster_variant', key, tick, biomeId: biome.id, baseId: base?base.id:null } },
      links: []
    }, {
      causedBy: { kind:'hotspot+overexposed', biomeId: biome.id, baseMonsterId: base?base.id:null, key }
    });

    WorldMutator.addLink(entId, 'habitat', biome.id, {note:'emergence', ruleId:'EMERGENCE'});
    if (base) WorldMutator.addLink(entId, 'variant_of', base.id, {note:'emergence', ruleId:'EMERGENCE'});

    markSeen(key, tick);
    EventBus.emit('EMERGENCE_TRIGGERED', {kind:'monster_variant', key, tick, entityId: entId, biomeId: biome.id, baseId: base?base.id:null});
    return {entityId: entId, kind:'monster_variant', key};
  }

  function spawnSkillVariant({cls, tick}){
    const key = `emerge:skillVariant:${cls.id}`;
    if (seen(key)) return null;

    const emergentTid = ensureTag('emergent', 'Tone');
    const studiedTid = RefResolver.tag('studied') || ensureTag('studied','Tone');

    const name = `${cls.name} Technique`;
    const entId = WorldMutator.spawnEntity({
      typeId: 'skill',
      name,
      tagIds: [emergentTid, studiedTid].filter(Boolean),
      fields: { __emergence: { kind:'skill_variant', key, tick, classId: cls.id } },
      links: []
    }, {
      causedBy: { kind:'dense_synergy', classId: cls.id, key }
    });

    WorldMutator.addLink(entId, 'synergy', cls.id, {note:'emergence', ruleId:'EMERGENCE'});

    markSeen(key, tick);
    EventBus.emit('EMERGENCE_TRIGGERED', {kind:'skill_variant', key, tick, entityId: entId, classId: cls.id});
    return {entityId: entId, kind:'skill_variant', key};
  }

  function spawnAnomaly({tick, suspects}){
    const key = `emerge:anomaly:${tick}`;
    if (seen(key)) return null;

    const emergentTid = ensureTag('emergent', 'Tone');
    ensureLinkType('distorts', 'Distorts');

    const name = `Anomaly (t${tick})`;
    const entId = WorldMutator.spawnEntity({
      typeId: 'monster',
      name,
      tagIds: [emergentTid].filter(Boolean),
      fields: { __emergence: { kind:'anomaly', key, tick } },
      links: []
    }, {
      causedBy: { kind:'runaway', tick, key }
    });

    const top = (suspects?.topDegree||[])[0];
    if (top?.id){
      WorldMutator.addLink(entId, 'distorts', top.id, {note:'emergence', ruleId:'EMERGENCE'});
    }

    markSeen(key, tick);
    EventBus.emit('EMERGENCE_TRIGGERED', {kind:'anomaly', key, tick, entityId: entId, targetId: top?.id||null});
    return {entityId: entId, kind:'anomaly', key};
  }

  function onTick({tick, runaway, runawayInfo=null}={}){
    if (!state.sim.settings.emergenceEnabled) return {spawns:[]};

    const maxSpawns = Number(state.sim.settings.emergenceMaxSpawnsPerTick || 2);
    const spawns = [];

    // Pattern 1: hotspot + overexposed biome -> monster variant
    const hot = RefResolver.tag('hotspot');
    const over = RefResolver.tag('overexposed');
    if (hot && over){
      for (const e of (state.world.entities||[])){
        if (spawns.length >= maxSpawns) break;
        if (e.typeId !== 'biome') continue;
        const tags = new Set(e.tagIds||[]);
        if (tags.has(hot) && tags.has(over)){
          const r = spawnMonsterVariant({biome:e, tick});
          if (r) spawns.push(r);
        }
      }
    }

    // Pattern 2: studied class with dense inbound synergy -> spawn skill variant
    const studied = RefResolver.tag('studied');
    if (spawns.length < maxSpawns && studied){
      for (const e of (state.world.entities||[])){
        if (spawns.length >= maxSpawns) break;
        if (e.typeId !== 'class') continue;
        if (!(e.tagIds||[]).includes(studied)) continue;
        const inbound = GraphIndex.inCount(e.id, 'synergy', 'skill');
        if (inbound >= 3){
          const r = spawnSkillVariant({cls:e, tick});
          if (r) spawns.push(r);
        }
      }
    }

    // Pattern 3: runaway -> spawn anomaly
    if (spawns.length < maxSpawns && runaway){
      const suspects = runawayInfo?.suspects || latestEventOfType('RUNAWAY_DETECTED')?.suspects || null;
      const r = spawnAnomaly({tick, suspects});
      if (r) spawns.push(r);
    }


// Pattern 4 (Layer 2): artifact-grade item + rune -> spawn a rune variant (local-only "echo")
// NOTE: Avoid PackManager dependency here (const init order). Check packMeta directly.
const artifactTag = RefResolver.tag("artifact:grade");
const artifactMeta = state.sim.packMeta && state.sim.packMeta["item_artifact_v0"];
const artifactPackEnabled = !artifactMeta || artifactMeta.enabled !== false;
const artifactPackInstalled = (state.sim.installedPacks||[]).includes("item_artifact_v0");

if (artifactTag && artifactPackInstalled && artifactPackEnabled){
  for (const it of (state.world.entities||[])){
    if (spawns.length >= maxSpawns) break;
    if (it.typeId !== "item") continue;
    const tags = new Set(it.tagIds||[]);
    if (!tags.has(artifactTag)) continue;

    const runes = [];
const kRune = RefResolver.linkType("item_has_rune") || "item_has_rune";
for (const l of (it.links||[])){
  if (!l || l.kindId !== kRune) continue;
  const r = entityById(l.toId);
  if (r && r.typeId === "rune") runes.push(r);
}

    for (const baseRune of runes){
      if (spawns.length >= maxSpawns) break;

      const key = `artifact_rune_variant::${it.id}::${baseRune.id}`;
      if (state.sim.emergenceSeen && state.sim.emergenceSeen[key]) continue;

      // Spawn the variant rune (naming kept simple)
      const vid = WorldMutator.spawnEntity({
        typeId: "rune",
        name: `${baseRune.name} (echo)`,
        fields: { __facets: { rarity: 3 } },
        tagIds: [],
        links: []
      }, { source:"emergence", tick });

      // Link variant_of (variant -> base)
      WorldMutator.addLink(vid, "variant_of", baseRune.id, { source:"emergence", tick });

      // Attach to item as an extra rune (this is intentional breakability)
      WorldMutator.addLink(it.id, "item_has_rune", vid, { source:"emergence", tick, note:"emerged: echo variant" });

      state.sim.emergenceSeen = state.sim.emergenceSeen || {};
      state.sim.emergenceSeen[key] = tick;

      EventBus.emit("EMERGENCE_SPAWN", { tick, kind:"artifact_rune_variant", itemId: it.id, baseRuneId: baseRune.id, entityId: vid });
      spawns.push({entityId: vid, kind:"artifact_rune_variant", key});
    }
  }
}

    state.sim.lastEmergence = {tick, spawns};
    return {spawns};
  }

  return { onTick };
})();


// -------------------- ITEM CRAFTING (Layer 1: production loop) --------------------
/**
 * Design goal:
 * - Item crafting exists, but it doesn't become the *driver* of the world unless you push it.
 * - Early systems should be "breakable" and debuggable: you can create runaway items and then solve the mess.
 *
 * TS-READY NOTES:
 * - Treat this module as a self-contained namespace for later TS extraction.
 * - Prefer passing ids + using WorldMutator (centralized events, blocking, and future provenance).
 */
const Crafting = (function(){

  // ----- Helpers (tag sets) -----
  const CONDITION_TAGS = ["condition:stable","condition:flawed","condition:failed"];
  const QUALITY_TAGS = ["quality:raw","quality:standard","quality:excellent"];

  function getFacet(e, key, fallback=0){
    const v0 = e?.fields?.__facets?.[key];
    const v = (v0==="" || v0==null) ? null : Number(v0);
    return Number.isFinite(v) ? v : fallback;
  }

  function setExclusiveTag(entityId, tagNames, chooseName, meta){
    // Remove all, then add chosen (if provided).
    tagNames.forEach(tn=> WorldMutator.removeTag(entityId, tn, meta));
    if (chooseName) WorldMutator.addTag(entityId, chooseName, meta);
  }

  function outLinkedEntities(fromEntity, kindId, toTypeId=null){
    const out = [];
    const links = fromEntity?.links || [];
    for (const l of links){
      if (!l || (kindId && l.kindId !== kindId)) continue;
      const to = entityById(l.toId);
      if (!to) continue;
      if (toTypeId && to.typeId !== toTypeId) continue;
      out.push(to);
    }
    return out;
  }

  function analyzeItem(item){
    // TS: returns CraftingAnalysis
    const tier = getFacet(item,"tier",0);
    const quality = getFacet(item,"quality",0);
    const stability = getFacet(item,"stability",0);
    const complexity = getFacet(item,"complexity",0);
    const corruption = getFacet(item,"corruption",0);

    const mats = outLinkedEntities(item, "item_uses_material", "material");
    const cores = outLinkedEntities(item, "item_has_core", "core");
    const runes = outLinkedEntities(item, "item_has_rune", "rune");

    const issues = [];

    if (!mats.length) issues.push("No material linked (item→material).");
    if (!cores.length) issues.push("No core linked (item→core).");

    // Rune allowance is intentionally small.
    const baseAllowed = tier >= 2 ? 2 : (tier >= 1 ? 1 : 0);
    const extra = state.sim?.crafting?.upgrades?.extraRuneSlot ? 1 : 0;
    const allowedRunes = baseAllowed + extra;

    // ---- Risk score (0..100-ish) ----
    // Risk is a debug lever: you can lower it by linking better stuff, or raise it to create chaos.
    let risk = 0;
    const riskBreakdown = [];
    // TS: riskBreakdown entries explain where risk came from (UI 'Why?')
    function addRisk(points, label){
      const p = Number(points||0);
      if (!p) return;
      risk += p;
      riskBreakdown.push({ points: p, label: String(label||"") });
    }


    // Missing essentials is harsh.
    if (!mats.length) addRisk(35, "missing material");
    if (!cores.length) addRisk(35, "missing core");

    // Complexity vs tier: if you're building something too complex for its tier, it wobbles.
    // Example: tier 0 item with complexity 7 is a mess.
    const expected = tier*3 + 2;
    if (complexity > expected) addRisk((complexity - expected) * 6, `complexity over tier (expected ${expected})`);

    // Corruption feeds risk directly.
    addRisk(corruption * 3, "corruption");

    // Too many runes increases failure likelihood unless you intentionally unlock more slots.
    if (runes.length > allowedRunes) addRisk((runes.length - allowedRunes) * 15, `too many runes (${runes.length}/${allowedRunes})`);

    // Low stability is inherently risky.
    if (stability <= 2) addRisk((3 - stability) * 7, `low stability (${stability})`);

    // If you're broke, forging is "improvised" and worse.
    const coin = Number(state.sim?.resources?.coin||0);
    const cost = Number(state.sim?.crafting?.settings?.costCoinPerForge||0);
    if (cost > 0 && coin < cost) addRisk(12, `insufficient coin for cost (${coin}/${cost})`);

    risk = Math.max(0, Math.min(125, Math.round(risk)));

    const ready = (issues.length===0);

    return {
      ready,
      issues,
      risk,
      facets: {tier, quality, stability, complexity, corruption},
      components: { materials:mats, cores, runes },
      allowedRunes,
      riskBreakdown
    };
  }

  function rollOutcome(risk){
    // TS: returns {outcome:ForgeOutcome, roll:number, p:{fail:number, flaw:number, success:number}}
    // Keep probabilities simple + readable.
    let pFail = clamp(0.08 + risk/180, 0.08, 0.80);
    let pFlaw = clamp(0.12 + risk/260, 0.10, 0.70);
    let pSuccess = 1 - pFail - pFlaw;
    if (pSuccess < 0.05){
      // Renormalize to keep a minimum success floor
      const over = 0.05 - pSuccess;
      pFail = clamp(pFail - over*0.6, 0.05, 0.90);
      pFlaw = clamp(pFlaw - over*0.4, 0.05, 0.90);
      pSuccess = 1 - pFail - pFlaw;
      if (pSuccess < 0.01) pSuccess = 0.01;
    }

    const roll = Math.random();
    let outcome = "success";
    if (roll < pFail) outcome = "fail";
    else if (roll < pFail + pFlaw) outcome = "flaw";

    return { outcome, roll, p:{fail:pFail, flaw:pFlaw, success:pSuccess} };
  }

  
function rollOutcomeLab(risk){
  // TS: Like rollOutcome, but volatility shifts mass from "flaw" into {fail, success}.
  // Lab should feel like: higher stakes, higher chance of "weird good", and more corruption on bad.
  const base = rollOutcome(risk);
  // reshape probabilities a bit (readable, not "correct")
  let pFail = clamp(base.p.fail + 0.06, 0.05, 0.90);
  let pSuccess = clamp(base.p.success + 0.05, 0.01, 0.90);
  let pFlaw = 1 - pFail - pSuccess;
  if (pFlaw < 0.02){
    // keep at least a small flaw band
    const need = 0.02 - pFlaw;
    pFlaw = 0.02;
    // pull proportionally from fail/success
    pFail = clamp(pFail - need*0.55, 0.02, 0.95);
    pSuccess = 1 - pFail - pFlaw;
  }
  const roll = Math.random();
  let outcome = "success";
  if (roll < pFail) outcome = "fail";
  else if (roll < pFail + pFlaw) outcome = "flaw";
  return { outcome, roll, p:{fail:pFail, flaw:pFlaw, success:pSuccess}, lab:true };
}

function listQuirkTagNames(){
  // TS: returns string[] of quirk tag *names* that exist (from the artifact pack).
  const tags = state.index.tags || [];
  const out = [];
  for (const t of tags){
    const name = String(t.name||"");
    if (name.toLowerCase().startsWith("quirk:")) out.push(name);
  }
  return out;
}

function maybeGainQuirk(itemId, meta, chance){
  // Only if artifact vocabulary exists.
  const quirks = listQuirkTagNames();
  if (!quirks.length) return null;
  if (Math.random() > (chance||0)) return null;

  // Avoid duplicates
  const e = entityById(itemId);
  const existing = new Set((e?.tagIds||[]).map(tid=>tagName(tid).toLowerCase()));
  const pool = quirks.filter(n=>!existing.has(n.toLowerCase()));
  if (!pool.length) return null;

  const pick = pool[Math.floor(Math.random()*pool.length)];
  WorldMutator.addTag(itemId, pick, meta);
  EventBus.emit("QUIRK_GAINED", { itemId, tick: meta.tick, quirk: pick, ...meta });
  return pick;
}

function checkArtifactPromotion(itemId, meta){
  // Artifact grade is a *tag* gate, not a huge new system. It should be debuggable.
  if (!state.sim?.crafting?.upgrades?.artifactUnlocked) return false;

  const e = entityById(itemId);
  if (!e) return false;

  const tagArtifact = RefResolver.tag("artifact:grade");
  if (tagArtifact && (e.tagIds||[]).includes(tagArtifact)) return false; // already

  // thresholds (tweakable later; keep readable)
  const q = getFacet(e,"quality",0);
  const stab = getFacet(e,"stability",0);
  const corr = getFacet(e,"corruption",0);
  const tier = getFacet(e,"tier",0);

  const stableTid = RefResolver.tag("condition:stable");
  const isStable = stableTid ? (e.tagIds||[]).includes(stableTid) : true;

  const runes = outLinkedEntities(e, "item_has_rune", "rune");
  const hasRune = runes.length >= 1;

  const ok =
    isStable &&
    hasRune &&
    q >= 8 &&
    stab >= 7 &&
    corr <= 4 &&
    tier >= 1;

  if (!ok) return false;

  WorldMutator.addTag(itemId, "artifact:grade", meta);
  EventBus.emit("ARTIFACT_PROMOTED", { itemId, tick: meta.tick, q, stab, corr, tier, ...meta });

  // Artifacts tend to gain a quirk on promotion (if available)
  maybeGainQuirk(itemId, meta, 0.85);

  // Light bump in rarity to reflect "people notice" (still local-only)
  WorldMutator.addFacet(itemId, "rarity", +1, meta);

  return true;
}
function applyOutcome(itemId, analysis, outcome, meta){
    // TS: returns applied changes summary
    const up = state.sim?.crafting?.upgrades || {};
    const toolsBonus = Number(up.toolsBonus||0);

    // Small upgrades reduce risk a bit (without removing breakability).
    const effectiveRisk = Math.max(0, analysis.risk - toolsBonus*10);

    const applied = { tags:[], facets:[] };

    // Mark as crafted on any non-fail attempt (still a production loop).
    if (outcome !== "fail"){
      WorldMutator.addTag(itemId, "crafted", meta);
    }

    if (outcome === "success"){
      WorldMutator.addFacet(itemId, "quality", +1, meta); applied.facets.push({k:"quality", d:+1});
      WorldMutator.addFacet(itemId, "stability", +1 + toolsBonus, meta); applied.facets.push({k:"stability", d:+1+toolsBonus});
      WorldMutator.addFacet(itemId, "corruption", -1, meta); applied.facets.push({k:"corruption", d:-1});
      setExclusiveTag(itemId, CONDITION_TAGS, "condition:stable", meta); applied.tags.push("condition:stable");
    } else if (outcome === "flaw"){
      WorldMutator.addFacet(itemId, "quality", +1, meta); applied.facets.push({k:"quality", d:+1});
      WorldMutator.addFacet(itemId, "stability", -1, meta); applied.facets.push({k:"stability", d:-1});
      WorldMutator.addFacet(itemId, "corruption", +1, meta); applied.facets.push({k:"corruption", d:+1});
      setExclusiveTag(itemId, CONDITION_TAGS, "condition:flawed", meta); applied.tags.push("condition:flawed");
    } else { // fail
      WorldMutator.addFacet(itemId, "stability", -2, meta); applied.facets.push({k:"stability", d:-2});
      WorldMutator.addFacet(itemId, "corruption", +2, meta); applied.facets.push({k:"corruption", d:+2});
      setExclusiveTag(itemId, CONDITION_TAGS, "condition:failed", meta); applied.tags.push("condition:failed");
    }

    // Auto quality tags based on current quality facet (soft rule, easy to break)
    const item = entityById(itemId);
    const q = getFacet(item, "quality", 0);
    let qTag = "quality:raw";
    if (q >= 7) qTag = "quality:excellent";
    else if (q >= 4) qTag = "quality:standard";
    setExclusiveTag(itemId, QUALITY_TAGS, qTag, meta); applied.tags.push(qTag);

    // Track "failed at" for objectives (recover within N ticks).
    const tick = state.sim.clock.tick || 0;
    state.sim.crafting.failedAtByItemId = state.sim.crafting.failedAtByItemId || {};
    if (outcome === "fail") state.sim.crafting.failedAtByItemId[itemId] = tick;
    if (outcome === "success") {
      // If we're stable now, clear the failure timer.
      const condStable = RefResolver.tag("condition:stable");
      if (condStable && (entityById(itemId)?.tagIds||[]).includes(condStable)){
        delete state.sim.crafting.failedAtByItemId[itemId];
      }
    }

    return { effectiveRisk, applied };
  }

  function updateStreaks(itemId, outcome){
    const tick = state.sim.clock.tick || 0;
    state.sim.crafting.streaks = state.sim.crafting.streaks || deep(DEFAULT_SIM.crafting.streaks);
    const perItem = state.sim.crafting.streaks.perItem = state.sim.crafting.streaks.perItem || {};

    const cur = perItem[itemId] || {successStreak:0, lastOutcome:"", lastTick:tick};
    if (outcome === "success") cur.successStreak = (cur.successStreak||0) + 1;
    else cur.successStreak = 0;
    cur.lastOutcome = outcome;
    cur.lastTick = tick;
    perItem[itemId] = cur;

    if (outcome === "success") state.sim.crafting.streaks.consecutiveSuccesses = (state.sim.crafting.streaks.consecutiveSuccesses||0) + 1;
    else state.sim.crafting.streaks.consecutiveSuccesses = 0;

    return cur;
  }

  function forge(itemId, opts={}){
    const item = entityById(itemId);
    if (!item) return {ok:false, reason:"missing item"};
    if (item.typeId !== "item") return {ok:false, reason:"not an item"};

    const tick = state.sim.clock.tick || 0;
    const meta = {source:"forge", tick, itemId, ...(opts.meta||{})};

// Mode: production vs lab (unlocked), plus optional crisis override.
// TS: type CraftingMode = "production" | "lab" | "crisis";
const requestedMode = String(opts.modeOverride || state.sim?.crafting?.settings?.mode || "production");
const mode =
  (requestedMode === "lab" || requestedMode === "crisis") && state.sim?.crafting?.upgrades?.labUnlocked
    ? requestedMode
    : "production";


    // Block rules: frozen ids or quarantined tag (same semantics as WorldMutator)
    const frozen = Array.isArray(state.sim.frozenEntityIds) && state.sim.frozenEntityIds.includes(String(itemId));
    const qid = RefResolver.tag("quarantined");
    const quarantined = qid && (entityById(itemId)?.tagIds||[]).includes(qid);
    if (frozen || quarantined){
      EventBus.emit("WARN",{msg:"forge blocked", itemId, tick});
      return {ok:false, reason:"blocked"};
    }

    const analysis = analyzeItem(item);

    if (!analysis.ready && !state.sim.crafting.settings.allowUnsafe){
      return {ok:false, reason:"not ready", analysis};
    }

    // Spend cost (if any)
    let cost = Number(state.sim?.crafting?.settings?.costCoinPerForge||0);
if (mode === "lab") cost += Number(state.sim?.crafting?.settings?.labExtraCostCoin||0);
if (mode === "crisis") cost = Number(state.sim?.crafting?.settings?.crisisCostCoin||0);

if (cost) WorldMutator.addResource("coin", -cost, {...meta, mode});


    // Emit attempt (so it's debuggable)
    EventBus.emit("FORGE_ATTEMPT", {
      itemId,
      tick,
      mode,
      risk: analysis.risk,
      ready: analysis.ready,
      issues: analysis.issues.slice(0, 6)
    });

    // Tools upgrade shifts risk a bit, but doesn't remove breakability.
    const toolsBonus = Number(state.sim?.crafting?.upgrades?.toolsBonus||0);
    const extraRisk =
  mode === "lab" ? Number(state.sim?.crafting?.settings?.labExtraRisk||0)
  : mode === "crisis" ? (Number(state.sim?.crafting?.settings?.labExtraRisk||0) + 25)
  : 0;

const baseRisk = analysis.risk + extraRisk;
const risk2 = Math.max(0, baseRisk - toolsBonus*10);


    const r = (mode==="production") ? rollOutcome(risk2) : rollOutcomeLab(risk2);
    const outcome = r.outcome;

    const applied = applyOutcome(itemId, analysis, outcome, {...meta, mode});
    const streak = updateStreaks(itemId, outcome);

// Lab-only extras (kept tiny and debuggable)
if (mode !== "production"){
  // Mark unstable on any lab attempt; remove on clean production success later if you want.
  WorldMutator.addTag(itemId, "condition:unstable", {...meta, mode});

  if (outcome === "success"){
    // Small chance of an extra bump (breakability lever)
    if (Math.random() < 0.22) WorldMutator.addFacet(itemId, "complexity", +1, {...meta, mode});
    if (Math.random() < 0.18) WorldMutator.addFacet(itemId, "quality", +1, {...meta, mode});

    // Rare tier push (caps at 3 for now)
    const e2 = entityById(itemId);
    const tierNow = getFacet(e2,"tier",0);
    if (tierNow < 3 && risk2 >= 55 && Math.random() < (mode==="crisis" ? 0.20 : 0.10)){
      WorldMutator.addFacet(itemId, "tier", +1, {...meta, mode});
      EventBus.emit("TIER_UP", { itemId, tick, mode, before: tierNow, after: tierNow+1 });
    }

    // Quirk chance (if artifact vocabulary exists)
    if (state.sim?.crafting?.upgrades?.artifactUnlocked){
      maybeGainQuirk(itemId, {...meta, mode}, mode==="crisis" ? 0.35 : 0.15);
    }

    // Lab taint if corruption stays high
    const cNow = getFacet(entityById(itemId),"corruption",0);
    if (cNow >= 6) WorldMutator.addTag(itemId, "lab:tainted", {...meta, mode});
  }

  if (outcome === "fail"){
    // Lab failures should be dirtier than production failures.
    WorldMutator.addFacet(itemId, "corruption", +1, {...meta, mode});
  }
}

// Artifact promotion check (local-only, gated by unlock)
checkArtifactPromotion(itemId, {...meta, mode});

    // Save last forge result for UI
    state.sim.crafting.lastForge = {
      tick,
      itemId,
      outcome,
      risk: analysis.risk,
      riskAfterUpgrades: risk2,
      roll: r.roll,
      p: r.p,
      summary: outcome==="success" ? "Stable result" : (outcome==="flaw" ? "Functional but flawed" : "Failed attempt"),
      applied: applied.applied,
      streak
    };

    EventBus.emit("FORGE_RESULT", {
      itemId,
      tick,
      mode,
      outcome,
      risk: analysis.risk,
      riskAfterUpgrades: risk2,
      roll: r.roll,
      p: r.p
    });

    return {ok:true, analysis, result: state.sim.crafting.lastForge};
  }

function crisisForge(itemId){
  // TS: Crisis Forge is a lab-only "push your luck" button.
  if (!state.sim?.crafting?.upgrades?.labUnlocked) return {ok:false, reason:"lab locked"};
  return forge(itemId, { modeOverride:"crisis", meta:{ source:"crisis_forge" } });
}

function affinityNames(ent){
  const out = [];
  if (!ent) return out;
  for (const tid of (ent.tagIds||[])){
    const nm = String(tagName(tid)||"").toLowerCase();
    if (nm.startsWith("affinity:")) out.push(nm);
  }
  return out;
}

function itemAffinitySet(item){
  const set = new Set();
  affinityNames(item).forEach(x=>set.add(x));
  outLinkedEntities(item, "item_uses_material", "material").forEach(m=>affinityNames(m).forEach(x=>set.add(x)));
  outLinkedEntities(item, "item_has_core", "core").forEach(c=>affinityNames(c).forEach(x=>set.add(x)));
  outLinkedEntities(item, "item_has_rune", "rune").forEach(r=>affinityNames(r).forEach(x=>set.add(x)));
  return set;
}

function feed(itemId, componentId, opts={}){
  // TS: componentId may be a material/core/rune; feeding is a mutation lever with explicit logging.
  if (!state.sim?.crafting?.upgrades?.feedingUnlocked) return {ok:false, reason:"feeding locked"};

  const item = entityById(itemId);
  const comp = entityById(componentId);
  if (!item || item.typeId !== "item") return {ok:false, reason:"missing item"};
  if (!comp) return {ok:false, reason:"missing component"};

  const tick = state.sim.clock.tick || 0;
  const meta = { source:"feed", tick, itemId, componentId, ...(opts.meta||{}) };

  if (WorldMutator.isBlocked(itemId) || WorldMutator.isBlocked(componentId)){
    EventBus.emit("WARN",{msg:"feed blocked", itemId, componentId, tick});
    return {ok:false, reason:"blocked"};
  }

  // Spend feed cost
  const cost = Number(state.sim?.crafting?.settings?.feedCostCoin||0);
  if (cost) WorldMutator.addResource("coin", -cost, meta);

  EventBus.emit("FEED_ATTEMPT", {
    itemId, componentId, tick,
    itemName: item.name, componentName: comp.name,
    componentType: comp.typeId
  });

  // Record the feeding link (for debugging)
  WorldMutator.addLink(itemId, "item_fed_with", componentId, meta);

  // Mutate facets (readable, not complex)
  const affSet = itemAffinitySet(item);
  const compAff = affinityNames(comp);
  const match = compAff.some(a=>affSet.has(a));

  WorldMutator.addFacet(itemId, "complexity", +1, meta);

  if (match){
    WorldMutator.addFacet(itemId, "stability", +1, meta);
    if (Math.random() < 0.45) WorldMutator.addFacet(itemId, "corruption", -1, meta);
    if (Math.random() < 0.25) WorldMutator.addFacet(itemId, "quality", +1, meta);
  } else {
    WorldMutator.addFacet(itemId, "stability", -1, meta);
    WorldMutator.addFacet(itemId, "corruption", +1, meta);
    WorldMutator.addTag(itemId, "lab:tainted", meta);
  }

  // Quirk chance if feeding into an already-artifact item (or if you unlocked quirks)
  if (state.sim?.crafting?.upgrades?.artifactUnlocked){
    const isArtifact = RefResolver.tag("artifact:grade") && (entityById(itemId)?.tagIds||[]).includes(RefResolver.tag("artifact:grade"));
    maybeGainQuirk(itemId, meta, isArtifact ? 0.20 : 0.10);
  }

  checkArtifactPromotion(itemId, meta);

  EventBus.emit("FEED_RESULT", {
    itemId, componentId, tick,
    matchAffinity: match,
    compAffinities: compAff.slice(0,6),
    itemAffinities: Array.from(affSet).slice(0,8)
  });

  return {ok:true, matchAffinity: match, compAffinities: compAff, itemAffinities: Array.from(affSet)};
}

return { analyzeItem, forge, crisisForge, feed };
})();


// -------------------- ECONOMY + REPUTATION (Layer 2.5) --------------------
/**
 * TS-READY NOTES:
 * - This layer does NOT make items world-driving actors.
 * - Items can be finalized, priced, sold. Attribution is stored via links:
 *   crafted_by (item→character), crafted_at (item→location)
 * - Character fame uses facets: fame_pos, fame_neg (0..10).
 * - Local reputation uses character.fields.localRep: { [locationId:string]: {pos:number, neg:number} }.
 *
 * Types (future TS):
 * type FameDelta = { posDelta?: number, negDelta?: number };
 * type LocalRepDelta = { posDelta?: number, negDelta?: number };
 * type PriceQuote = { price:number, breakdown:Array<{label:string,value:number}>, repPreview:any, crafterId?:string, locationId?:string };
 */

// ----- Small helpers (local; avoid cross-module coupling) -----
function getFacetSafe(ent, key, fallback=0){
  const v0 = ent?.fields?.__facets?.[key];
  const v = (v0==="" || v0==null) ? null : Number(v0);
  return Number.isFinite(v) ? v : fallback;
}
function setFacetSafe(ent, key, value){
  if (!ent) return;
  ent.fields = ent.fields || {};
  ent.fields.__facets = ent.fields.__facets || {};
  ent.fields.__facets[key] = clamp10(Number(value||0));
  ent.updatedAt = nowISO();
}
function tagIdByName(name){
  const t = (state.index.tags||[]).find(x=>x && x.name===name);
  return t ? t.id : null;
}
function hasTagByName(ent, name){
  const tid = tagIdByName(name);
  if (!tid) return false;
  return (ent?.tagIds||[]).includes(tid);
}
function linkFirstToId(fromEnt, kindId, toTypeId=null){
  const links = fromEnt?.links || [];
  for (const l of links){
    if (!l || l.kindId !== kindId) continue;
    const to = entityById(l.toId);
    if (!to) continue;
    if (toTypeId && to.typeId !== toTypeId) continue;
    return to.id;
  }
  return null;
}
function ensureSingleLink(fromId, kindId, toId){
  const from = entityById(fromId);
  if (!from) return;
  from.links = from.links || [];
  // single-slot semantics: remove existing of this kind
  from.links = from.links.filter(l=>!(l && l.kindId===kindId));
  from.links.push({ kindId, toId, note:"" });
  from.updatedAt = nowISO();
  GraphIndex.rebuild();
}

// ----- Reputation Engine -----
const ReputationEngine = (function(){
  function ensureLocalRep(char){
    char.fields = char.fields || {};
    if (!char.fields.localRep || typeof char.fields.localRep !== "object") char.fields.localRep = {};
    return char.fields.localRep;
  }
  function applyGlobal(characterId, delta, meta){
    const c = entityById(characterId);
    if (!c) return {ok:false, reason:"missing character"};
    const pos = Number(delta?.posDelta||0);
    const neg = Number(delta?.negDelta||0);

    const beforePos = getFacetSafe(c,"fame_pos",0);
    const beforeNeg = getFacetSafe(c,"fame_neg",0);

    setFacetSafe(c,"fame_pos", beforePos + pos);
    setFacetSafe(c,"fame_neg", beforeNeg + neg);

    EventBus.emit("FAME_DELTA", {
      characterId: c.id,
      posDelta: pos,
      negDelta: neg,
      before: { pos: beforePos, neg: beforeNeg },
      after: { pos: getFacetSafe(c,"fame_pos",0), neg: getFacetSafe(c,"fame_neg",0) },
      reason: meta?.reason || "",
      tick: meta?.tick || (state.sim.clock.tick||0)
    });
    return {ok:true};
  }
  function applyLocal(characterId, locationId, delta, meta){
    const c = entityById(characterId);
    if (!c) return {ok:false, reason:"missing character"};
    if (!locationId) return {ok:false, reason:"missing location"};
    const rep = ensureLocalRep(c);
    const cur = rep[locationId] || {pos:0, neg:0};
    const pos = Number(delta?.posDelta||0);
    const neg = Number(delta?.negDelta||0);
    const next = {
      pos: clamp10(Number(cur.pos||0) + pos),
      neg: clamp10(Number(cur.neg||0) + neg),
    };
    rep[locationId] = next;
    c.updatedAt = nowISO();

    EventBus.emit("LOCAL_REP_DELTA", {
      characterId: c.id,
      locationId,
      posDelta: pos,
      negDelta: neg,
      before: cur,
      after: next,
      reason: meta?.reason || "",
      tick: meta?.tick || (state.sim.clock.tick||0)
    });
    return {ok:true};
  }
  function summary(characterId, locationId=null){
    const c = entityById(characterId);
    if (!c) return null;
    const fame = { pos: getFacetSafe(c,"fame_pos",0), neg: getFacetSafe(c,"fame_neg",0) };
    const rep = c.fields?.localRep || {};
    const local = locationId ? (rep[locationId]||{pos:0,neg:0}) : null;
    return { characterId, fame, local };
  }
  return { applyGlobal, applyLocal, summary };
})();

// ----- Item Finalization -----
const ItemFinalization = (function(){
  function canFinalize(item){
    if (!item || item.typeId !== "item") return {ok:false, reason:"not an item"};
    const stability = getFacetSafe(item,"stability",0);
    const failed = hasTagByName(item,"condition:failed");
    if (failed) return {ok:false, reason:"Item is failed. Recover it before finalizing."};
    if (stability < 3) return {ok:true, warn:"Low stability (<3). Final product may harm reputation."};
    return {ok:true};
  }

  function finalize(itemId, {crafterId=null, locationId=null}={}, meta){
    const item = entityById(itemId);
    if (!item) return {ok:false, reason:"missing item"};
    const chk = canFinalize(item);
    if (!chk.ok) return chk;

    if (crafterId) ensureSingleLink(item.id, "crafted_by", crafterId);
    if (locationId) ensureSingleLink(item.id, "crafted_at", locationId);

    // Mark finalized + snapshot
    WorldMutator.addTag(item.id, "item:finalized", meta);
    item.fields = item.fields || {};
    item.fields.final = item.fields.final || {};
    item.fields.final.finalizedAtTick = (state.sim.clock.tick||0);
    item.fields.final.finalizedAtISO = nowISO();
    item.fields.final.snapshot = {
      tier: getFacetSafe(item,"tier",0),
      quality: getFacetSafe(item,"quality",0),
      stability: getFacetSafe(item,"stability",0),
      corruption: getFacetSafe(item,"corruption",0)
    };
    item.updatedAt = nowISO();

    EventBus.emit("ITEM_FINALIZED", {
      itemId: item.id,
      crafterId: linkFirstToId(item,"crafted_by","character") || crafterId || null,
      locationId: linkFirstToId(item,"crafted_at","location") || locationId || null,
      warn: chk.warn || "",
      tick: (meta?.tick ?? (state.sim.clock.tick||0))
    });

    // Small rep/fame nudge on finalization (selling is bigger)
    const cid = linkFirstToId(item,"crafted_by","character");
    const lid = linkFirstToId(item,"crafted_at","location");
    if (cid && lid){
      const q = getFacetSafe(item,"quality",0);
      const s = getFacetSafe(item,"stability",0);
      const corr = getFacetSafe(item,"corruption",0);
      const pos = (q>=6 && s>=5 && corr<=2) ? 1 : 0;
      const neg = (corr>=4 || s<=2) ? 1 : 0;
      if (pos||neg){
        ReputationEngine.applyLocal(cid, lid, {posDelta: pos, negDelta: neg}, {reason:"finalized", tick:(state.sim.clock.tick||0)});
        ReputationEngine.applyGlobal(cid, {posDelta: Math.max(0,pos), negDelta: Math.max(0,neg)}, {reason:"finalized", tick:(state.sim.clock.tick||0)});
      }
    }

    return {ok:true, warn: chk.warn||""};
  }

  return { canFinalize, finalize };
})();

// ----- Price Engine -----
const PriceEngine = (function(){
  function quote(itemId, {crafterId=null, locationId=null}={}, meta){
    const item = entityById(itemId);
    if (!item) return {ok:false, reason:"missing item"};
    const cid = crafterId || linkFirstToId(item,"crafted_by","character");
    const lid = locationId || linkFirstToId(item,"crafted_at","location") || linkFirstToId(item,"listed_at","location");

    const tier = getFacetSafe(item,"tier",0);
    const quality = getFacetSafe(item,"quality",0);
    const stability = getFacetSafe(item,"stability",0);
    const corr = getFacetSafe(item,"corruption",0);
    const isArt = hasTagByName(item,"artifact:grade");
    const isTainted = hasTagByName(item,"lab:tainted");
    const isFailed = hasTagByName(item,"condition:failed");
    const isFinal = hasTagByName(item,"item:finalized");

    const quirkCount = (item.tagIds||[]).map(tagName).filter(n=>String(n||"").startsWith("quirk:")).length;

    const breakdown = [];
    function add(label, v){ breakdown.push({label, value:Number(v||0)}); }

    let price = 5; add("base", 5);

    add("tier bonus", tier * 8); price += tier*8;
    add("quality bonus", quality * 2); price += quality*2;
    add("stability bonus", Math.max(0, stability-5) * 1.5); price += Math.max(0, stability-5)*1.5;

    if (isArt){ add("artifact bonus", 15); price += 15; }
    if (quirkCount){ add("quirk bonus", quirkCount * 4); price += quirkCount*4; }

    const corruptionPenalty = corr * 3;
    add("corruption penalty", -corruptionPenalty); price -= corruptionPenalty;

    if (isFailed){ add("failed penalty", -20); price -= 20; }
    if (isTainted){ add("tainted penalty", -5); price -= 5; }
    if (!isFinal){ add("not finalized", -10); price -= 10; }

    // Location premium
    if (lid){
      const loc = entityById(lid);
      const renown = getFacetSafe(loc,"renown",0);
      const locPrem = renown * 1.2;
      if (locPrem) add("location renown", locPrem);
      price += locPrem;
    }

    // Crafter premium
    if (cid){
      const c = entityById(cid);
      const fp = getFacetSafe(c,"fame_pos",0);
      const fn = getFacetSafe(c,"fame_neg",0);
      const fameUp = fp * 1.0;
      const infamy = fn * 0.6;
      const infamyAdj = (corr <= 3) ? infamy : -infamy;
      const crafterPrem = fameUp + infamyAdj;
      if (crafterPrem) add("crafter fame", crafterPrem);
      price += crafterPrem;

      // Local rep premium
      if (lid && c.fields?.localRep?.[lid]){
        const lr = c.fields.localRep[lid];
        const repPrem = (Number(lr.pos||0) - Number(lr.neg||0)) * 0.8;
        if (repPrem) add("local rep", repPrem);
        price += repPrem;
      }
    }

    price = Math.max(0, Math.round(price));

    // Rep/fame preview for SELL (not finalize)
    const repPreview = { famePosDelta:0, fameNegDelta:0, localPosDelta:0, localNegDelta:0 };
    if (cid && lid){
      const cleanGood = (quality >= 6 && stability >= 5 && corr <= 2 && !isTainted);
      const suspect = (corr >= 4 || stability <= 2 || isTainted);

      if (cleanGood){
        repPreview.localPosDelta = 1;
        repPreview.famePosDelta = (tier >= 1) ? 1 : 0;
        if (isArt) repPreview.famePosDelta += 1;
      }
      if (suspect){
        repPreview.localNegDelta = 1;
        repPreview.fameNegDelta = 1;
        if (isArt && corr >= 4) repPreview.fameNegDelta += 1;
      }
    }

    return {ok:true, price, breakdown, crafterId: cid||null, locationId: lid||null, repPreview };
  }
  return { quote };
})();

// ----- Market Engine -----
const MarketEngine = (function(){
  function sell(itemId, {crafterId=null, locationId=null, buyerId=null}={}, meta){
    const item = entityById(itemId);
    if (!item) return {ok:false, reason:"missing item"};
    if (!hasTagByName(item,"item:finalized")) return {ok:false, reason:"Finalize the item before selling."};

    const q = PriceEngine.quote(itemId, {crafterId, locationId}, meta);
    if (!q.ok) return q;

    // Pay
    state.sim.resources.coin = Number(state.sim.resources.coin||0) + Number(q.price||0);

    // Mark sold + record sale
    WorldMutator.addTag(item.id, "item:sold", meta);
    item.fields = item.fields || {};
    item.fields.sale = item.fields.sale || {};
    item.fields.sale.soldAtTick = (state.sim.clock.tick||0);
    item.fields.sale.soldAtISO = nowISO();
    item.fields.sale.price = q.price;
    item.fields.sale.locationId = q.locationId;
    item.fields.sale.crafterId = q.crafterId;
    if (buyerId) {
      ensureSingleLink(item.id, "sold_to", buyerId);
      item.fields.sale.buyerId = buyerId;
    }
    if (q.locationId) ensureSingleLink(item.id, "listed_at", q.locationId);

    item.updatedAt = nowISO();

    EventBus.emit("ITEM_SOLD", {
      itemId: item.id,
      price: q.price,
      locationId: q.locationId,
      crafterId: q.crafterId,
      buyerId: buyerId || null,
      tick: (meta?.tick ?? (state.sim.clock.tick||0))
    });

    // Apply rep/fame deltas
    if (q.crafterId && q.locationId){
      const rp = q.repPreview || {};
      if ((rp.localPosDelta||0) || (rp.localNegDelta||0)){
        ReputationEngine.applyLocal(q.crafterId, q.locationId, {posDelta: rp.localPosDelta||0, negDelta: rp.localNegDelta||0}, {reason:"sold", tick:(state.sim.clock.tick||0)});
      }
      if ((rp.famePosDelta||0) || (rp.fameNegDelta||0)){
        ReputationEngine.applyGlobal(q.crafterId, {posDelta: rp.famePosDelta||0, negDelta: rp.fameNegDelta||0}, {reason:"sold", tick:(state.sim.clock.tick||0)});
      }
    }

    return {ok:true, price:q.price, quote:q};
  }
  return { sell };
})();





/* -------------------- END MODULAR SCAFFOLD -------------------- */

// -------------------- SIM: EVENT + RULE ENGINE (SKELETON) --------------------
const Sim = {
  // ring buffer push
  pushEvent(ev) {
    const list = state.sim.events;
    list.push(ev);
    const MAX = 2000;
    if (list.length > MAX) list.splice(0, list.length - MAX);
  },

  ev(type, payload={}) {
    return {
      id: uid(),
      at: nowISO(),
      tick: state.sim.clock.tick || 0,
      type,
      ...payload
    };
  },

  // tiny diff helper
  diffBegin() {
    return { tick: state.sim.clock.tick || 0, deltas: [], fired: 0, linksAdded: 0, maxAbsDelta: 0 };
  },
  diffAdd(diff, label, delta) {
    const d = Number(delta||0);
    diff.deltas.push({label, delta:d});
    diff.maxAbsDelta = Math.max(diff.maxAbsDelta, Math.abs(d));
  },

  // ---- Rule format (minimal)
  // rule = { id, name, when:{...}, then:[...], limits:{maxPerTick?} }
  
  resolveTagToken(x){
    if (!x) return x;
    // allow either tagId or tag name (lowercase)
    if (typeof x === "string") {
      // if it's an existing id, keep
      if ((state.index.tags||[]).some(t=>t.id===x)) return x;
      const name = x.trim().toLowerCase();
      const found = (state.index.tags||[]).find(t=>String(t.name||"").toLowerCase()===name);
      return found ? found.id : x;
    }
    if (typeof x === "object" && x.id) return x.id;
    return x;
  },

  outLinksCount(fromEntity, kindId, toTypeId=null){
    let n = 0;
    const links = fromEntity?.links || [];
    for (const l of links) {
      if (kindId && l.kindId !== kindId) continue;
      if (toTypeId) {
        const to = entityById(l.toId);
        if (!to || to.typeId !== toTypeId) continue;
      }
      n++;
    }
    return n;
  },

  // ---- Rule format (minimal)
  // rule = { id, name, when:{...}, then:[...], limits:{maxPerTick?} }
  matchRule(rule, ctx) {
    // Minimal matcher v1:
    // - when.tagsAll / tagsAny / tagsNone: tag ids or names
    // - when.typeIs: ctx.entity.typeId match
    // - when.linkCount: inbound links count
    // - when.outLinkCount: outbound links count
    // - when.facet: reads fields.__facets[key]
    const w = rule.when || {};

    if (w.typeIs && ctx.entity?.typeId !== w.typeIs) return false;

    // tags
    const tagsAll = Array.isArray(w.tagsAll) ? w.tagsAll.map(Sim.resolveTagToken) : null;
    const tagsAny = Array.isArray(w.tagsAny) ? w.tagsAny.map(Sim.resolveTagToken) : null;
    const tagsNone = Array.isArray(w.tagsNone) ? w.tagsNone.map(Sim.resolveTagToken) : null;

    if (tagsAll && tagsAll.length) {
      for (const tid of tagsAll) if (!ctx.tags.has(tid)) return false;
    }
    if (tagsAny && tagsAny.length) {
      let ok = false;
      for (const tid of tagsAny) if (ctx.tags.has(tid)) { ok = true; break; }
      if (!ok) return false;
    }
    if (tagsNone && tagsNone.length) {
      for (const tid of tagsNone) if (ctx.tags.has(tid)) return false;
    }

    // inbound links
    if (w.linkCount) {
      const { kindId, gte=null, lte=null, fromTypeId=null } = w.linkCount;
      const inbound = Sim.inboundLinks(ctx.entity.id, kindId, fromTypeId);
      if (gte!=null && inbound < gte) return false;
      if (lte!=null && inbound > lte) return false;
    }

    // outbound links
    if (w.outLinkCount) {
      const { kindId, gte=null, lte=null, toTypeId=null } = w.outLinkCount;
      const out = Sim.outLinksCount(ctx.entity, kindId, toTypeId);
      if (gte!=null && out < gte) return false;
      if (lte!=null && out > lte) return false;
    }

    // facet check
    if (w.facet) {
      const key = String(w.facet.key||"").trim();
      const gte = w.facet.gte;
      const lte = w.facet.lte;
      const v0 = ctx.entity?.fields?.__facets?.[key];
      const v = (v0==="" || v0==null) ? null : Number(v0);
      if (gte!=null && (v==null || v < gte)) return false;
      if (lte!=null && (v==null || v > lte)) return false;
    }

    return true;
  },

  inboundLinks(toId, kindId, fromTypeId=null) {
    let n = 0;
    for (const e of state.world.entities) {
      if (fromTypeId && e.typeId !== fromTypeId) continue;
      const links = e.links || [];
      for (const l of links) {
        if (l.toId === toId && (!kindId || l.kindId === kindId)) n++;
      }
    }
    return n;
  },

  applyEffects(rule, ctx, diff) {
    for (const eff of (rule.then || [])) {
      // Effect types (minimal v0):
      // - {resource:{key:"coin", add:+1}}
      // - {tag:{add:tagId}} adds to entity.tagIds
      // - {link:{fromId, toId, kindId, note?}} adds link
      // - {facet:{key:"rarity", add:+1}} writes into fields.__facets
      if (eff.resource) {
        const k = eff.resource.key;
        const add = Number(eff.resource.add||0);
        state.sim.resources[k] = Number(state.sim.resources[k]||0) + add;
        Sim.diffAdd(diff, `res.${k}`, add);
        Sim.pushEvent(Sim.ev("RESOURCE_DELTA", { ruleId: rule.id, resource: k, delta: add }));
      }

      
      if (eff.tag?.add) {
        const tid = Sim.resolveTagToken(eff.tag.add);
        const exists = (state.index.tags||[]).some(t=>t.id===tid);
        if (!exists) {
          Sim.pushEvent(Sim.ev("WARN", { ruleId: rule.id, entityId: ctx.entity.id, why: `Unknown tag ref: ${String(eff.tag.add)}` }));
        } else {
          ctx.entity.tagIds = ctx.entity.tagIds || [];
          if (!ctx.entity.tagIds.includes(tid)) {
            ctx.entity.tagIds.push(tid);
            ctx.entity.updatedAt = nowISO();
            Sim.pushEvent(Sim.ev("TAG_ADDED", { ruleId: rule.id, entityId: ctx.entity.id, tagId: tid }));
          }
        }
      }

      if (eff.link) {
        const from = entityById(eff.link.fromId);
        if (from) {
          from.links = from.links || [];
          from.links.push({ kindId: eff.link.kindId, toId: eff.link.toId, note: eff.link.note || "" });
          from.updatedAt = nowISO();
          diff.linksAdded++;
          Sim.pushEvent(Sim.ev("LINK_ADDED", { ruleId: rule.id, fromId: from.id, toId: eff.link.toId, kindId: eff.link.kindId }));
        }
      }

      if (eff.facet) {
        const k = eff.facet.key;
        const add = Number(eff.facet.add||0);
        ctx.entity.fields = ctx.entity.fields || {};
        ctx.entity.fields.__facets = ctx.entity.fields.__facets || {};
        const before = clamp10(ctx.entity.fields.__facets[k] ?? 0);
        const after = clamp10(before + add);
        ctx.entity.fields.__facets[k] = after;
        ctx.entity.updatedAt = nowISO();
        Sim.diffAdd(diff, `${ctx.entity.name}.${k}`, after - before);
        Sim.pushEvent(Sim.ev("FACET_DELTA", { ruleId: rule.id, entityId: ctx.entity.id, facet: k, before, after }));
      }
    }
  },

  // evaluate all rules against a set of candidate entities
  runTick({ candidates }) {
    const diff = Sim.diffBegin();
    const rules = state.sim.rules || [];
    const firedCountByRule = new Map();
    const maxFires = state.sim.settings.maxRuleFiringsPerTick || 25;

    for (const ent of candidates) {
      const tags = new Set(ent.tagIds || []);
      const ctx = { entity: ent, tags };

      for (const rule of rules) {
        if (diff.fired >= maxFires) break;

        const lim = rule.limits || {};
        const perTick = Number(lim.maxPerTick || 999);

        const firedSoFar = firedCountByRule.get(rule.id) || 0;
        if (firedSoFar >= perTick) continue;

        if (!Sim.matchRule(rule, ctx)) continue;

        firedCountByRule.set(rule.id, firedSoFar + 1);
        diff.fired++;

        Sim.pushEvent(Sim.ev("RULE_FIRED", {
          ruleId: rule.id,
          entityId: ent.id,
          name: rule.name || rule.id
        }));

        Sim.applyEffects(rule, ctx, diff);
      }
      if (diff.fired >= maxFires) break;
    }

    // runaway detection (simple)
    const R = state.sim.settings.runaway || {};
    const runaway =
      (diff.fired > (R.maxRuleFirings||80)) ||
      (diff.linksAdded > (R.maxLinksAdded||25)) ||
      (diff.maxAbsDelta > (R.maxAbsDelta||25));

    if (runaway) {
      Sim.pushEvent(Sim.ev("RUNAWAY_DETECTED", {
        fired: diff.fired,
        linksAdded: diff.linksAdded,
        maxAbsDelta: diff.maxAbsDelta
      }));
      if (state.sim.settings.stopOnRunaway) {
        state.sim.settings.autoTick = false;
      }
    }

    state.sim.lastDiff = diff;
    state.sim.clock.tick = (state.sim.clock.tick || 0) + 1;
    state.sim.clock.lastTickAt = nowISO();
  }
};


function normalizeSeeds() {
  const tagByName = new Map(state.index.tags.map(t => [t.name.toLowerCase(), t]));
  function ensureTag(name, categoryFallback="tone") {
    const k = (name||"").trim().toLowerCase();
    if (!k) return null;
    if (tagByName.has(k)) return tagByName.get(k).id;
    const t = { id: uid(), name:k, categoryId: categoryFallback };
    state.index.tags.push(t);
    tagByName.set(k, t);
    return t.id;
  }

  for (const e of state.world.entities) {
    if (e._seedTagNames?.length) {
      e.tagIds = e._seedTagNames.map(n => ensureTag(n, "tone")).filter(Boolean);
      delete e._seedTagNames;
    }
  }
  for (const c of state.characters.list) {
    if (c._seedTagNames?.length) {
      c.tagIds = c._seedTagNames.map(n => ensureTag(n, "race")).filter(Boolean);
      delete c._seedTagNames;
    }
  }

  // Add race tags to seeded Race options
  const knownRaces = new Map(tagsInCategory("race").map(t=>[t.name.toLowerCase(), t.id]));
  const raceStep = state.generator.steps.find(s => s.name.toLowerCase().includes("race"));
  if (raceStep?.options?.length) {
    raceStep.options.forEach(o => {
      const rid = knownRaces.get((o.label||"").toLowerCase());
      if (rid) {
        o.tagIds = o.tagIds || [];
        if (!o.tagIds.includes(rid)) o.tagIds.push(rid);
      }
    });
  }

  // Seed domain tags on library stuff for synergy
  const tagIdByLower = new Map(state.index.tags.map(t=>[t.name.toLowerCase(), t.id]));
  function ensureTagOnEntity(entName, tagLower) {
    const ent = state.world.entities.find(e => e.name === entName);
    const tid = tagIdByLower.get(tagLower);
    if (!ent || !tid) return;
    ent.tagIds = ent.tagIds || [];
    if (!ent.tagIds.includes(tid)) ent.tagIds.push(tid);
  }
  ensureTagOnEntity("Scout", "scouting");
  ensureTagOnEntity("Fighter", "martial");
  ensureTagOnEntity("Crafter", "crafting");
  ensureTagOnEntity("Quickstep Feint", "scouting");
  ensureTagOnEntity("Barkskin Habit", "primal");
  ensureTagOnEntity("Runic Craft", "runic");
  ensureTagOnEntity("Storm Calling", "storm");

  // Ensure a default Quant Profile is selected
  if (!state.quant) state.quant = { defaultProfileId: null, visualWheel: false };
  if (!state.quant.defaultProfileId) {
    const qp = state.world.entities.find(e=>e.typeId==="quant_profile");
    if (qp) state.quant.defaultProfileId = qp.id;
  }
}



function getEntityById(id){ return state.world.entities.find(e=>e.id===id) || null; }

/** -------------------- QUANTIFICATION MODULE (Profiles + Non-linear) -------------------- */
function parseNumList(str, fallback, expectLen=11) {
  try {
    const arr = (str||"").split(",").map(s=>Number(s.trim())).filter(x=>!Number.isNaN(x));
    if (arr.length === expectLen) return arr;
  } catch {}
  return fallback;
}
function safeJSON(str, fallback) {
  try { return JSON.parse(str); } catch { return fallback; }
}
function getQuantProfiles() {
  return state.world.entities.filter(e=>e.typeId==="quant_profile");
}
function getQuantProfileById(id) {
  return state.world.entities.find(e=>e.typeId==="quant_profile" && e.id===id) || null;
}
function getDefaultQuantProfile() {
  const id = state.quant?.defaultProfileId || null;
  return (id ? getQuantProfileById(id) : null) || getQuantProfiles()[0] || null;
}
function getQuantProfileForEntity(entity) {
  const chosen = entity?.fields?.quantProfileId ? getQuantProfileById(entity.fields.quantProfileId) : null;
  return chosen || getDefaultQuantProfile();
}

function parseLabelsInput(x){
  if (!x) return null;
  if (Array.isArray(x)) return x;
  const s = String(x).trim();
  if (!s) return null;
  // allow comma or newline separated
  const parts = s.split(/\n|,/).map(p=>p.trim()).filter(Boolean);
  if (parts.length>=11) return parts.slice(0,11);
  return null;
}

function getFacetDefsForType(typeId){
  const map = state?.index?.facetDefsByType || DEFAULT_FACET_DEFS_BY_TYPE;
  const defs = map?.[typeId] || DEFAULT_FACET_DEFS_BY_TYPE[typeId] || [];
  return defs.filter(d=>d && d.key && d.enabled!==false);
}

function getFacetDef(typeId, key){
  const defs = getFacetDefsForType(typeId);
  return defs.find(d=>d.key===key) || null;
}

function facetLabel(typeId, key, v){
  const n = clamp10(v);
  const def = getFacetDef(typeId, key);
  const labs = parseLabelsInput(def?.labels);
  if (labs && labs[n]) return `${n} — ${labs[n]}`;
  // If this facet maps to a canonical Quant channel, use that channel's wording.
  const canon = (def?.mapsTo && Quant.CANON_KEYS.includes(def.mapsTo)) ? def.mapsTo : (Quant.CANON_KEYS.includes(key) ? key : "generic");
  return Quant.labelFor(canon, n);
}

function ensureEntityFacets(entity){
  if (!entity) return;
  if (!entity.fields) entity.fields = {};
  if (!entity.fields.__facets) entity.fields.__facets = {};
}
const Quant = (() => {
  const DEFAULT_POWER_UNITS = [0,1,2,3,5,8,13,21,34,55,89];
  const DEFAULT_SCOPE_MULT  = [1.00,1.05,1.10,1.20,1.35,1.55,1.80,2.10,2.50,3.20,4.20];
  const DEFAULT_PRESTIGE_UNITS = [0,2,4,7,10,14,19,25,40,55,65];

  const DEFAULT_USE_W = { power:0.25, utility:0.30, reliability:0.20, frequency:0.15, scope:0.10 };
  const DEFAULT_EFF_W = { complexity:0.45, upkeep:0.35, access:0.20 };

  const CANON_KEYS = ["power","utility","reliability","scope","frequency","complexity","upkeep","access","rarity"];

  const LABELS_GENERIC = [
    "None","Trace","Low","Minor","Moderate","Notable","High","Very High","Exceptional","Legendary","Transcendent"
  ];
  // Facet-specific labels (0–10). Keep meanings appropriate per facet.
  const LABELS_POWER = [
    "None","Faint","Weak","Modest","Sturdy","Strong","Potent","Mighty","Overwhelming","Mythic","Transcendent"
  ];
  const LABELS_UTILITY = [
    "None","Niche","Limited","Situational","Useful","Versatile","Broad","Major","Exceptional","Game-changing","World-defining"
  ];
  const LABELS_RELIABILITY = [
    "Unreliable","Shaky","Spotty","Inconsistent","Fair","Dependable","Reliable","Very Reliable","Near-certain","Certain","Absolute"
  ];
  const LABELS_COMPLEXITY = [
    "Trivial","Simple","Basic","Trained","Demanding","Complex","Expert","Arcane","Masterwork","Esoteric","Impossible"
  ];
  const LABELS_UPKEEP = [
    "None","Negligible","Light","Low","Moderate","Ongoing","Heavy","Costly","Severe","Crippling","Unsustainable"
  ];
  const LABELS_SCOPE = [
    "Self","Touch","Close","Duel","Small skirmish","Skirmish","Battlefield","Large battlefield","Warfront","Regional","World-weird"
  ];
  const LABELS_FREQ = [
    "Once (effectively)","Rarely (months)","Infrequent (weeks)","Occasional (days)","Daily limited","Daily reliable",
    "Often (many/day)","Frequent","Spammable","Constant-ready","Passive/always-on"
  ];
  const LABELS_ACCESS = [
    "Anyone","Common training","Apprenticeship","Specialist","Needs status/gear","Rare mentor/region","Major org",
    "Lineage/oath/rite","Unique condition","Near-impossible","Unattainable"
  ];
  const LABELS_RARITY = [
    "Ubiquitous","Very common","Common","Uncommon","Rare","Very rare","Scarce","Exceptional","Singular","Mythic","Unique"
  ];

  function clamp10(v){ return clamp(Number(v)||0, 0, 10); }

  function profileData(profileEnt) {
    const f = profileEnt?.fields || {};
    const powerUnits = parseNumList(f.powerUnits, DEFAULT_POWER_UNITS, 11);
    const scopeMult = parseNumList(f.scopeMult, DEFAULT_SCOPE_MULT, 11);
    const prestigeUnits = parseNumList(f.prestigeUnits, DEFAULT_PRESTIGE_UNITS, 11);
    const useW = safeJSON(f.useWeights, DEFAULT_USE_W);
    const effW = safeJSON(f.effortWeights, DEFAULT_EFF_W);
    return { powerUnits, scopeMult, prestigeUnits, useW, effW };
  }

  function facetMaps(entity) {
    const fx = entity?.fields?.__facets || {};
    const typeId = entity?.typeId || "skill";

    const raw = {};
    const eff = {};
    const sources = {};
    const present = {};
    CANON_KEYS.forEach(k=>{ eff[k]=0; sources[k]=[]; present[k]=false; });

    const defs = getFacetDefsForType(typeId);
    if (defs.length) {
      defs.forEach(def=>{
        const k = (def?.key || "").trim();
        if (!k) return;
        const v = clamp10(fx[k]);
        raw[k] = v;

        const canon = (def?.mapsTo && CANON_KEYS.includes(def.mapsTo)) ? def.mapsTo : (CANON_KEYS.includes(k) ? k : null);
        if (!canon) return;

        eff[canon] = Math.max(eff[canon], v);
        sources[canon].push({key:k, v});
        present[canon] = true;
      });
    } else {
      // Fallback: if no facet set exists, read canonical keys directly.
      CANON_KEYS.forEach(k=>{
        const v = clamp10(fx[k]);
        eff[k] = v;
        sources[k] = [{key:k, v}];
        present[k] = true;
      });
    }

    return { raw, eff, sources, present };
  }

  function blendedScore(values, weights, keys) {
    let sumW = 0, sum = 0;
    keys.forEach(k=>{
      const w = Number(weights?.[k] ?? 0);
      if (!(w > 0)) return;
      sumW += w;
      sum += w * Number(values?.[k] ?? 0);
    });
    if (!(sumW > 0)) return 0;
    return 10 * (sum / sumW); // 0..100
  }

  function compute(entity) {
    const profile = getQuantProfileForEntity(entity);
    const P = profileData(profile);

    const M = facetMaps(entity);
    const F = M.eff;
    const present = M.present;

    const powerV = present.power ? F.power : 0;
    const scopeV = present.scope ? F.scope : 0;

    const potencyUnits = P.powerUnits[powerV] ?? P.powerUnits[0];
    const scopeMult = P.scopeMult[scopeV] ?? 1.0;
    const influenceUnits = potencyUnits * scopeMult;

    // Usefulness: blend only channels that exist for this type, and re-normalize weights.
    const useKeys = ["utility","power","reliability","frequency","scope"].filter(k=>present[k]);
    const u = blendedScore(F, P.useW, useKeys);

    // Effort: blend only effort channels that exist for this type, and re-normalize weights.
    const effKeys = ["complexity","upkeep","access"].filter(k=>present[k]);
    const e = blendedScore(F, P.effW, effKeys);

    const nv = clamp(u - 0.55*e, 0, 100);

    // Prestige: based on rarity + access only if those channels exist for this type.
    let prestigeRaw = 0;
    let prestigeMax = 0;
    const maxUnit = (P.prestigeUnits[10] ?? 65);

    if (present.rarity) { prestigeRaw += (P.prestigeUnits[F.rarity] ?? 0); prestigeMax += maxUnit; }
    if (present.access) { prestigeRaw += (P.prestigeUnits[F.access] ?? 0); prestigeMax += maxUnit; }

    const prestige = prestigeMax > 0 ? clamp((prestigeRaw / prestigeMax) * 100, 0, 100) : 0;

    // Rarity factor for roll weights (0.35..1.15). Higher prestige => rarer => lower roll chance.
    const rarityFactor = clamp(1.15 - 0.008*prestige, 0.35, 1.15);

    return {
      profileId: profile?.id || null,
      facets: F,                 // canonical channels (after mapping)
      rawFacets: M.raw,          // raw facet keys (as defined for this entity type)
      facetSources: M.sources,   // canonical channel -> [{key,v},...]
      facetPresent: present,     // which canonical channels exist for this type
      usedKeys: { usefulness: useKeys, effort: effKeys },

      potencyUnits,
      influenceUnits,
      usefulness: clamp(u,0,100),
      effort: clamp(e,0,100),
      netValue: nv,
      prestige,
      rarityFactor
    };
  }

  function labelFor(key, v) {
    const n = clamp10(v);
    let lab = null;

    // facet-specific wording first
    if (key === "power") lab = LABELS_POWER[n];
    else if (key === "utility") lab = LABELS_UTILITY[n];
    else if (key === "reliability") lab = LABELS_RELIABILITY[n];
    else if (key === "complexity") lab = LABELS_COMPLEXITY[n];
    else if (key === "upkeep") lab = LABELS_UPKEEP[n];
    else if (key === "scope") lab = LABELS_SCOPE[n];
    else if (key === "frequency") lab = LABELS_FREQ[n];
    else if (key === "access") lab = LABELS_ACCESS[n];
    else if (key === "rarity") lab = LABELS_RARITY[n];

    // fallback
    if (!lab) lab = LABELS_GENERIC[n] || "";
    return `${n} — ${lab}`;
  }

  function tierFromUsefulness(u, scope) {
    let tier = "Mundane";
    if (u>=20) tier="Trained";
    if (u>=40) tier="Notable";
    if (u>=60) tier="Exceptional";
    if (u>=75) tier="Mythic";
    if (u>=90) tier="Impossible";
    // scope bump
    if (scope>=9) tier = bumpTier(tier, 2);
    else if (scope>=6) tier = bumpTier(tier, 1);
    return tier;
  }
  function bumpTier(t, n){
    const order=["Mundane","Trained","Notable","Exceptional","Mythic","Impossible"];
    let i=order.indexOf(t); if (i<0) i=0;
    i = clamp(i+n, 0, order.length-1);
    return order[i];
  }
return { CANON_KEYS, compute, labelFor, tierFromUsefulness };
})();

function renderTagChips(selectedIds, onToggle, opts={}) {
  const filterCategoryId = opts.filterCategoryId || null;
  const showCreate = !!opts.showCreate;
  const createCategoryId = opts.createCategoryId || null;

  const byCat = new Map();
  for (const cat of state.index.tagCategories) byCat.set(cat.id, []);
  for (const t of state.index.tags) {
    if (!byCat.has(t.categoryId)) byCat.set(t.categoryId, []);
    byCat.get(t.categoryId).push(t);
  }

  const container = el("div", {class:"col"});

  if (showCreate) {
    const row = el("div",{class:"row"});
    const inp = el("input",{id: opts.createInputId || "", placeholder:"Add new tag (enter)…"});
    const catSel = el("select");
    state.index.tagCategories.forEach(c=>{
      if (filterCategoryId && c.id !== filterCategoryId) return;
      catSel.appendChild(el("option",{value:c.id, text:c.name}));
    });
    if (createCategoryId) catSel.value = createCategoryId;

    const btn = el("button",{class:"primary", text:"Add tag", onclick: ()=>{
      const name = inp.value.trim();
      if (!name) return;
      const id = uid();
      state.index.tags.push({id, name, categoryId: catSel.value});
      inp.value = "";
      saveState();
      onToggle(id);
      renderPreserveFocus();
    }});
    row.appendChild(inp);
    row.appendChild(catSel);
    row.appendChild(btn);
    container.appendChild(el("div",{class:"createBox"}, [
      el("div",{class:"title", text:"CREATE NEW TAG"}),
      el("div",{class:"muted", text:"(optional, but great for coherence)"}),
      row
    ]));
    container.appendChild(el("div",{class:"hr"}));
  }

  for (const cat of state.index.tagCategories) {
    if (filterCategoryId && cat.id !== filterCategoryId) continue;
    const tags = (byCat.get(cat.id) || []).slice().sort((a,b)=>a.name.localeCompare(b.name));
    if (!tags.length) continue;

    container.appendChild(el("div", {class:"muted", text:cat.name}));
    const chips = el("div", {class:"chips"});
    tags.forEach(t => {
      const isOn = selectedIds.includes(t.id);
      chips.appendChild(el("div", {
        class: "chip" + (isOn ? " on":""),
        text: t.name,
        onclick: () => onToggle(t.id)
      }));
    });
    container.appendChild(chips);
    container.appendChild(el("div", {class:"hr"}));
  }
  return container;
}


/** -------------------- SKILL GENERATION MODULE -------------------- 
 *  Drop-in module to generate "skill fields" from tags + context.
 *  Where it's used:
 *   - World → Skill entries: "Generate defaults from tags"
 *   - Characters → Skills: "Generate + add new skill" from character context
 */
const SkillGen = (() => {
  const toNum = (x, d=0) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : d;
  };
  const tagLowerSet = (tagIds=[]) => {
    const s = new Set();
    for (const tid of (tagIds||[])) {
      const t = tagById(tid);
      if (t?.name) s.add(String(t.name).toLowerCase());
    }
    return s;
  };

  // Small heuristic table. Add your own tags here over time.
  const HEUR = {
    power: {
      martial: +2, storm: +2, blood: +2, primal: +1, arcane: +1,
      scouting: 0, crafting: -1, social: -1, illusion: 0, runic: 0,
      stealth: +1,
    },
    utility: {
      scouting: +2, crafting: +2, social: +2, illusion: +2, runic: +1,
      martial: 0, storm: -1, blood: -1, primal: 0, arcane: +1,
      stealth: +1,
    },
    risk: {
      blood: +3, storm: +2, arcane: +1, primal: +1,
      martial: 0, scouting: 0, crafting: 0, social: 0, illusion: +1, runic: +1,
      stealth: 0,
    },
    cooldown: { // higher = rarer use / longer cooldown
      storm: +2, blood: +2, arcane: +1, martial: +1,
      scouting: 0, crafting: 0, social: 0, illusion: 0, runic: 0, primal: 0,
      stealth: 0,
    }
  };

  function bumpFromTags(base, tagSet, table) {
    let out = base;
    for (const [k, delta] of Object.entries(table)) {
      if (tagSet.has(k)) out += delta;
    }
    return out;
  }

  function deriveScope(tagSet) {
    if (tagSet.has("storm")) return "Battle";
    if (tagSet.has("blood")) return "Skirmish";
    if (tagSet.has("martial") || tagSet.has("stealth")) return "Duel";
    if (tagSet.has("scouting")) return "Utility";
    if (tagSet.has("crafting") || tagSet.has("runic")) return "Utility";
    if (tagSet.has("primal")) return "Skirmish";
    return "Skirmish";
  }

  function deriveEvolves(tagSet) {
    // Wandering-Inn-ish vibe: most skills can “deepen”, some clearly don't.
    if (tagSet.has("crafting")) return "yes";
    if (tagSet.has("martial") || tagSet.has("scouting") || tagSet.has("stealth")) return "yes";
    if (tagSet.has("storm") || tagSet.has("blood") || tagSet.has("arcane") || tagSet.has("primal") || tagSet.has("runic") || tagSet.has("illusion")) return "yes";
    return "yes";
  }

  // Main: generate numeric fields 1–10 based on tags and context overlap
  function generateFields(skillTagIds=[], contextTagIds=[]) {
    const tagSet = tagLowerSet(skillTagIds);
    const ctxSet = tagLowerSet(contextTagIds);

    // Base values (mid)
    let power = 4, utility = 5, risk = 3, cooldown = 2;

    power = bumpFromTags(power, tagSet, HEUR.power);
    utility = bumpFromTags(utility, tagSet, HEUR.utility);
    risk = bumpFromTags(risk, tagSet, HEUR.risk);
    cooldown = bumpFromTags(cooldown, tagSet, HEUR.cooldown);

    // Context tilt: if it matches the character context, slightly increase utility.
    let overlap = 0;
    for (const t of tagSet) if (ctxSet.has(t)) overlap++;
    utility += Math.min(2, overlap);

    // Clamp
    power = clamp(power, 1, 10);
    utility = clamp(utility, 1, 10);
    risk = clamp(risk, 1, 10);
    cooldown = clamp(cooldown, 1, 10);

    const scope = deriveScope(tagSet);
    const evolves = deriveEvolves(tagSet);

    return {
      power: String(power),
      utility: String(utility),
      risk: String(risk),
      cooldown: String(cooldown),
      scope,
      evolves,
      evolve_notes: evolves === "yes"
        ? "How could this deepen with practice? What changes at mastery—scope, precision, or side effects?"
        : ""
    };
  }

  // Apply to an existing skill entity (keeps description)
  function applyToSkillEntity(skillEntity, contextTagIds=[]) {
    if (!skillEntity || skillEntity.typeId !== "skill") return;
    skillEntity.fields = skillEntity.fields || {};
    const gen = generateFields(skillEntity.tagIds||[], contextTagIds);
    skillEntity.fields.power = gen.power;
    skillEntity.fields.utility = gen.utility;
    skillEntity.fields.risk = gen.risk;
    skillEntity.fields.cooldown = gen.cooldown;
    skillEntity.fields.scope = gen.scope;
    skillEntity.fields.evolves = gen.evolves;
    if (!skillEntity.fields.evolve_notes) skillEntity.fields.evolve_notes = gen.evolve_notes;
    skillEntity.updatedAt = nowISO();
  }

  // Create a brand new skill entity from context + optional extra tags
  function createGeneratedSkill({name, tagIds=[], contextTagIds=[]} = {}) {
    const e = seedEntity("skill", name || "Untitled Skill", {}, [], []);
    e.tagIds = Array.from(new Set(tagIds || []));
    e.fields.description = "";
    applyToSkillEntity(e, contextTagIds);
    return e;
  }

  return { generateFields, applyToSkillEntity, createGeneratedSkill };
})();


/** -------------------- WEIGHTING -------------------- */
function countOverlap(aIds, bIds) {
  const b = new Set(bIds);
  let c = 0;
  for (const x of aIds) if (b.has(x)) c++;
  return c;
}
function countConflicts(optionTagIds, contextTagIds) {
  const ctx = new Set(contextTagIds);
  const opt = new Set(optionTagIds);
  let hits = 0;
  for (const pair of (state.index.tagConflicts || [])) {
    const a = pair.a, b = pair.b;
    const ok = (opt.has(a) && ctx.has(b)) || (opt.has(b) && ctx.has(a));
    if (ok) hits++;
  }
  return hits;
}

/** -------------------- ROLLER (single source of truth for weighted rolls) -------------------- */
const Roller = (()=>{
  function getRules(genOrRules){
    return genOrRules?.rules ? genOrRules.rules : (genOrRules || state.generator.rules);
  }

  function computeWeights(options, genOrRules, contextTags){
    const rules = getRules(genOrRules);
    const details = options.map(o => {
      const base = Math.max(0, Number(o.baseWeight ?? 1));
      const optTags = o.tagIds || [];
      const overlap = clamp(countOverlap(optTags, contextTags), 0, rules.maxSynergyCount);
      const conflicts = clamp(countConflicts(optTags, contextTags), 0, rules.maxInverseCount);
      let w = base + overlap * rules.synergyBoost - conflicts * rules.inversePenalty;
      w = Math.max(0.01, w);

      let rarityFactor = null;
      let prestige = null;
      if (o.refId) {
        const ent = getEntityById(o.refId);
        if (ent) {
          const q = Quant.compute(ent);
          rarityFactor = q.rarityFactor;
          prestige = q.prestige;
          w *= q.rarityFactor;
        }
      }
      return { base, overlap, conflicts, rarityFactor, prestige, w: Math.max(0.01, w) };
    });
    const weights = details.map(d=>d.w);
    const total = weights.reduce((a,b)=>a+b,0) || 1;
    const explainFor = (i)=>{
      const d = details[i];
      if (!d) return "";
      const parts = [`base ${d.base}`];
      if (d.overlap) parts.push(`+ synergy ${d.overlap}×${getRules(genOrRules).synergyBoost}`);
      if (d.conflicts) parts.push(`− conflict ${d.conflicts}×${getRules(genOrRules).inversePenalty}`);
      if (d.rarityFactor!=null) parts.push(`× rarity ${Number(d.rarityFactor).toFixed(2)}`);
      return parts.join(" ");
    };
    return { weights, total, details, explainFor };
  }

  function pickWeighted(options, genOrRules, contextTags){
    const {weights, total, explainFor} = computeWeights(options, genOrRules, contextTags);
    let r = Math.random() * total;
    let idx = 0;
    for (let i=0;i<weights.length;i++){
      r -= weights[i];
      if (r<=0){ idx=i; break; }
      idx=i;
    }
    return { picked: options[idx], index: idx, weights, total, explainFor };
  }

  function softRoll(options, genOrRules, contextTags, n=3){
    return softRollDetailed(options, genOrRules, contextTags, n).map(x=>x.picked);
  }

  function softRollDetailed(options, genOrRules, contextTags, n=3){
    const pool = options.slice();
    const out = [];
    for (let i=0;i<n && pool.length;i++){
      const wp = pickWeighted(pool, genOrRules, contextTags);
      out.push({ picked: wp.picked, explain: wp.explainFor(wp.index) });
      const j = pool.findIndex(x => (x.id === wp.picked.id && x.label === wp.picked.label));
      if (j>=0) pool.splice(j,1);
    }
    return out;
  }

  return { computeWeights, pickWeighted, softRoll, softRollDetailed };
})();

function weightedPick(options, gen, contextTags) {
  // Back-compat wrapper
  return Roller.pickWeighted(options, gen, contextTags);
}
function softRoll(options, gen, contextTags, n=3) {
  // Back-compat wrapper
  return Roller.softRoll(options, gen, contextTags, n);
}
function pushUndo(gen) {
  gen.undoStack = gen.undoStack || [];
  gen.undoStack.push(deep({
    currentStepIndex: gen.currentStepIndex,
    lastResult: gen.lastResult,
    candidates: gen.candidates,
    history: gen.history,
    locks: gen.locks,
    rules: gen.rules,
    run: gen.run
  }));
  gen.undoStack = gen.undoStack.slice(0, 50);
}
function undo(gen) {
  if (!gen.undoStack?.length) return;
  const prev = gen.undoStack.pop();
  gen.currentStepIndex = prev.currentStepIndex;
  gen.lastResult = prev.lastResult;
  gen.candidates = prev.candidates;
  gen.history = prev.history;
  gen.locks = prev.locks;
  gen.rules = prev.rules;
  gen.run = prev.run || {draft:""};
}

/** -------------------- GENERATOR UTILITIES -------------------- */
function getStepOptions(step) {
  if (step.source === "manual") {
    return (step.options || []).map(o => ({
      id: o.id,
      label: o.label,
      baseWeight: Number(o.baseWeight ?? 1),
      tagIds: o.tagIds || [],
      notes: o.notes || "",
      refId: null
    }));
  }
  if (step.source.startsWith("library:")) {
    const typeId = step.source.split(":")[1];
    return state.world.entities
      .filter(e => e.typeId === typeId)
      .map(e => ({ id:e.id, label:e.name, baseWeight:1.0, tagIds:(e.tagIds||[]), notes:"", refId:e.id }));
  }
  return [];
}
function contextTagIdsFromLocks(gen) {
  const tags = new Set();
  for (const v of Object.values(gen.locks || {})) {
    (v.tagIds || []).forEach(t => tags.add(t));
    if (v.refId) {
      const e = entityById(v.refId);
      (e?.tagIds || []).forEach(t => tags.add(t));
    }
  }
  return Array.from(tags);
}
function normalizeResult(step, opt, gen, contextTags, weightMaybe) {
  const refId = opt?.refId || (step.source?.startsWith("library:") ? opt?.id : null) || null;
  const tagIds = opt?.tagIds || (refId ? (entityById(refId)?.tagIds || []) : []);
  let why = "";
  if (gen.rules.explainWeights) {
    if (typeof weightMaybe === "string" && weightMaybe) {
      why = weightMaybe;
    } else {
      const overlap = clamp(countOverlap(tagIds, contextTags), 0, gen.rules.maxSynergyCount);
      const conflicts = clamp(countConflicts(tagIds, contextTags), 0, gen.rules.maxInverseCount);
      const base = Math.max(0, Number(opt?.baseWeight ?? 1));
      const eff = (typeof weightMaybe === "number" ? weightMaybe : (base + overlap*gen.rules.synergyBoost - conflicts*gen.rules.inversePenalty));
      why = `w=${Number(eff).toFixed(2)} (base ${base.toFixed(2)}, +${overlap} synergy, -${conflicts} conflict)`;
    }
  }
  return { label: opt?.label || "(none)", refId, tagIds, why };
}
function locksName(gen) {
  const steps = gen.steps || state.generator.steps;
  const raceStep = steps.find(s=>s.name.toLowerCase().includes("race"));
  const classStep = steps.find(s=>s.source==="library:class" || s.name.toLowerCase().includes("class"));
  const r = raceStep ? gen.locks[raceStep.id]?.label : null;
  const c = classStep ? gen.locks[classStep.id]?.label : null;
  if (r && c) return `${r} ${c}`;
  const first = Object.values(gen.locks||{})[0]?.label;
  return first ? `${first}` : "Generated Character";
}

/** -------------------- TAB WIRING -------------------- */
function setTab(tab) { state.ui.tab = tab; saveState(); renderPreserveFocus(); }
$("#tabWorld").onclick = () => setTab("world");
$("#tabChars").onclick = () => setTab("chars");
$("#tabGen").onclick = () => setTab("gen");
$("#tabCreate").onclick = () => setTab("create");
$("#tabIntake").onclick = () => setTab("intake");
$("#tabSettings").onclick = () => setTab("settings");
$("#tabSim").onclick = () => setTab("sim");
$("#tabDocs").onclick = () => setTab("docs");


// -------------------- NAV: Modes + Context Bar (Sprint 16) --------------------
// TS: UIMode = "build" | "run" | "trade" | "debug" | "meta"
const UIMODES = [
  { id:"build", label:"Build" },
  { id:"run", label:"Run" },
  { id:"trade", label:"Trade" },
  { id:"debug", label:"Debug" },
  { id:"meta", label:"Meta" },
];

// -------------------- NAV: History + Breadcrumbs (Sprint 19) --------------------
// TS: We keep a tiny, explainable navigation history so "Back" feels app-native.
// The history is linear (like a browser): jumping after going back truncates the forward stack.
let __NAV_APPLY = false; // guards against recursive history writes while applying history entries

/**
 * TS: @typedef {Object} NavEntry
 * @property {"entity"|"character"|"rule"|"pack"|"mode"} kind
 * @property {string} id
 * @property {string} label
 * @property {string=} sub
 * @property {string=} at  ISO timestamp
 */

function navHistPush(entry){
  const nav = state.ui.nav = state.ui.nav || { recent: [] };
  nav.history = Array.isArray(nav.history) ? nav.history : [];
  nav.index = (typeof nav.index === "number") ? nav.index : (nav.history.length ? nav.history.length - 1 : -1);

  const cur = nav.history[nav.index];
  if (cur && cur.kind === entry.kind && cur.id === entry.id) return;

  // truncate forward stack
  if (nav.index < nav.history.length - 1) nav.history = nav.history.slice(0, nav.index + 1);

  nav.history.push({ ...entry, at: nowISO() });

  // cap (keep UI snappy + storage small)
  const MAX = 80;
  if (nav.history.length > MAX) nav.history.splice(0, nav.history.length - MAX);
  nav.index = nav.history.length - 1;
}

function __navRememberRecent(entry){
  const nav = state.ui.nav = state.ui.nav || { recent: [] };
  const r = nav.recent || [];
  const key = `${entry.kind}:${entry.id}`;
  const filtered = r.filter(x=>`${x.kind}:${x.id}` !== key);
  filtered.unshift({ ...entry, at: nowISO() });
  nav.recent = filtered.slice(0, 12);
}

// TS: record navigation into both recents + history (unless we are applying history).
function navRecord(entry){
  __navRememberRecent(entry);
  if (!__NAV_APPLY) navHistPush(entry);
}

function navApplyEntry(entry){
  if (!entry) return;
  __NAV_APPLY = true;
  try{
    if (entry.kind === "entity") navJumpEntity(entry.id);
    else if (entry.kind === "character") navGoCharacter(entry.id);
    else if (entry.kind === "rule") navGoRule(entry.id);
    else if (entry.kind === "pack") navGoPack(entry.id);
    else if (entry.kind === "mode") setMode(entry.id);
  } finally {
    __NAV_APPLY = false;
  }
}

function navBack(){
  const nav = state.ui.nav;
  if (!nav || !Array.isArray(nav.history)) return;
  if ((nav.index||0) <= 0) return;
  nav.index = nav.index - 1;
  navApplyEntry(nav.history[nav.index]);
  saveState(); renderPreserveFocus();
}
function navForward(){
  const nav = state.ui.nav;
  if (!nav || !Array.isArray(nav.history)) return;
  if ((nav.index||-1) >= nav.history.length - 1) return;
  nav.index = nav.index + 1;
  navApplyEntry(nav.history[nav.index]);
  saveState(); renderPreserveFocus();
}

function navGoIndex(idx){
  const nav = state.ui.nav;
  if (!nav || !Array.isArray(nav.history)) return;
  const i = Number(idx);
  if (!Number.isFinite(i)) return;
  if (i < 0 || i >= nav.history.length) return;
  nav.index = i;
  navApplyEntry(nav.history[i]);
  saveState(); renderPreserveFocus();
}

// TS: jump helpers
function navGoEntity(id){
  navJumpEntity(id);
}
function navGoCharacter(id){
  const c = (state.characters.list||[]).find(x=>x && x.id===id);
  if (!c) return;
  state.ui.mode = "build";
  state.ui.tab = "chars";
  state.characters.selectedId = id;
  navRecord({kind:"character", id, label:c.name, sub:"character"});
  saveState(); renderPreserveFocus();
}
function navGoRule(ruleId){
  state.sim = state.sim || {};
  state.sim.ui = state.sim.ui || {};
  state.ui.mode = "meta";
  state.ui.tab = "sim";
  state.sim.ui.ruleFilter = ruleId;
  navRecord({kind:"rule", id:ruleId, label:ruleId, sub:"rule"});
  saveState(); renderPreserveFocus();
}
function navGoPack(packId){
  state.sim = state.sim || {};
  state.sim.ui = state.sim.ui || {};
  state.ui.mode = "meta";
  state.ui.tab = "sim";
  state.sim.ui.packFilter = packId;
  navRecord({kind:"pack", id:packId, label:packId, sub:"pack"});
  saveState(); renderPreserveFocus();
}

// TS: central mode setter (streamlines navigation without removing power features)
function setMode(mode){
  const m = String(mode||"run");
  const ok = UIMODES.some(x=>x.id===m);
  state.ui.mode = ok ? m : "run";
  if (!__NAV_APPLY){
    const lab = (UIMODES.find(x=>x.id===state.ui.mode)||{}).label || state.ui.mode;
    navRecord({kind:"mode", id: state.ui.mode, label: lab, sub:"mode"});
  }

  // Route to the right "home tab" for this mode.
  // TS: keep this routing small + explicit; it will become a router in a later sprint.
  if (state.ui.mode === "build") state.ui.tab = "world";
  else state.ui.tab = "sim";

  saveState();
  renderPreserveFocus();
}

// TS: UI helper
function getMode(){
  return state?.ui?.mode || "run";
}


// TS: lightweight search across entities/characters/rules/packs.
// Returns items with a `.go()` handler so we can keep navigation logic centralized.
function navSearch(query){
  const q = String(query||"").trim().toLowerCase();
  if (!q) return [];

  const out = [];
  const entities = (state?.world?.entities||[]);
  const chars = (state?.characters?.list||[]);
  const rules = (state?.sim?.rules||[]);
  const packs = (state?.sim?.installedPacks||[]);

  function scoreText(hay){
    const s = String(hay||"").toLowerCase();
    if (!s) return 0;
    if (s === q) return 100;
    if (s.startsWith(q)) return 60;
    if (s.includes(q)) return 25;
    return 0;
  }

  // Entities
  for (const e of entities){
    const sc = Math.max(scoreText(e.name), scoreText(e.typeId), scoreText(entityTypeName(e.typeId)));
    if (sc>0){
      out.push({
        score: sc,
        label: e.name || "(unnamed)",
        sub: `Entity · ${e.typeId}`,
        go: ()=>{ navJumpEntity(e.id); }
      });
    }
  }

  // Characters (sheet list)
  for (const c of chars){
    const sc = scoreText(c.name);
    if (sc>0){
      out.push({
        score: sc,
        label: c.name || "(unnamed)",
        sub: "Character sheet",
        go: ()=>{ state.ui.navQuery=""; state.ui.mode="build"; state.ui.tab="chars"; state.characters.selectedId=c.id;
          state.ui.nav = state.ui.nav||{recent:[]};
          const r = state.ui.nav.recent||[]; const key=`character:${c.id}`; 
          state.ui.nav.recent = [{kind:"character", id:c.id, label:c.name||"(unnamed)", sub:"character", at:nowISO()}, ...r.filter(x=>`${x.kind}:${x.id}`!==key)].slice(0,12);
          saveState(); renderPreserveFocus();
        }
      });
    }
  }

  // Sim rules
  for (const r of rules){
    const sc = Math.max(scoreText(r.id), scoreText(r.name));
    if (sc>0){
      out.push({
        score: sc,
        label: r.name ? `${r.name}` : r.id,
        sub: `Rule · ${r.id}`,
        go: ()=>{ state.ui.navQuery=""; setMode("meta"); state.sim.ui = state.sim.ui||{}; state.sim.ui.ruleFilter = r.id; saveState(); renderPreserveFocus(); }
      });
    }
  }

  // Installed packs
  for (const p of packs){
    const sc = scoreText(p);
    if (sc>0){
      out.push({
        score: sc,
        label: p,
        sub: "Pack (installed)",
        go: ()=>{ state.ui.navQuery=""; setMode("meta"); state.sim.ui = state.sim.ui||{}; state.sim.ui.packFilter = p; saveState(); renderPreserveFocus(); }
      });
    }
  }

  // Best first, then stable tie-break
  return out.sort((a,b)=> (b.score-a.score) || String(a.label).localeCompare(String(b.label)));
}

// -------------------- NAV: Jump + Focus Helpers (Sprint 18) --------------------
// TS: Centralized jump helpers so search/results can ensure visibility in the World list.
// This avoids the common "jumped, but the item isn't visible due to filters" failure mode.

function navPushRecent(entry){
  state.ui.nav = state.ui.nav || { recent: [] };
  if (!Array.isArray(state.ui.nav.recent)) state.ui.nav.recent = [];
  const key = `${entry.kind}:${entry.id}`;
  const filtered = (state.ui.nav.recent||[]).filter(x=>`${x.kind}:${x.id}` !== key);
  filtered.unshift({ ...entry, at: nowISO() });
  state.ui.nav.recent = filtered.slice(0, 12);
}

// TS: Set a short-lived "flash + scroll" focus for the World list.
function navFocusWorldEntity(entityId){
  state.ui.navFocus = { kind: "worldEntity", id: entityId, untilMs: Date.now() + 1400, didScroll: false };
}

// TS: Jump to an entity and ensure it becomes visible (switches type filter and clears narrowing filters).
function navJumpEntity(entityId){
  const e = entityById(entityId);
  if (!e) return;

  state.ui.navQuery = "";
  state.ui.mode = "build";
  state.ui.tab = "world";

  // Ensure visibility in the left list.
  state.world.selectedEntityId = entityId;
  state.world.filter.typeId = e.typeId;
  state.world.filter.text = "";
  state.world.filter.pinnedOnly = false;
  state.world.filter.tags = [];

  navFocusWorldEntity(entityId);
  navPushRecent({ kind:"entity", id:entityId, label: e.name || "(unnamed)", sub: e.typeId });

  saveState();
  renderPreserveFocus();
}

// TS: Apply focus after renderWorld builds the list.
function applyWorldNavFocus(){
  const f = state.ui.navFocus;
  if (!f || f.kind !== "worldEntity") return;
  if (Date.now() > Number(f.untilMs||0)) { state.ui.navFocus = null; return; }
  if (state.ui.tab !== "world") return;

  const row = document.querySelector(`[data-world-id="${f.id}"]`);
  if (!row) return;

  row.classList.add("flash");
  if (!f.didScroll){
    try { row.scrollIntoView({ block: "center", behavior: "smooth" }); } catch(e) { row.scrollIntoView(); }
    f.didScroll = true;

    setTimeout(()=>{
      const r = document.querySelector(`[data-world-id="${f.id}"]`);
      if (r) r.classList.remove("flash");
      if (state.ui.navFocus && state.ui.navFocus.id === f.id && Date.now() > Number(state.ui.navFocus.untilMs||0)) {
        state.ui.navFocus = null;
      }
    }, 1450);
  }
}



// TS: render/update header bars (mode + context). Called from render().
function renderNavBars(){
  const modeEl = document.getElementById("modeBar");
  const ctxEl = document.getElementById("contextBar");
  if (!modeEl || !ctxEl) return;

  // MODE BAR
  modeEl.innerHTML = "";
  const mode = getMode();

  const focus = el("input",{type:"checkbox"});
  focus.checked = !!state.ui.focusMode;
  focus.onchange = ()=>{
    state.ui.focusMode = focus.checked;
    saveState();
    renderPreserveFocus();
  };

  modeEl.appendChild(el("div",{class:"contextGroup"},[
    ...UIMODES.map(x=>{
      const b = el("button",{class:"modeBtn" + (mode===x.id ? " primary" : ""), text:x.label, onclick: ()=>setMode(x.id)});
      return b;
    }),
    el("label",{class:"chip", title:"Focus mode hides non-essential panels per mode."},[focus, el("span",{text:" Focus"})]),
  ]));

  // CONTEXT BAR
  ctxEl.innerHTML = "";
  // NAV CONTROLS + BREADCRUMBS (Sprint 19)
  const nav = state.ui.nav = state.ui.nav || { recent: [] };
  nav.history = Array.isArray(nav.history) ? nav.history : [];
  nav.index = (typeof nav.index === "number") ? nav.index : (nav.history.length ? nav.history.length - 1 : -1);

  const btnBack = el("button",{class:"navNavBtn", text:"← Back", disabled: !(nav.index>0), onclick: ()=>navBack()});
  const btnFwd  = el("button",{class:"navNavBtn", text:"Forward →", disabled: !(nav.index < nav.history.length-1), onclick: ()=>navForward()});

  const crumbs = el("div",{class:"navCrumbs"});
  const endIdx = Math.max(0, nav.index||0);
  const startIdx = Math.max(0, endIdx - 3);
  for (let i=startIdx; i<=endIdx; i++){
    const h = nav.history[i];
    if (!h) continue;
    const isActive = (i === nav.index);
    crumbs.appendChild(el("button",{class:"crumb"+(isActive?" active":""), text:(h.label || h.id), title:(h.sub||""), onclick: ()=>{ if (!isActive) navGoIndex(i); }}));
    if (i < endIdx) crumbs.appendChild(el("span",{class:"crumbSep", text:"›"}));
  }

  ctxEl.appendChild(el("div",{class:"contextGroup"},[
    btnBack, btnFwd,
    el("div",{class:"contextLabel", text:"You are here:"}),
    crumbs
  ]));


  // Shared quick stats
  const tick = Number(state?.sim?.clock?.tick||0);
  const coin = Number(state?.sim?.resources?.coin||0);
  const notes = Number(state?.sim?.resources?.notes||0);

  ctxEl.appendChild(el("div",{class:"contextGroup"},[
    el("div",{class:"contextPill", text:`Tick: ${tick}`}),
    el("div",{class:"contextPill", text:`Coin: ${coin}`}),
    el("div",{class:"contextPill", text:`Notes: ${notes}`}),
  ]));


  // Context pickers: active item / crafter / location (when relevant)
  const showCtx = (mode==="run" || mode==="trade" || mode==="debug");
  if (!showCtx){
    // Clear results panel when not in contextual modes
    const resEl = document.getElementById("navResults");
    if (resEl) resEl.innerHTML = "";
    return;
  }

  const entities = (state?.world?.entities||[]);
  const items = entities.filter(e=>e && e.typeId==="item");
  const chars = entities.filter(e=>e && e.typeId==="character");
  const locs  = entities.filter(e=>e && e.typeId==="location");

  // -------------------- Recents + Search (Sprint 17) --------------------
  state.ui.nav = state.ui.nav || { recent: [] };
  if (!Array.isArray(state.ui.nav.recent)) state.ui.nav.recent = [];
  if (typeof state.ui.navQuery !== "string") state.ui.navQuery = "";

  // Recents chips
  if (state.ui.nav.recent.length){
    const row = el("div",{class:"recentRow"});
    state.ui.nav.recent.slice(0,8).forEach(r=>{
      const b = el("button",{class:"small", text:r.label, title:`${r.sub||""}`, onclick: ()=>{
        if (r.kind==="entity") navGoEntity(r.id);
        else if (r.kind==="character") navGoCharacter(r.id);
        else if (r.kind==="rule") navGoRule(r.id);
        else if (r.kind==="pack") navGoPack(r.id);
      }});
      row.appendChild(b);
    });
    ctxEl.appendChild(el("div",{class:"contextGroup"},[
      el("div",{class:"contextLabel", text:"Recent"}),
      row
    ]));
  }

  // Search box
  const search = el("input",{class:"navSearch", type:"search", placeholder:"Search… (entities, chars, rules, packs)"});
  search.value = state.ui.navQuery || "";
  search.oninput = ()=>{
    state.ui.navQuery = search.value;
    // don't spam saves on keystrokes; just rerender header panel
    renderNavBars();
  };
  search.onkeydown = (ev)=>{
    if (ev.key === "Escape"){
      state.ui.navQuery = "";
      renderNavBars();
      ev.preventDefault();
    }
    if (ev.key === "Enter"){
      // If there is exactly one result, jump to it
      const res = navSearch(state.ui.navQuery);
      if (res.length === 1) res[0].go();
    }
  };

  ctxEl.appendChild(el("div",{class:"contextGroup"},[
    el("div",{class:"contextLabel", text:"Find"}),
    search
  ]));

  // -------------------- Active item (ties into Forge UI) --------------------
  if (items.length){
    const sel = el("select",{class:"contextSelect"});
    items.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(it=>{
      sel.appendChild(el("option",{value:it.id, text:it.name}));
    });

    const simui = state.sim.ui = state.sim.ui || {};
    const cur = (simui.forgeItemId && entityById(simui.forgeItemId)) ? simui.forgeItemId : items[0].id;
    simui.forgeItemId = cur;
    sel.value = cur;
    sel.onchange = ()=>{ simui.forgeItemId = sel.value; saveState(); renderPreserveFocus(); };

    ctxEl.appendChild(el("div",{class:"contextGroup"},[
      el("div",{class:"contextLabel", text:"Item"}),
      sel,
      el("button",{class:"small", text:"World", onclick: ()=>navGoEntity(simui.forgeItemId)}),
      el("button",{class:"small", text:"Explain", onclick: ()=>{
        state.sim.ui.selectedEntityId = simui.forgeItemId;
        saveState(); renderPreserveFocus();
      }})
    ]));
  }

  // Crafter + Location (Market UI state)
  const marketInstalled = PackManager.isInstalled("market_schema_v0") || (state.sim.installedPacks||[]).includes("market_schema_v0");
  if (marketInstalled){
    state.sim.ui = state.sim.ui || {};
    state.sim.ui.market = state.sim.ui.market || {};
    const market = state.sim.ui.market;

    if (chars.length){
      const ddC = el("select",{class:"contextSelect"});
      ddC.appendChild(el("option",{value:"", text:"(crafter)"}));
      chars.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(c=>{
        ddC.appendChild(el("option",{value:c.id, text:c.name}));
      });
      ddC.value = market.crafterId || "";
      ddC.onchange = ()=>{ market.crafterId = ddC.value; saveState(); renderPreserveFocus(); };

      ctxEl.appendChild(el("div",{class:"contextGroup"},[
        el("div",{class:"contextLabel", text:"Crafter"}),
        ddC,
        el("button",{class:"small", text:"World", onclick: ()=>{ if (market.crafterId) navGoEntity(market.crafterId); else alert("Pick a crafter first."); }})
      ]));
    }

    if (locs.length){
      const ddL = el("select",{class:"contextSelect"});
      ddL.appendChild(el("option",{value:"", text:"(location)"}));
      locs.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(l=>{
        ddL.appendChild(el("option",{value:l.id, text:l.name}));
      });
      ddL.value = market.locationId || "";
      ddL.onchange = ()=>{ market.locationId = ddL.value; saveState(); renderPreserveFocus(); };

      ctxEl.appendChild(el("div",{class:"contextGroup"},[
        el("div",{class:"contextLabel", text:"Location"}),
        ddL,
        el("button",{class:"small", text:"World", onclick: ()=>{ if (market.locationId) navGoEntity(market.locationId); else alert("Pick a location first."); }})
      ]));
    }
  }

  // Results panel
  const resEl = document.getElementById("navResults");
  if (!resEl) return;
  resEl.innerHTML = "";
  const q = (state.ui.navQuery||"").trim();
  if (!q) return;

  const results = navSearch(q).slice(0, 10);
  const panel = el("div",{class:"navPanel"});
  panel.appendChild(el("div",{class:"row"},[
    el("div",{text:`Results for “${q}”`}),
    el("button",{class:"small", text:"Clear", onclick: ()=>{ state.ui.navQuery=""; renderNavBars(); }})
  ]));
  if (!results.length){
    panel.appendChild(el("div",{class:"muted", text:"No matches."}));
  } else {
    results.forEach(r=>{
      const b = el("button",{class:"navResultBtn", onclick: r.go},[
        el("div",{text:r.label}),
        el("div",{class:"navSub", text:r.sub})
      ]);
      panel.appendChild(b);
    });
  }
  resEl.appendChild(panel);
}


$("#btnReset").onclick = () => {
  if (!confirm("Reset everything? This wipes local data.")) return;
  localStorage.removeItem(STORAGE_KEY);
  state = deep(DEFAULT_STATE);
  normalizeSeeds();
  saveState();
  renderPreserveFocus();
};
$("#btnExport").onclick = () => {
  const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "living-world-v2.json";
  a.click();
  URL.revokeObjectURL(a.href);
};

// Export to Markdown
$("#btnExportMD").onclick = () => {
  const lines = ["# World Export\n"];

  (state.index.entityTypes||[]).forEach(type => {
    const entities = (state.world.entities||[]).filter(e => e.typeId === type.id);
    if (!entities.length) return;

    lines.push(`\n## ${type.name}s\n`);
    entities.forEach(e => {
      lines.push(`\n### ${e.name}`);
      if (e.tagIds?.length) {
        lines.push(`**Tags**: ${(e.tagIds||[]).map(tagName).join(", ")}`);
      }

      const tmpl = (state.index.templates && state.index.templates[e.typeId]) ? state.index.templates[e.typeId] : [];
      (tmpl||[]).forEach(f => {
        const val = e.fields?.[f.key];
        if (val) lines.push(`\n**${f.label || f.key}**: ${val}`);
      });

      // Quant summary
      try{
        const q = computeQuantCached(e);
        if (q && (q.usefulness > 0 || q.netValue > 0 || q.prestige > 0)) {
          lines.push(`\n**Quant**: Usefulness ${Number(q.usefulness||0).toFixed(0)}, Net Value ${Number(q.netValue||0).toFixed(0)}, Prestige ${Number(q.prestige||0).toFixed(0)}`);
        }
      } catch {}
    });
  });

  const blob = new Blob([lines.join("\n")], {type:"text/markdown"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "world-export.md";
  a.click();
  URL.revokeObjectURL(a.href);
  toast("Markdown exported!");
};
$("#fileImport").addEventListener("change", async (ev) => {
  const f = ev.target.files?.[0];
  if (!f) return;
  const txt = await f.text();
  try {
    state = migrateState(JSON.parse(txt));
    normalizeSeeds();
    saveState();
    renderPreserveFocus();
  } catch {
    alert("Invalid JSON.");
  } finally {
    ev.target.value = "";
  }
});

/** -------------------- RENDER SWITCH -------------------- */
function render() {
  renderNavBars();
  $("#tabWorld").classList.toggle("primary", state.ui.tab==="world");
  $("#tabChars").classList.toggle("primary", state.ui.tab==="chars");
  $("#tabGen").classList.toggle("primary", state.ui.tab==="gen");
  $("#tabCreate").classList.toggle("primary", state.ui.tab==="create");
  $("#tabIntake").classList.toggle("primary", state.ui.tab==="intake");
  $("#tabSettings").classList.toggle("primary", state.ui.tab==="settings");
  $("#tabSim").classList.toggle("primary", state.ui.tab==="sim");
  $("#tabDocs").classList.toggle("primary", state.ui.tab==="docs");

  if (state.ui.tab === "world") renderWorld();
  if (state.ui.tab === "chars") renderChars();
  if (state.ui.tab === "gen") renderGen();
  if (state.ui.tab === "create") renderCreate();
  if (state.ui.tab === "intake") renderIntake();
  if (state.ui.tab === "settings") renderIndex();
  if (state.ui.tab === "sim") renderSim();
  if (state.ui.tab === "docs") renderDocs();
}


/** -------------------- DOCS -------------------- */
function renderDocs(){
  const left = $("#leftPane"), main = $("#mainPane"), right = $("#rightPane");
  left.innerHTML = main.innerHTML = right.innerHTML = "";

  const sections = [
    {id:"overview", title:"Overview", body:[
      "Living World Wheels is a single-file app with a persistent local state (localStorage).",
      "Core modules: Quant (numbers), Roller (weighted picks), Wheel (visual spin), SkillGen (skill defaults), migrateState (schema safety).",
      "Rule of thumb: when you add a new field to state, also add migration + defaults."
    ]},
    {id:"direction", title:"Product direction (core identity)", body:[
      "Core loop: Graph → Rules → Tick → Diff → Explain → Patch → Iterate.",
      "Core identity is the graph workbench; crafting/market/reputation live in packs.",
      "Every UI should answer: What changed? Why? How do I alter the system?"
    ]},
    {id:"modes", title:"Modes (primary UX)", body:[
      "Build: create entities + link them, guided checklist.",
      "Run: tick, observe diffs, spot runaway behavior.",
      "Trade: finalize/quote/sell, see rep/fame effects.",
      "Debug: events, inspector, patch tools, rule toggles.",
      "Meta: packs, unlocks, objectives, settings.",
      "Rule: in each mode show only the 2–3 panels that matter; everything else collapses behind Advanced."
    ]},
    {id:"architecture", title:"Architecture split (core vs packs)", body:[
      "Core (permanent): Entity store + schema index; Link system + GraphIndex; Tick engine + event log + diff; Rule engine + effect system; Pack manager; Navigation layer (modes/search/history/context); Debug tools.",
      "Packs (content/gameplay): Crafting, Market/Economy, Reputation/Fame, Ecology, Class/Skill, plus future factions/quests/war/religion.",
      "Avoid hardcoding gameplay logic in core; if it’s not navigation/engine/debug tooling, it belongs in a pack."
    ]},
    {id:"state", title:"State shape (high level)", body:[
      "state.index: definitions (entity types, tags, facet sets, templates, conflicts).",
      "state.world.entities: the library database (biomes, monsters, skills, etc).",
      "state.generator: step flow + locks + history + draft.",
      "state.characters: character sheets.",
      "state.quant: default quant profile + wheel toggle."
    ]},
    {id:"quant", title:"Quant + Facet sets", body:[
      "Facets live per-entity in entity.fields.__facets (0–10).",
      "Facet Sets live in Index (state.index.facetDefsByType[typeId]).",
      "Each facet can map to a canonical Quant channel (power/utility/reliability/scope/frequency/complexity/upkeep/access/rarity).",
      "Quant uses ONLY mapped facets; missing channels are ignored and weights are re-normalized."
    ]},
    {id:"roller", title:"How to add a new rollable thing", body:[
      "Step 1: Gather options as {id,label,tagIds,baseWeight,refId?}.",
      "Step 2: Build contextTagIds (usually from locks, selected entity tags, or character tags).",
      "Step 3: Call Roller.pickWeighted(...) or Roller.softRollDetailed(...).",
      "Step 4 (optional): use wheelModalPick(...) to spin visually."
    ]},
    {id:"intake", title:"AI Intake (prompt → paste JSON → commit)", body:[
  "Use the Intake tab to generate a tailored prompt for any external AI, then paste JSON output back into the app.",
  "Prompt builder controls: entity type, count (generateCount), detail level (richness), and which world context to include (tags / facet set / templates / quant profiles).",
  "Supported input shapes: either {tagsToCreate:[...], entities:[...]} or an array of entity objects.",
  "Commit modes: Create new, Update existing (merge/replace by typeId+name), or Draft only (stash without mutating world).",
  "Validation: facets are clamped to 0..10; unknown tags/types produce warnings in Preview."
]},
{id:"migrations", title:"Schema changes (anti-freeze checklist)", body:[
      "1) Bump STATE_SCHEMA_VERSION.",
      "2) In migrateState(): create missing keys, add defaults, clamp unexpected values.",
      "3) Ensure old localStorage keys are still readable (v2/v3).",
      "4) Add a safe fallback so a bad state never hard-freezes the UI."
    ]},
    {id:"patterns", title:"Spec → Code translation recipes", body:[
      "“Add a new data field” → DEFAULT_STATE + migrateState + UI editor + export/import stays automatic.",
      "“Add a new entity type” → index.entityTypes + index.templates + (optional) facet set + (optional) generator step.",
      "“Add a new computed number” → module function + render panel + keep it derivable (no duplicate source of truth).",
      "“Make something rollable” → wrap as options + call Roller + persist only what you need (locks/history)."
    ]},
    {id:"modules", title:"Module Index (pre-sprints)", body:[
      'Purpose: keep future game features modular and debuggable.',
      'Core rule: ONLY WorldMutator writes to state; everything else emits events + returns plans.',
      'Every mutation MUST emit an event with ruleId + target refs + delta/before/after.',
      'Planned modules: EventBus, RefResolver, GraphIndex, SimClock, DiffTracker, MatcherLib, RuleEngine, EffectApplier, WorldMutator, RunawayDetector, Inspector, PackManager, Objectives, Unlocks, Emergence, Replay.',
      'Workflow per change: add defaults → migrateState → module code → UI hook → smoke test.'
    ]}
  ];

  // Left nav
  const nav = el("div",{class:"card"},[
    el("div",{style:"font-weight:700; margin-bottom:8px;", text:"Docs"}),
    el("div",{class:"muted", text:"Cheatsheets for adding features without breaking the app."}),
    el("div",{style:"margin-top:10px; display:flex; flex-direction:column; gap:6px;"}, sections.map(s=>{
      return el("button",{class:"ghost small", text:s.title, onclick:()=>{
        const elTarget = document.getElementById("docs-"+s.id);
        if (elTarget) elTarget.scrollIntoView({behavior:"smooth", block:"start"});
      }});
    }))
  ]);
  left.appendChild(nav);

  const top = el("div",{class:"card"},[
    el("div",{style:"font-weight:800; font-size:18px;", text:"Developer Docs"}),
    el("div",{class:"muted", style:"margin-top:6px;", text:`App: ${APP_VERSION} • Schema: ${STATE_SCHEMA_VERSION}`}),
    el("div",{class:"muted", style:"margin-top:6px;", text:"Tip: When you ask me for code changes, paste the acceptance tests you care about. One step per version."}),
  ]);
  main.appendChild(top);

  sections.forEach(s=>{
    main.appendChild(el("div",{class:"card", id:"docs-"+s.id},[
      el("div",{style:"font-weight:800; margin-bottom:8px;", text:s.title}),
      ...s.body.map(t=>el("div",{style:"margin:6px 0;", text:"• "+t}))
    ]));
  });

  right.appendChild(el("div",{class:"card"},[
    el("div",{style:"font-weight:800; margin-bottom:8px;", text:"Quick snippet: adding a roll button"}),
    el("pre",{style:"white-space:pre-wrap; font-size:12px; background:#fafafa; border:1px solid #eee; padding:10px; border-radius:12px;"},[
`// options: [{id,label,tagIds,baseWeight,refId}]
const ctx = contextTagIdsFromLocks(state.generator);
const picks = Roller.softRollDetailed(options, 3, ctx, state.index.tagConflicts, (id)=>entityById(id));
`
    ])
  ]));
}


/** -------------------- SIM TAB -------------------- */
function renderSim(){
  const left = $("#leftPane"), main = $("#mainPane"), right = $("#rightPane");
  left.innerHTML = main.innerHTML = right.innerHTML = "";

  state.sim.ui = state.sim.ui || deep(DEFAULT_SIM.ui);
  state.sim.ui.eventFilter = state.sim.ui.eventFilter || deep(DEFAULT_SIM.ui.eventFilter);
  const ui = state.sim.ui;

  // -------------------- NAV: mode-driven layout (Sprint 16) --------------------
  const mode = getMode(); // build | run | trade | debug | meta
  const focusMode = !!state.ui.focusMode;

  const isRun = (mode==="run");
  const isTrade = (mode==="trade");
  const isDebug = (mode==="debug");
  const isMeta = (mode==="meta");


  const candidates = SimClock.getCandidates();
  const tick = state.sim.clock.tick || 0;


  // LEFT
  // TS: Focus mode keeps the left pane minimal so the app feels like a guided loop.
  // You can always jump to "Meta" to manage packs/rules/unlocks.
  if (isMeta){
    left.appendChild(renderPackManagerCard());
    left.appendChild(renderRuleManagerCard());
  } else if (isDebug){
    if (ui.showCandidates && !focusMode){
      left.appendChild(el("div",{class:"card"},[
        el("div",{class:"row"},[
          el("div",{text:"Candidates"}),
          el("div",{class:"muted", text:`${candidates.length} entities`})
        ]),
        ...candidates.slice(0, 30).map(e=>{
          const btn = el("button",{class:"small", text:"Explain", onclick: ()=>{
            ui.selectedEntityId = e.id;
            saveState(); renderPreserveFocus();
          }});
          return el("div",{class:"item"},[
            el("div",{text:e.name}),
            el("div",{class:"muted", text:`${e.typeId}`}),
            btn
          ]);
        })
      ]));
    }
    left.appendChild(renderRuleManagerCard());
    left.appendChild(el("div",{class:"card"},[
      el("div",{class:"row"},[
        el("div",{text:"Graph"}),
        el("div",{class:"muted", text:"Most connected entities"})
      ]),
      ...GraphIndex.topDegree(10).map(x=>el("div",{class:"item"},[
        el("div",{text:x.label}),
        el("div",{class:"mono muted", text:String(x.deg)}),
        el("button",{class:"small", text:"Explain", onclick: ()=>{
          ui.selectedEntityId = x.id;
          saveState(); renderPreserveFocus();
        }})
      ]))
    ]));
  } else {
    // Run/Trade: keep it calm.
    if (!focusMode){
      if (ui.showCandidates){
        left.appendChild(el("div",{class:"card"},[
          el("div",{class:"row"},[
            el("div",{text:"Candidates"}),
            el("div",{class:"muted", text:`${candidates.length} entities`})
          ]),
          ...candidates.slice(0, 12).map(e=>{
            return el("div",{class:"item"},[
              el("div",{text:e.name}),
              el("div",{class:"muted", text:`${e.typeId}`}),
              el("button",{class:"small", text:"Explain", onclick: ()=>{
                ui.selectedEntityId = e.id;
                saveState(); renderPreserveFocus();
              }})
            ]);
          })
        ]));
      }
      left.appendChild(el("div",{class:"card"},[
        el("div",{class:"row"},[
          el("div",{text:"Graph"}),
          el("div",{class:"muted", text:"Quick anchors"})
        ]),
        ...GraphIndex.topDegree(6).map(x=>el("div",{class:"item"},[
          el("div",{text:x.label}),
          el("div",{class:"mono muted", text:String(x.deg)}),
          el("button",{class:"small", text:"Explain", onclick: ()=>{
            ui.selectedEntityId = x.id;
            saveState(); renderPreserveFocus();
          }})
        ]))
      ]));
    } else {
      left.appendChild(el("div",{class:"card"},[
        el("div",{class:"row"},[
          el("div",{text:"Shortcuts"}),
          el("div",{class:"muted", text:"Keep focus; jump when needed"})
        ]),
        el("button",{class:"small", text:"Go to Meta (packs/rules)", onclick: ()=>setMode("meta")}),
        el("button",{class:"small", text:"Go to Debug (events)", onclick: ()=>setMode("debug")}),
      ]));
    }
  }


  // MAIN
  const btnTick = el("button",{class:"primary", text:"Tick once", onclick: ()=>{
    SimClock.tickOnce();
    saveState();
    renderPreserveFocus();
  }});

  const auto = el("input",{type:"checkbox"});
  auto.checked = !!state.sim.settings.autoTick;
  auto.onchange = ()=>{
    state.sim.settings.autoTick = auto.checked;
    saveState(); renderPreserveFocus();
  };

  const pinnedOnly = el("input",{type:"checkbox"});
  pinnedOnly.checked = !!state.sim.settings.pinnedOnly;
  pinnedOnly.onchange = ()=>{
    state.sim.settings.pinnedOnly = pinnedOnly.checked;
    saveState(); renderPreserveFocus();
  };

  const stopOnRunaway = el("input",{type:"checkbox"});
  stopOnRunaway.checked = !!state.sim.settings.stopOnRunaway;
  stopOnRunaway.onchange = ()=>{
    state.sim.settings.stopOnRunaway = stopOnRunaway.checked;
    saveState(); renderPreserveFocus();
  };

  const emergenceOn = el("input",{type:"checkbox"});
  emergenceOn.checked = !!state.sim.settings.emergenceEnabled;
  emergenceOn.onchange = ()=>{
    state.sim.settings.emergenceEnabled = emergenceOn.checked;
    saveState(); renderPreserveFocus();
  };

  const tickMs = el("input",{type:"number", min:"150", step:"50", value:String(state.sim.settings.tickMs||1500)});
  tickMs.onchange = ()=>{
    state.sim.settings.tickMs = Math.max(150, Number(tickMs.value||1500));
    saveState(); renderPreserveFocus();
  };

  const candLimit = el("input",{type:"number", min:"1", step:"1", value:String(state.sim.settings.candidateLimit||25)});
  candLimit.onchange = ()=>{
    state.sim.settings.candidateLimit = Math.max(1, Math.min(500, Number(candLimit.value||25)));
    saveState(); renderPreserveFocus();
  };

  const showCand = el("input",{type:"checkbox"});
  showCand.checked = !!ui.showCandidates;
  showCand.onchange = ()=>{
    ui.showCandidates = showCand.checked;
    saveState(); renderPreserveFocus();
  };

  // Mode header card
  if (isRun || isDebug || (!focusMode && !isMeta)) {
    main.appendChild(el("div",{class:"card"},[
      el("div",{class:"row"},[
        el("div",{text: mode==="debug" ? "Debug" : "Simulation"}),
        el("div",{class:"muted", text: isDebug ? "Observe → Explain → Patch" : "Link → Tick → Observe"})
      ]),
      el("div",{class:"row"},[
        btnTick,
        el("label",{class:"chip"},[auto, el("span",{text:" Auto"})]),
        el("label",{class:"chip"},[pinnedOnly, el("span",{text:" Pinned-only"})]),
        el("label",{class:"chip"},[stopOnRunaway, el("span",{text:" Stop on runaway"})]),
        el("label",{class:"chip"},[emergenceOn, el("span",{text:" Emergence"})]),
        ...(isDebug && !focusMode ? [el("label",{class:"chip"},[showCand, el("span",{text:" Show candidates"})])] : []),
      ]),
      el("div",{class:"row"},[
        el("label",{class:"chip"},[el("span",{text:"Tick ms"}), tickMs]),
        el("label",{class:"chip"},[el("span",{text:"Candidate limit"}), candLimit]),
      ]),
      el("div",{class:"hr"}),
      el("div",{class:"row"},[
        el("div",{class:"pill", text:`Tick: ${tick}`}),
        el("div",{class:"pill", text:`Coin: ${Number(state.sim.resources.coin||0)}`}),
        el("div",{class:"pill", text:`Notes: ${Number(state.sim.resources.notes||0)}`}),
        el("div",{class:"pill", text:`Spawns: ${Number(state.sim.lastEmergence?.spawns?.length||0)}`}),
      ]),
    ]));
  } else {
    // Trade / Meta: keep it calm; offer escape hatches.
    const label = isTrade ? "Trade" : "Meta";
    const hint = isTrade ? "Finalize → Quote → Sell (with rep/fame)" : "Packs → Unlocks → Objectives";
    main.appendChild(el("div",{class:"card"},[
      el("div",{class:"row"},[
        el("div",{text: label}),
        el("div",{class:"muted", text: hint})
      ]),
      el("div",{class:"row"},[
        el("button",{class:"small", text:"Go to Run", onclick: ()=>setMode("run")}),
        el("button",{class:"small", text:"Go to Debug", onclick: ()=>setMode("debug")}),
        el("button",{class:"small", text:"Tick once", onclick: ()=>{
          SimClock.tickOnce();
          saveState(); renderPreserveFocus();
        }})
      ])
    ]));
  }

  // Last diff (most useful in Run/Debug)
  const diff = state.sim.lastDiff;
  if (diff && (isRun || isDebug || (!focusMode && !isMeta))) {
    const diffCard = el("div",{class:"card"});
    diffCard.appendChild(el("div",{class:"row"},[
      el("div",{text:"Last diff"}),
      el("div",{class:"muted", text: `fired ${diff.fired}, links +${diff.linksAdded}`})
    ]));
    if (diff?.deltas?.length) {
      diff.deltas
        .slice()
        .sort((a,b)=>Math.abs(b.delta)-Math.abs(a.delta))
        .slice(0, 10)
        .forEach(d=>{
          diffCard.appendChild(el("div",{class:"item"},[
            el("div",{text:d.label}),
            el("div",{class:"mono", text:(d.delta>=0?"+":"") + d.delta})
          ]));
        });
    }
    main.appendChild(diffCard);
  } else if (!diff) {
    // No tick yet; keep quiet in Trade/Meta.
    if (isRun || isDebug) main.appendChild(el("div",{class:"card"},[el("div",{class:"muted", text:"No tick yet."})]));
  }



  const diffCard = el("div",{class:"card"});
  diffCard.appendChild(el("div",{class:"row"},[
    el("div",{text:"Last diff"}),
    el("div",{class:"muted", text: diff ? `fired ${diff.fired}, links +${diff.linksAdded}` : "No tick yet."})
  ]));
  if (diff?.deltas?.length) {
    diff.deltas
      .slice()
      .sort((a,b)=>Math.abs(b.delta)-Math.abs(a.delta))
      .slice(0, 10)
      .forEach(d=>{
        diffCard.appendChild(el("div",{class:"item"},[
          el("div",{text:d.label}),
          el("div",{class:"mono", text:(d.delta>=0?"+":"") + d.delta})
        ]));
      });
  }
  main.appendChild(diffCard);


  // Mode-specific modules
  if (isRun || isTrade){
    main.appendChild(renderForgeCard());
  }

  if (isDebug){
    main.appendChild(renderPatchToolsCard());
    if (!focusMode) main.appendChild(renderEmergenceCard());
  }

  if (isMeta){
    main.appendChild(renderObjectivesCard());
    main.appendChild(renderUnlocksCard());
  } else {
    // Optional progress surfacing in Run/Trade when not focusing
    if (!focusMode){
      main.appendChild(renderObjectivesCard());
      main.appendChild(renderUnlocksCard());
    }
  }

  if (isRun){
    main.appendChild(renderEmergenceCard());
  }


  // RIGHT
  const lastRunaway = latestEventOfType("RUNAWAY_DETECTED");
  if ((isRun || isDebug) && lastRunaway && lastRunaway.tick === tick){
    right.appendChild(renderRunawayBanner(lastRunaway));
  }

  const showEvents = (!isMeta) || (!focusMode);
  if (showEvents){
    right.appendChild(renderEventFilterCard());

    const evCard = el("div",{class:"card"});
    evCard.appendChild(el("div",{class:"row"},[
      el("div",{text:"Events"}),
      el("div",{class:"muted", text:"Newest first"})
    ]));

    const events = filteredEvents().slice(-80).reverse();
    if (!events.length) evCard.appendChild(el("div",{class:"muted", text:"No events match filters."}));
    else {
      events.forEach(ev=>{
        evCard.appendChild(el("div",{class:"item"},[
          el("div",{text:`${ev.type}`}),
          el("div",{class:"muted", text: formatEvent(ev) })
        ]));
      });
    }
    right.appendChild(evCard);
  } else {
    right.appendChild(el("div",{class:"card"},[
      el("div",{class:"row"},[
        el("div",{text:"Inspector"}),
        el("div",{class:"muted", text:"(Events hidden in Focus mode)"})
      ]),
      el("div",{class:"muted", text:"Switch to Debug to browse events + patch causes."})
    ]));
  }

  right.appendChild(renderInspectorPanel());
}


function latestEventOfType(type){
  const list = state.sim.events || [];
  for (let i=list.length-1; i>=0; i--){
    if (list[i].type === type) return list[i];
  }
  return null;
}

function getRuleFireCountsForTick(tick){
  const fires = EventBus.query({types:["RULE_FIRED"], tick, limit: 2000});
  const map = {};
  for (const ev of fires){
    const rid = ev.ruleId || "(none)";
    map[rid] = (map[rid]||0) + 1;
  }
  return map;
}


function renderPackManagerCard(){
  const ui = state.sim.ui;
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Packs"}),
    el("div",{class:"muted", text:"Install & toggle rule bundles"})
  ]));

  // Built-in pack quick install
  const btnBuiltIn = el("button",{class:"small", text: PackManager.isInstalled(PACK_INTERACTION_BASICS.packId) ? "Built-in installed" : "Install built-in: Interaction Basics",
    onclick: ()=>{
      const r = PackManager.install(PACK_INTERACTION_BASICS, {replaceRules:false});
      ui.packInstallError = r.ok ? "" : (r.errors||[]).join(" • ");
      saveState(); renderPreserveFocus();
    }
  });
  btnBuiltIn.disabled = PackManager.isInstalled(PACK_INTERACTION_BASICS.packId);
  card.appendChild(btnBuiltIn);


  // Built-in item packs (Layer 1)
  const btnItemSchema = el("button",{class:"small", text: PackManager.isInstalled(PACK_ITEM_SCHEMA_V0.packId) ? "Built-in installed: Item Schema" : "Install built-in: Item Schema (Layer 1)",
    onclick: ()=>{
      const r = PackManager.install(PACK_ITEM_SCHEMA_V0, {replaceRules:false});
      ui.packInstallError = r.ok ? "" : (r.errors||[]).join(" • ");
      saveState(); renderPreserveFocus();
    }
  });
  btnItemSchema.disabled = PackManager.isInstalled(PACK_ITEM_SCHEMA_V0.packId);
  card.appendChild(btnItemSchema);

  const btnItemProd = el("button",{class:"small", text: PackManager.isInstalled(PACK_ITEM_PRODUCTION_V0.packId) ? "Built-in installed: Item Production" : "Install built-in: Item Production (Layer 1 rules)",
    onclick: ()=>{
      const r = PackManager.install(PACK_ITEM_PRODUCTION_V0, {replaceRules:false});
      ui.packInstallError = r.ok ? "" : (r.errors||[]).join(" • ");
      saveState(); renderPreserveFocus();
    }
  });
  btnItemProd.disabled = PackManager.isInstalled(PACK_ITEM_PRODUCTION_V0.packId);
  card.appendChild(btnItemProd);

  const btnAdvMat = el("button",{class:"small", text: PackManager.isInstalled(PACK_ITEM_ADV_MATERIALS_V0.packId) ? "Built-in installed: Advanced Affinities" : "Install built-in: Advanced Material Affinities",
    onclick: ()=>{
      const r = PackManager.install(PACK_ITEM_ADV_MATERIALS_V0, {replaceRules:false});
      ui.packInstallError = r.ok ? "" : (r.errors||[]).join(" • ");
      saveState(); renderPreserveFocus();
    }
  });
  btnAdvMat.disabled = PackManager.isInstalled(PACK_ITEM_ADV_MATERIALS_V0.packId);
  card.appendChild(btnAdvMat);


  const btnMarketSchema = el("button",{class:"small", text: PackManager.isInstalled(PACK_MARKET_SCHEMA_V0.packId) ? "Built-in installed: Market Schema" : "Install built-in: Market Schema (Economy)",
    onclick: ()=>{
      const r = PackManager.install(PACK_MARKET_SCHEMA_V0, {replaceRules:false});
      ui.packInstallError = r.ok ? "" : (r.errors||[]).join(" • ");
      saveState(); renderPreserveFocus();
    }
  });
  btnMarketSchema.disabled = PackManager.isInstalled(PACK_MARKET_SCHEMA_V0.packId);
  card.appendChild(btnMarketSchema);



  // Installed list
  const packs = PackManager.listPacks();
  if (!packs.length){
    card.appendChild(el("div",{class:"muted", text:"No packs installed yet."}));
  } else {
    packs.forEach(p=>{
      const chk = el("input",{type:"checkbox"});
      chk.checked = (p.enabled !== false);
      chk.onchange = ()=>{
        PackManager.enable(p.packId, chk.checked);
        saveState(); renderPreserveFocus();
      };
      card.appendChild(el("div",{class:"item"},[
        el("div",{text: p.name || p.packId}),
        el("div",{class:"muted", text:`${p.packId}${p.version?(" · v"+p.version):""}`}),
        el("label",{class:"chip"},[chk, el("span",{text:" enabled"})]),
        el("button",{class:"small", text:"Filter rules", onclick: ()=>{
          ui.packFilter = p.packId;
          saveState(); renderPreserveFocus();
        }}),
        el("button",{class:"small", text:"Clear filter", onclick: ()=>{
          ui.packFilter = "";
          saveState(); renderPreserveFocus();
        }})
      ]));
    });
  }

  card.appendChild(el("div",{class:"hr"}));
  card.appendChild(el("div",{class:"muted", text:"Install pack JSON (PackV0)"}));

  const ta = el("textarea",{placeholder:'{ "packId":"my_pack", "name":"My Pack", "version":"0.0.1", "rulesToAdd":[...]}', value: ui.packInstallText||""});
  ta.oninput = ()=>{ ui.packInstallText = ta.value; };

  const btnInstall = el("button",{class:"small primary", text:"Validate & Install", onclick: ()=>{
    ui.packInstallError = "";
    let pack = null;
    try { pack = JSON.parse(ui.packInstallText||""); }
    catch(e){ ui.packInstallError = "Invalid JSON: " + (e?.message||String(e)); saveState(); renderPreserveFocus(); return; }
    const r = PackManager.install(pack, {replaceRules:false});
    ui.packInstallError = r.ok ? "" : (r.errors||[]).join(" • ");
    saveState(); renderPreserveFocus();
  }});

  card.appendChild(ta);
  card.appendChild(btnInstall);

  if (ui.packInstallError){
    card.appendChild(el("div",{class:"muted", style:"color:#b00"},[ el("div",{text: ui.packInstallError}) ]));
  }

  return card;
}

function renderRuleManagerCard(){
  const ui = state.sim.ui;
  const card = el("div",{class:"card"});
  const tick = state.sim.clock.tick || 0;
  const fireCounts = getRuleFireCountsForTick(tick);

  const filter = el("input",{type:"text", value: ui.ruleFilter||"", placeholder:"Filter rules..."});
  filter.oninput = ()=>{
    ui.ruleFilter = filter.value;
    saveState(); renderPreserveFocus();
  };

  const rules = (state.sim.rules||[]).slice();
  const packFilter = (ui.packFilter||"").trim();
  const rules2 = packFilter ? rules.filter(r=>r.packId===packFilter) : rules;

  const q = (ui.ruleFilter||"").trim().toLowerCase();
  const filtered = q ? rules2.filter(r=>{
    return (r.id||"").toLowerCase().includes(q) || (r.name||"").toLowerCase().includes(q);
  }) : rules2;

  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Rules"}),
    el("div",{class:"muted", text:`${filtered.length}/${rules2.length}${packFilter?(' (pack '+packFilter+')'):''}`})
  ]));
  card.appendChild(filter);

  filtered.slice(0, 40).forEach(rule=>{
    const chk = el("input",{type:"checkbox"});
    chk.checked = (rule.enabled !== false);
    chk.onchange = ()=>{
      rule.enabled = chk.checked;
      saveState(); renderPreserveFocus();
    };

    const fired = fireCounts[rule.id] || 0;

    const btnFocus = el("button",{class:"small", text:"Log", onclick: ()=>{
      state.sim.ui.eventFilter.ruleId = rule.id;
      saveState(); renderPreserveFocus();
    }});

    const inpMax = el("input",{type:"number", min:"0", step:"1", value: String((rule.limits||{}).maxPerTick ?? ""), style:"width:90px"});
    inpMax.onchange = ()=>{
      rule.limits = rule.limits || {};
      const v = String(inpMax.value||"").trim();
      rule.limits.maxPerTick = v==="" ? undefined : Math.max(0, Number(v||0));
      saveState(); renderPreserveFocus();
    };

    const inpCd = el("input",{type:"number", min:"0", step:"1", value: String((rule.limits||{}).cooldownTicks ?? ""), style:"width:90px"});
    inpCd.onchange = ()=>{
      rule.limits = rule.limits || {};
      const v = String(inpCd.value||"").trim();
      rule.limits.cooldownTicks = v==="" ? undefined : Math.max(0, Number(v||0));
      saveState(); renderPreserveFocus();
    };

    card.appendChild(el("div",{class:"item"},[
      el("div",{text: rule.name || rule.id}),
      el("div",{class:"muted", text: rule.id}),
      el("div",{class:"badge", text: rule.packId ? ('pack: '+rule.packId) : 'core'}),
      el("div",{class:"mono muted", text: fired ? `fired ${fired}` : ""}),
      el("div",{class:"row"},[
        el("label",{class:"muted", style:"width:80px"},[el("span",{text:"max/tick"})]),
        inpMax,
        el("label",{class:"muted", style:"width:80px"},[el("span",{text:"cooldown"})]),
        inpCd
      ]),
      el("label",{class:"chip"},[chk, el("span",{text:" enabled"})]),
      btnFocus
    ]));
  });

  return card;
}

function renderEventFilterCard(){
  const ui = state.sim.ui;
  const f = ui.eventFilter;

  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Event filters"}),
    el("button",{class:"small", text:"Clear", onclick: ()=>{
      ui.eventFilter = deep(DEFAULT_SIM.ui.eventFilter);
      saveState(); renderPreserveFocus();
    }})
  ]));

  const type = el("input",{type:"text", value:f.type||"", placeholder:"Type (e.g. RULE_FIRED)"});
  type.oninput = ()=>{ f.type = type.value; saveState(); renderPreserveFocus(); };

  const entity = el("input",{type:"text", value:f.entity||"", placeholder:"Entity id or exact name"});
  entity.oninput = ()=>{ f.entity = entity.value; saveState(); renderPreserveFocus(); };

  const ruleId = el("input",{type:"text", value:f.ruleId||"", placeholder:"Rule id"});
  ruleId.oninput = ()=>{ f.ruleId = ruleId.value; saveState(); renderPreserveFocus(); };

  const q = el("input",{type:"text", value:f.q||"", placeholder:"Search"});
  q.oninput = ()=>{ f.q = q.value; saveState(); renderPreserveFocus(); };

  card.appendChild(el("div",{class:"col"},[ type, entity, ruleId, q ]));
  return card;
}

function filteredEvents(){
  const ui = state.sim.ui;
  const f = ui.eventFilter || {};
  const types = f.type ? [f.type.trim()] : null;

  let entityId = null;
  const entQ = (f.entity||"").trim();
  if (entQ){
    const byId = entityById(entQ);
    if (byId) entityId = byId.id;
    else {
      const match = (state.world.entities||[]).find(e=>e.name===entQ);
      if (match) entityId = match.id;
    }
  }

  const ruleId = (f.ruleId||"").trim() || null;
  let list = EventBus.query({types, entityId, ruleId, limit: 2000});

  const q = (f.q||"").trim().toLowerCase();
  if (q){
    list = list.filter(ev=>{
      const s = (formatEvent(ev) || "").toLowerCase() + " " + JSON.stringify(ev).toLowerCase();
      return s.includes(q);
    });
  }
  return list;
}

function renderRunawayBanner(ev){
  const suspects = ev.suspects || {};
  const wrap = el("div",{class:"card"});
  wrap.appendChild(el("div",{class:"row"},[
    el("div",{text:"Runaway detected"}),
    el("div",{class:"muted", text:`fired ${ev.fired||0} · links +${ev.linksAdded||0} · maxΔ ${ev.maxAbsDelta||0}`}),
  ]));

  if (suspects.topRulesByFires?.length){
    wrap.appendChild(el("div",{class:"muted", text:"Top rules by fires"}));
    suspects.topRulesByFires.forEach(x=>{
      wrap.appendChild(el("div",{class:"item"},[
        el("div",{text:`${x.ruleId}`}),
        el("div",{class:"mono muted", text:`${x.n}`}),
        el("button",{class:"small", text:"Filter", onclick: ()=>{
          state.sim.ui.eventFilter.ruleId = x.ruleId;
          saveState(); renderPreserveFocus();
        }})
      ]));
    });
  }
  if (suspects.topDegree?.length){
    wrap.appendChild(el("div",{class:"muted", text:"Most connected entities"}));
    suspects.topDegree.forEach(x=>{
      wrap.appendChild(el("div",{class:"item"},[
        el("div",{text:x.label}),
        el("div",{class:"mono muted", text:`deg ${x.deg}`}),
        el("button",{class:"small", text:"Explain", onclick: ()=>{
          state.sim.ui.selectedEntityId = x.id;
          saveState(); renderPreserveFocus();
        }})
      ]));
    });
  }

  return wrap;
}



/** -------------------- Crafting UI Flow (Sprint 13) --------------------
 * Streamlining layer for the Forge card:
 * - computes a 'next step' to reduce cognitive load
 * - offers quick actions (create+attach) while keeping everything debuggable
 *
 * TS-READY NOTES:
 * - Treat stageId as a string-literal union in TS:
 *   type ForgeStage = "needs_components"|"forge"|"needs_attribution"|"finalize"|"quote"|"sell"|"done";
 */
const CraftingUIFlow = (function(){
  function hasOutLink(from, kindId){
    const k = RefResolver.linkType(kindId) || kindId;
    return !!(from && (from.links||[]).some(l=>l && l.kindId===k));
  }
  function outLinkTargetId(from, kindId){
    const k = RefResolver.linkType(kindId) || kindId;
    const l = (from?.links||[]).find(x=>x && x.kindId===k);
    return l ? l.toId : null;
  }
  function hasTagName(e, name){
    const tid = RefResolver.tag(name);
    return tid ? (e?.tagIds||[]).includes(tid) : false;
  }

  /** Compute the next step for the streamlined flow. */
  function compute(item, analysis){
    // TS: returns {stageId:ForgeStage, label:string, hint:string}
    if (!item || item.typeId!=="item"){
      return {stageId:"needs_components", label:"Select an item", hint:"Create or pick an Item to craft."};
    }

    const isFinal = hasTagName(item,"item:finalized");
    const isSold = hasTagName(item,"item:sold");

    const hasCrafter = hasOutLink(item, "crafted_by");
    const hasLocation = hasOutLink(item, "crafted_at");

    // 1) composition essentials
    const missingEssentials = [];
    if (!(analysis?.components?.materials||[]).length) missingEssentials.push("material");
    if (!(analysis?.components?.cores||[]).length) missingEssentials.push("core");

    if (missingEssentials.length){
      return {
        stageId:"needs_components",
        label:`Attach ${missingEssentials.join(" + ")}`,
        hint:"Production requires material + core. Use quick actions to create & attach."
      };
    }

    // 2) if it's sell-intended and attribution missing, guide that before finalization
    if (!isFinal && (!hasCrafter || !hasLocation)){
      return {
        stageId:"needs_attribution",
        label:"Set crafter + location",
        hint:"So finalization and selling can affect local reputation and global fame."
      };
    }

    // 3) finalize
    if (!isFinal){
      return {stageId:"finalize", label:"Finalize the item", hint:"Locks a snapshot and makes it sellable."};
    }

    // 4) quote then sell
    if (isFinal && !isSold){
      return {stageId:"sell", label:"Quote & sell", hint:"Generate a price quote and sell to gain coin + reputation effects."};
    }

    return {stageId:"done", label:"Done", hint:"This item has been sold. Craft another or iterate a new design."};
  }

  return { compute, outLinkTargetId, hasTagName };
})();

/** -------------------- FORGE (Layer 1) --------------------
 * Minimal UI for the item-production loop:
 * - select an Item
 * - see readiness + risk
 * - Forge (updates facets/tags + emits events)
 *
 * TS-READY NOTES:
 * - Keep this UI thin; logic belongs in Crafting.*.
 */
function renderForgeCard(){
  const ui = state.sim.ui = state.sim.ui || {};
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Forge"}),
    el("div",{class:"muted", text:"Item crafting (production loop, Layer 1)"})
  ]));

  // Make sure schema pack is present; it adds types/link kinds/tags/facets.
  const schemaInstalled = PackManager.isInstalled("item_schema_v0") || (state.sim.installedPacks||[]).includes("item_schema_v0");
  if (!schemaInstalled){
    card.appendChild(el("div",{class:"muted", text:"Install the Item Schema pack to get Item/Material/Core/Rune types + link kinds."}));
    card.appendChild(el("button",{class:"small primary", text:"Install Item Schema (Layer 1)", onclick: ()=>{
      const r = PackManager.install(PACK_ITEM_SCHEMA_V0, {replaceRules:false});
      ui.packInstallError = r.ok ? "" : (r.errors||[]).join(" • ");
      saveState(); renderPreserveFocus();
    }}));
    return card;
  }

  // Items list
  const items = (state.world.entities||[]).filter(e=>e.typeId==="item");
  if (!items.length){
    card.appendChild(el("div",{class:"muted", text:"No items yet. Create an entity of type 'Item' in the World tab, then link Material/Core/Rune components."}));
    card.appendChild(el("div",{class:"muted", text:"Quick start: create a Material + Core + Item, then add links: item→material (Uses material) and item→core (Has core)."}));
    return card;
  }

  // Select
  const selId = ui.forgeItemId && entityById(ui.forgeItemId) ? ui.forgeItemId : items[0].id;
  ui.forgeItemId = selId;
  const sel = entityById(selId);

  const dd = el("select",{});
  items.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(it=>{
    dd.appendChild(el("option",{value: it.id, text: it.name + " ("+it.id.slice(0,6)+")"}));
  });
  dd.value = selId;
  dd.onchange = ()=>{ ui.forgeItemId = dd.value; saveState(); renderPreserveFocus(); };

  const btnPin = el("button",{class:"small", text: sel?.pinned ? "Unpin" : "Pin", onclick: ()=>{
    if (!sel) return;
    sel.pinned = !sel.pinned;
    sel.updatedAt = nowISO();
    saveState(); renderPreserveFocus();
  }});

  const btnExplain = el("button",{class:"small", text:"Explain", onclick: ()=>{
    ui.selectedEntityId = selId;
    saveState(); renderPreserveFocus();
  }});

  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Item"}),
    dd,
    btnPin,
    btnExplain
  ]));

  // Analysis
  const analysis = Crafting.analyzeItem(sel);
  const riskChip = el("div",{class:"pill", text:`Risk: ${analysis.risk}`});
  const readyChip = el("div",{class:"pill", text: analysis.ready ? "Ready" : "Not ready"});
  card.appendChild(el("div",{class:"row"},[
    readyChip,
    riskChip,
    el("div",{class:"pill", text:`Tier ${analysis.facets.tier} · Q ${analysis.facets.quality} · Stab ${analysis.facets.stability}`}),
    el("div",{class:"pill", text:`Runes ${analysis.components.runes.length}/${analysis.allowedRunes}`}),
  ]));

  // -------------------- Guided flow (Sprint 13) --------------------
  const flow = CraftingUIFlow.compute(sel, analysis);

  // Banner: next step + quick actions
  const banner = el("div",{class:"card"});
  banner.appendChild(el("div",{class:"row"},[
    el("div",{text:`Next: ${flow.label}`}),
    el("div",{class:"muted", text: flow.hint })
  ]));

  // "Why risk?" — show breakdown in a small alert (debug puzzle vibe)
  const btnWhyRisk = el("button",{class:"small", text:"Why this risk?", onclick: ()=>{
    const lines = (analysis.riskBreakdown||[]).map(x=>`+${x.points}  ${x.label}`);
    const core = [
      `Risk: ${analysis.risk}`,
      `Tier ${analysis.facets.tier} · Q ${analysis.facets.quality} · Stab ${analysis.facets.stability} · Cx ${analysis.facets.complexity} · Corr ${analysis.facets.corruption}`,
      "",
      ...(lines.length ? lines : ["(no risk contributions)"])
    ];
    alert(core.join("\n"));
  }});

  // Quick action helpers (create + attach)
  function quickCreate(typeId, namePrefix){
    const e = seedEntity(typeId, `${namePrefix} ${String(Date.now()).slice(-4)}`, {}, []);
    state.world.entities.unshift(e);
    state.world.selectedEntityId = e.id;
    return e;
  }
  function replaceSingleLink(fromId, kindId, toId){
    const from = entityById(fromId);
    if (!from) return false;
    if (WorldMutator.isBlocked && WorldMutator.isBlocked(fromId)) return false;
    const k = RefResolver.linkType(kindId) || kindId;
    from.links = (from.links||[]).filter(l=>!(l && l.kindId===k));
    if (toId) from.links.push({kindId: k, toId, note:""});
    from.updatedAt = nowISO();
    EventBus.emit("LINKS_REPLACED", {fromId, kindId:k, toId});
    return true;
  }

    const qa = el("div",{class:"row"});
  qa.appendChild(btnWhyRisk);

  // -------------------- Option A: Inline attach pickers (Sprint 14) --------------------
  // TS: the UI below is intentionally "graph-native" (it still creates the same links),
  // but reduces friction by letting you attach existing entities without leaving this card.

  /** TS: entity list helper
   * @param {string} typeId
   * @returns {Array<any>}
   */
  function listByType(typeId){
    return (state.world.entities||[]).filter(e=>e && e.typeId===typeId);
  }

  const mats = listByType("material");
  const cores = listByType("core");
  const runes = listByType("rune");

  // Attach existing Material if missing
  if (!(analysis.components.materials||[]).length){
    if (mats.length){
      const matSel = el("select",{});
      matSel.appendChild(el("option",{value:"", text:"(choose material)"}));
      mats.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(x=>{
        matSel.appendChild(el("option",{value:x.id, text:x.name}));
      });
      const btnAttachMat = el("button",{class:"small primary", text:"Attach material", onclick: ()=>{
        if (!matSel.value) return;
        replaceSingleLink(selId,"item_uses_material", matSel.value);
        saveState(); renderPreserveFocus();
      }});
      qa.appendChild(matSel);
      qa.appendChild(btnAttachMat);
    } else {
      qa.appendChild(el("button",{class:"small primary", text:"Create & attach material", onclick: ()=>{
        const m = quickCreate("material","Material");
        WorldMutator.addLink(selId,"item_uses_material", m.id, {source:"ui.quick"});
        saveState(); renderPreserveFocus();
      }}));
    }
  }

  // Attach existing Core if missing
  if (!(analysis.components.cores||[]).length){
    if (cores.length){
      const coreSel = el("select",{});
      coreSel.appendChild(el("option",{value:"", text:"(choose core)"}));
      cores.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(x=>{
        coreSel.appendChild(el("option",{value:x.id, text:x.name}));
      });
      const btnAttachCore = el("button",{class:"small primary", text:"Attach core", onclick: ()=>{
        if (!coreSel.value) return;
        replaceSingleLink(selId,"item_has_core", coreSel.value);
        saveState(); renderPreserveFocus();
      }});
      qa.appendChild(coreSel);
      qa.appendChild(btnAttachCore);
    } else {
      qa.appendChild(el("button",{class:"small primary", text:"Create & attach core", onclick: ()=>{
        const c = quickCreate("core","Core");
        WorldMutator.addLink(selId,"item_has_core", c.id, {source:"ui.quick"});
        saveState(); renderPreserveFocus();
      }}));
    }
  }

  // Rune picker (multi-attach; still optional at Tier 0)
  if (runes.length){
    const runeSel = el("select",{});
    runeSel.appendChild(el("option",{value:"", text:"(choose rune)"}));
    runes.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(x=>{
      runeSel.appendChild(el("option",{value:x.id, text:x.name}));
    });
    const btnAttachRune = el("button",{class:"small", text:"Attach rune", onclick: ()=>{
      if (!runeSel.value) return;
      WorldMutator.addLink(selId,"item_has_rune", runeSel.value, {source:"ui.quick"});
      saveState(); renderPreserveFocus();
    }});
    qa.appendChild(runeSel);
    qa.appendChild(btnAttachRune);
  }

  // Always offer create-rune shortcut (fast iteration)
  qa.appendChild(el("button",{class:"small", text:"Create rune", onclick: ()=>{
    const r = quickCreate("rune","Rune");
    WorldMutator.addLink(selId,"item_has_rune", r.id, {source:"ui.quick"});
    saveState(); renderPreserveFocus();
  }}));

  // Market attribution pickers (crafter + location) — keeps link semantics identical
  const marketInstalled = PackManager.isInstalled("market_schema_v0") || (state.sim.installedPacks||[]).includes("market_schema_v0");
  if (marketInstalled){
    const chars = listByType("character");
    const locs = listByType("location");

    const crafterSelMini = el("select",{});
    crafterSelMini.appendChild(el("option",{value:"", text:"(crafter)"}));
    chars.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(c=>{
      crafterSelMini.appendChild(el("option",{value:c.id, text:c.name}));
    });

    const btnSetCrafter = el("button",{class:"small", text:"Set crafter", onclick: ()=>{
      let id = crafterSelMini.value;
      if (!id){
        const pick = chars[0] || quickCreate("character","Crafter");
        id = pick.id;
      }
      replaceSingleLink(selId,"crafted_by", id);
      state.sim.ui.market = state.sim.ui.market || {};
      state.sim.ui.market.lastCrafterId = id;
      saveState(); renderPreserveFocus();
    }});

    const locSelMini = el("select",{});
    locSelMini.appendChild(el("option",{value:"", text:"(location)"}));
    locs.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(l=>{
      locSelMini.appendChild(el("option",{value:l.id, text:l.name}));
    });

    const btnSetLoc = el("button",{class:"small", text:"Set location", onclick: ()=>{
      let id = locSelMini.value;
      if (!id){
        const pick = locs[0] || quickCreate("location","Workshop");
        id = pick.id;
      }
      replaceSingleLink(selId,"crafted_at", id);
      state.sim.ui.market = state.sim.ui.market || {};
      state.sim.ui.market.lastLocationId = id;
      saveState(); renderPreserveFocus();
    }});

    qa.appendChild(crafterSelMini);
    qa.appendChild(btnSetCrafter);
    qa.appendChild(locSelMini);
    qa.appendChild(btnSetLoc);
  }

  banner.appendChild(qa);
  card.appendChild(banner);

  if (!analysis.ready){
    analysis.issues.slice(0,5).forEach(msg=>{
      card.appendChild(el("div",{class:"muted", text:"• " + msg}));
    });
  }

  // Settings
  const allowUnsafe = el("input",{type:"checkbox"});
  allowUnsafe.checked = !!state.sim.crafting.settings.allowUnsafe;
  allowUnsafe.onchange = ()=>{ state.sim.crafting.settings.allowUnsafe = allowUnsafe.checked; saveState(); renderPreserveFocus(); };

  const cost = el("input",{type:"number", min:"0", step:"1", value:String(state.sim.crafting.settings.costCoinPerForge||0)});
  cost.onchange = ()=>{ state.sim.crafting.settings.costCoinPerForge = Math.max(0, Number(cost.value||0)); saveState(); renderPreserveFocus(); };

  card.appendChild(el("div",{class:"row"},[
    el("label",{class:"chip"},[allowUnsafe, el("span",{text:" Allow unsafe forge"})]),
    el("label",{class:"chip"},[el("span",{text:"Cost (coin)"}), cost]),
    el("div",{class:"muted", text:`Coin: ${Number(state.sim.resources.coin||0)} · Notes: ${Number(state.sim.resources.notes||0)}`})
  ]));

  
// Lab mode (Layer 2) — gated by unlocks
const labUnlocked = !!state.sim?.crafting?.upgrades?.labUnlocked;
const feedingUnlocked = !!state.sim?.crafting?.upgrades?.feedingUnlocked;
const artifactUnlocked = !!state.sim?.crafting?.upgrades?.artifactUnlocked;

const modeSel = el("select",{});
modeSel.appendChild(el("option",{value:"production", text:"Production"}));
modeSel.appendChild(el("option",{value:"lab", text:"Lab (volatile)"}));
modeSel.value = String(state.sim.crafting.settings.mode || "production");
modeSel.disabled = !labUnlocked;
modeSel.onchange = ()=>{
  state.sim.crafting.settings.mode = modeSel.value;
  saveState(); renderPreserveFocus();
};

const tidArtifact = RefResolver.tag("artifact:grade");
const isArtifact = !!(tidArtifact && (sel.tagIds||[]).includes(tidArtifact));

const labRow = el("div",{class:"row"},[
  el("div",{text:"Mode"}),
  modeSel,
  el("div",{class:"muted", text: labUnlocked ? "Volatility increases breakage (and breakthroughs)." : "Unlock Lab mode to enable experimentation."}),
  isArtifact ? el("span",{class:"badge", text:"artifact-grade"}) : el("span",{class:"badge", text:"tier "+analysis.facets.tier})
]);
card.appendChild(labRow);

if (labUnlocked){
  const btnCrisis = el("button",{class:"small", text:`Crisis Forge (-${Number(state.sim.crafting.settings.crisisCostCoin||0)} coin)`, onclick: ()=>{
    Crafting.crisisForge(selId);
    saveState(); renderPreserveFocus();
  }});

  // Feed selector (materials/cores/runes)
  const comps = (state.world.entities||[]).filter(e=>["material","core","rune"].includes(e.typeId));
  const feedSel = el("select",{});
  comps.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(c=>{
    feedSel.appendChild(el("option",{value:c.id, text:`${c.name} [${c.typeId}]`}));
  });

  const btnFeed = el("button",{class:"small", text:`Feed (-${Number(state.sim.crafting.settings.feedCostCoin||0)} coin)`, onclick: ()=>{
    if (!feedSel.value) return;
    Crafting.feed(selId, feedSel.value);
    saveState(); renderPreserveFocus();
  }});
  btnFeed.disabled = !feedingUnlocked || comps.length===0;

  card.appendChild(el("div",{class:"row"},[
    btnCrisis,
    el("div",{class:"muted", text: feedingUnlocked ? "Feed = controlled mutation. Match affinities for stability." : "Unlock Feeding to enable."}),
  ]));

  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Feed component"}),
    feedSel,
    btnFeed
  ]));
}


  // -------------------- Market / Selling (Layer 2.5) --------------------
  const marketOk = (typeof PACK_MARKET_SCHEMA_V0 !== "undefined") && PackManager.isInstalled(PACK_MARKET_SCHEMA_V0.packId);
  const mUI = ui.market = ui.market || { crafterId:"", locationId:"", lastQuote:null };

  if (!marketOk){
    card.appendChild(el("div",{class:"hr"}));
    card.appendChild(el("div",{class:"muted", text:"Market not enabled yet. Install the Market Schema pack (Sim → Packs) or buy the Market Basics unlock to price/sell items."}));
  } else {
    card.appendChild(el("div",{class:"hr"}));
    card.appendChild(el("div",{class:"row"},[
      el("div",{text:"Finalize + Price + Sell"}),
      el("div",{class:"muted", text:"Production economy: price depends on item + crafter + location. Rep/fame updates on finalize/sale."})
    ]));

    const chars = state.world.entities.filter(e=>e && e.typeId==="character");
    const locs = state.world.entities.filter(e=>e && e.typeId==="location");

    const crafterSel = el("select",{});
    crafterSel.appendChild(el("option",{value:"", text:"(select crafter)"}));
    chars.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(c=>{
      crafterSel.appendChild(el("option",{value:c.id, text:`${c.name}`}));
    });

    const locSel = el("select",{});
    locSel.appendChild(el("option",{value:"", text:"(select location)"}));
    locs.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).forEach(l=>{
      locSel.appendChild(el("option",{value:l.id, text:`${l.name}`}));
    });

    // Default selections: UI memory -> existing links -> empty
    const curCrafter = linkFirstToId(ent,"crafted_by","character");
    const curLoc = linkFirstToId(ent,"crafted_at","location") || linkFirstToId(ent,"listed_at","location");
    if (!mUI.crafterId && curCrafter) mUI.crafterId = curCrafter;
    if (!mUI.locationId && curLoc) mUI.locationId = curLoc;
    crafterSel.value = mUI.crafterId || "";
    locSel.value = mUI.locationId || "";

    crafterSel.onchange = ()=>{ mUI.crafterId = crafterSel.value; saveState(); };
    locSel.onchange = ()=>{ mUI.locationId = locSel.value; saveState(); };

    const btnSetCrafter = el("button",{class:"small", text:"Set crafter", onclick: ()=>{
      if (!crafterSel.value) return;
      ensureSingleLink(selId, "crafted_by", crafterSel.value);
      saveState(); renderPreserveFocus();
    }});
    btnSetCrafter.disabled = !chars.length;

    const btnSetLoc = el("button",{class:"small", text:"Set location", onclick: ()=>{
      if (!locSel.value) return;
      ensureSingleLink(selId, "crafted_at", locSel.value);
      saveState(); renderPreserveFocus();
    }});
    btnSetLoc.disabled = !locs.length;

    const isFinal = hasTagByName(ent, "item:finalized");
    const isSold = hasTagByName(ent, "item:sold");

    const btnFinalize = el("button",{class:"small primary", text: isFinal ? "Finalized" : "Finalize", onclick: ()=>{
      const r = ItemFinalization.finalize(selId, {crafterId: crafterSel.value||null, locationId: locSel.value||null});
      if (!r.ok) alert(r.reason||"Finalize failed");
      // refresh quote after finalize
      mUI.lastQuote = PriceEngine.quote(selId, {crafterId: crafterSel.value||null, locationId: locSel.value||null});
      saveState(); renderPreserveFocus();
    }});
    btnFinalize.disabled = isFinal;

    const btnQuote = el("button",{class:"small", text:"Quote price", onclick: ()=>{
      mUI.lastQuote = PriceEngine.quote(selId, {crafterId: crafterSel.value||null, locationId: locSel.value||null});
      saveState(); renderPreserveFocus();
    }});
    const btnWhyPrice = el("button",{class:"small", text:"Why this price?", onclick: ()=>{
      const q = mUI.lastQuote || PriceEngine.quote(selId, {crafterId: crafterSel.value||null, locationId: locSel.value||null});
      const lines = [];
      lines.push(`Price: ${q.price} coin`);
      lines.push("");
      (q.breakdown||[]).forEach(b=> lines.push(`${b.label}: ${b.value>=0?"+":""}${b.value}`));
      if (q.repPreview){
        lines.push("");
        const p = q.repPreview;
        lines.push(`Rep/Fame preview: fame +${p.famePosDelta}/-${p.fameNegDelta}, local +${p.localPosDelta}/-${p.localNegDelta}`);
      }
      alert(lines.join("\n"));
    }});


        // -------------------- Option B: One-button pipeline (Sprint 15) --------------------
    // TS: This pipeline is a UI convenience wrapper around existing engines (Finalize -> Quote -> Sell).
    // It keeps behavior debuggable by emitting the same events as the individual buttons.
    // In TS: type PipelineUI = { previewOnly: boolean };

    const pipeUI = mUI.pipeline = mUI.pipeline || { previewOnly: false };

    const cbPreview = el("input",{type:"checkbox"});
    cbPreview.checked = !!pipeUI.previewOnly;
    cbPreview.onchange = ()=>{ pipeUI.previewOnly = cbPreview.checked; saveState(); renderPreserveFocus(); };

    const previewChip = el("label",{class:"chip"},[
      cbPreview,
      el("span",{text:" Preview only"})
    ]);

    const btnPipeline = el("button",{class:"small primary", text: pipeUI.previewOnly ? "Preview: Finalize→Quote→Sell" : "One-click: Finalize→Sell", onclick: ()=>{
      const crafterId = crafterSel.value || null;
      const locationId = locSel.value || null;

      const issues = [];
      if (!crafterId) issues.push("Choose a crafter (Character).");
      if (!locationId) issues.push("Choose a location.");
      if (issues.length){
        alert("Can't run pipeline:\n- " + issues.join("\n- "));
        return;
      }

      // Ensure attribution links (idempotent). This keeps the graph authoritative.
      ensureSingleLink(selId, "crafted_by", crafterId);
      ensureSingleLink(selId, "crafted_at", locationId);

      // Finalize if needed
      const entNow = entityById(selId);
      const alreadyFinal = entNow && hasTagByName(entNow, "item:finalized");
      if (!alreadyFinal){
        const r = ItemFinalization.finalize(selId, {crafterId, locationId});
        if (!r.ok){
          alert(r.reason || "Finalize failed");
          saveState(); renderPreserveFocus();
          return;
        }
      }

      // Quote (always)
      mUI.lastQuote = PriceEngine.quote(selId, {crafterId, locationId});

      // Preview-only: show the same explanation you'd get from "Why this price?"
      if (pipeUI.previewOnly){
        const q = mUI.lastQuote;
        const lines = [];
        lines.push(`Price preview: ${q.price} coin`);
        lines.push("");
        (q.breakdown||[]).forEach(b=> lines.push(`${b.label}: ${b.value>=0?"+":""}${b.value}`));
        if (q.repPreview){
          const p = q.repPreview;
          lines.push("");
          lines.push(`Rep/Fame preview: fame +${p.famePosDelta}/-${p.fameNegDelta}, local +${p.localPosDelta}/-${p.localNegDelta}`);
        }
        alert(lines.join("\n"));
        saveState(); renderPreserveFocus();
        return;
      }

      // Sell
      const s = MarketEngine.sell(selId, {crafterId, locationId});
      if (!s.ok) alert(s.reason || "Sell failed");

      // Refresh quote after sale so the UI stays consistent
      mUI.lastQuote = PriceEngine.quote(selId, {crafterId, locationId});
      saveState(); renderPreserveFocus();
    }});
    btnPipeline.disabled = isSold;

const btnSell = el("button",{class:"small", text:"Sell", onclick: ()=>{
      const r = MarketEngine.sell(selId, {crafterId: crafterSel.value||null, locationId: locSel.value||null});
      if (!r.ok) alert(r.reason||"Sell failed");
      mUI.lastQuote = PriceEngine.quote(selId, {crafterId: crafterSel.value||null, locationId: locSel.value||null});
      saveState(); renderPreserveFocus();
    }});
    btnSell.disabled = !isFinal || isSold;

    // Summary line
    const crafterLabel = curCrafter ? entityLabel(curCrafter) : "(none)";
    const locLabel = curLoc ? entityLabel(curLoc) : "(none)";
    card.appendChild(el("div",{class:"muted", text:`Current: crafter ${crafterLabel} · location ${locLabel} · finalized ${isFinal?"yes":"no"} · sold ${isSold?"yes":"no"}` + (repLine?` · ${repLine}`:"")}));

    card.appendChild(el("div",{class:"row"},[
      el("div",{text:"Crafter"}), crafterSel, btnSetCrafter
    ]));
    card.appendChild(el("div",{class:"row"},[
      el("div",{text:"Location"}), locSel, btnSetLoc
    ]));

    card.appendChild(el("div",{class:"row"},[btnFinalize, btnQuote, btnWhyPrice, previewChip, btnPipeline, btnSell]));

    // Show fame + local rep snapshot
    if (mUI.crafterId){
      const sum = ReputationEngine.summary(mUI.crafterId, mUI.locationId||null);
      if (sum){
        const fame = sum.fame;
        const local = sum.local;
        card.appendChild(el("div",{class:"muted", text:`Fame: +${fame.pos} / -${fame.neg}`}));
        if (local) card.appendChild(el("div",{class:"muted", text:`Local rep here: +${local.pos} / -${local.neg}`}));
      }
    }

    // Price quote breakdown
    const q = mUI.lastQuote;
    if (q && q.ok){
      card.appendChild(el("div",{class:"hr"}));
      card.appendChild(el("div",{class:"row"},[
        el("div",{text:"Quote"}),
        el("div",{class:"mono", text:`${q.price} coin`})
      ]));
      (q.breakdown||[]).slice(0,10).forEach(b=>{
        card.appendChild(el("div",{class:"item"},[
          el("div",{text:b.label}),
          el("div",{class:"mono", text:(Number(b.value)>=0?"+":"") + Number(b.value).toFixed(2)})
        ]));
      });
      const rp = q.repPreview || {};
      if ((rp.famePosDelta||0) || (rp.fameNegDelta||0) || (rp.localPosDelta||0) || (rp.localNegDelta||0)){
        card.appendChild(el("div",{class:"muted", text:`On SELL (preview): Fame +${rp.famePosDelta||0}/-${rp.fameNegDelta||0} · Local +${rp.localPosDelta||0}/-${rp.localNegDelta||0}`}));
      }
    } else if (q && !q.ok){
      card.appendChild(el("div",{class:"muted", style:"color:#b00", text: q.reason||"Quote failed"}));
    }

    if (!chars.length || !locs.length){
      card.appendChild(el("div",{class:"muted", text:"Tip: create at least one Character and one Location (World tab) to enable attribution-based pricing."}));
    }
  }


  // Actions
  const btnForge = el("button",{class:"small primary", text:"Forge once", onclick: ()=>{
    Crafting.forge(selId);
    saveState(); renderPreserveFocus();
  }});

  const btnForge5 = el("button",{class:"small", text:"Forge x5", onclick: ()=>{
    for (let i=0;i<5;i++) Crafting.forge(selId);
    saveState(); renderPreserveFocus();
  }});

  card.appendChild(el("div",{class:"row"},[btnForge, btnForge5]));

  // Last result
  const last = state.sim.crafting.lastForge;
  if (last && last.itemId === selId){
    card.appendChild(el("div",{class:"hr"}));
    card.appendChild(el("div",{class:"row"},[
      el("div",{text:"Last result"}),
      el("div",{class:"muted", text:`t${last.tick} · ${last.outcome.toUpperCase()} · roll ${last.roll.toFixed(3)} · risk ${last.riskAfterUpgrades}`})
    ]));
    card.appendChild(el("div",{class:"muted", text:last.summary}));
    card.appendChild(el("div",{class:"muted", text:`Streak: ${last.streak?.successStreak||0} (item) · ${state.sim.crafting.streaks.consecutiveSuccesses||0} (global)`}));
  }

  return card;
}

function renderPatchToolsCard(){
  const ui = state.sim.ui;
  const card = el("div",{class:"card"});
  const sel = ui.selectedEntityId ? entityById(ui.selectedEntityId) : null;

  const frozenCount = (state.sim.frozenEntityIds||[]).length;
  const isFrozen = sel ? PatchTools.isFrozen(sel.id) : false;
  const isQ = sel ? PatchTools.isQuarantined(sel.id) : false;

  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Patch tools"}),
    el("div",{class:"muted", text: sel ? sel.name : "Select an entity to patch"})
  ]));

  const btnFreeze = el("button",{class:"small", text: isFrozen ? "Unfreeze" : "Freeze", onclick: ()=>{
    if (!sel) return;
    if (PatchTools.isFrozen(sel.id)) PatchTools.unfreeze(sel.id);
    else PatchTools.freeze(sel.id);
    saveState(); renderPreserveFocus();
  }});

  const btnQuarantine = el("button",{class:"small", text: isQ ? "Unquarantine" : "Quarantine", onclick: ()=>{
    if (!sel) return;
    PatchTools.toggleQuarantine(sel.id);
    saveState(); renderPreserveFocus();
  }});

  const btnClearFrozen = el("button",{class:"small", text:`Clear frozen (${frozenCount})`, onclick: ()=>{
    PatchTools.clearFrozen();
    saveState(); renderPreserveFocus();
  }});

  const cap = el("input",{type:"number", min:"1", step:"1", value:String(state.sim.settings.maxLinksPerEntityPerKind||9999), style:"width:120px"});
  cap.onchange = ()=>{
    state.sim.settings.maxLinksPerEntityPerKind = Math.max(1, Math.min(9999, Number(cap.value||9999)));
    saveState(); renderPreserveFocus();
  };

  card.appendChild(el("div",{class:"row"},[
    btnFreeze,
    btnQuarantine,
    btnClearFrozen,
    el("span",{class:"badge", text: sel ? (isFrozen ? "frozen" : isQ ? "quarantined" : "active") : "no selection"})
  ]));

  card.appendChild(el("div",{class:"hr"}));

  card.appendChild(el("div",{class:"row"},[
    el("div",{class:"muted", text:"Link cap per entity per kind (0/blank = high):"}),
    cap
  ]));

  card.appendChild(el("div",{class:"muted", text:"Use this to intentionally stabilize (caps/cooldowns) or to isolate breakage by freezing/quarantining nodes."}));

  return card;
}


function renderObjectivesCard(){
  ObjectiveEngine.ensure();
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Objectives"}),
    el("div",{class:"muted", text:"Turn debugging into wins"})
  ]));

  const list = state.sim.objectives || [];
  if (!list.length){
    card.appendChild(el("div",{class:"muted", text:"No objectives installed."}));
    return card;
  }

  function progressText(st){
    const d = st.data || {};
    if (st.id === "OBJ-STABLE-CLUSTER"){
      const s = Number(d.streak||0);
      const hit = d.lastHit;
      return hit ? `streak ${s}/5 • biome ${hit.biomeName} • class ${hit.className}` : `streak ${s}/5`;
    }
    if (st.id === "OBJ-RUNAWAY-RECOVER"){
      const stage = d.stage || "needRunaway";
      if (stage === "needRunaway") return "waiting for runaway";
      return `recovering ${Number(d.recover||0)}/3`;
    }
    if (st.id === "OBJ-CROSSDOMAIN-RIPPLE"){
      return d.done ? `hit via ${d.ruleId||"(rule)"}` : "need a resource+facet tick";
    }
    return "";
  }

  list.forEach(st=>{
    const completed = ObjectiveEngine.isCompleted(st);
    const claimed = ObjectiveEngine.isClaimed(st);

    const rightBits = [];
    if (completed && !claimed){
      rightBits.push(el("button",{class:"small", text:`Claim (+${Number(st.reward?.notes||0)} notes)`, onclick: ()=>{
        ObjectiveEngine.claim(st.id);
        saveState(); renderPreserveFocus();
      }}));
    } else if (completed && claimed){
      rightBits.push(el("div",{class:"muted", text:"Claimed"}));
    } else {
      rightBits.push(el("div",{class:"muted", text:progressText(st)}));
    }

    card.appendChild(el("div",{class:"item"},[
      el("div",{text: st.name || st.id}),
      el("div",{class:"muted", text: completed ? "Completed" : (st.desc || "")}),
      ...rightBits
    ]));
  });

  return card;
}


function renderUnlocksCard(){
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Unlocks"}),
    el("div",{class:"muted", text:"Spend Notes to expand mechanics"})
  ]));

  const list = UnlockStore.listAll();
  if (!list.length){
    card.appendChild(el("div",{class:"muted", text:"No unlocks available."}));
    return card;
  }

  list.forEach(u=>{
    const owned = !!u.owned;
    const costN = Number(u.cost?.notes||0);
    const costC = Number(u.cost?.coin||0);

    const costBits = [];
    if (costN) costBits.push(`${costN} notes`);
    if (costC) costBits.push(`${costC} coin`);
    const costText = costBits.length ? costBits.join(" + ") : "free";

    const btn = el("button",{class:"small", text: owned ? "Owned" : (u.canAfford ? "Buy" : "Need more"), disabled: owned || !u.canAfford, onclick: ()=>{
      const r = UnlockStore.buy(u.id);
      if (!r.ok){
        EventBus.emit("WARN",{msg:"unlock buy failed", unlockId:u.id, reason:r.reason||"unknown"});
      }
      saveState(); renderPreserveFocus();
    }});

    card.appendChild(el("div",{class:"item"},[
      el("div",{style:"flex:1;"},[
        el("div",{text:u.name}),
        el("div",{class:"muted", text:u.desc}),
        el("div",{class:"muted", text:`Cost: ${costText}`})
      ]),
      btn
    ]));
  });

  return card;
}




function renderEmergenceCard(){
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Emergence"}),
    el("div",{class:"muted", text:"New entities born from interactions"})
  ]));

  const enabled = !!state.sim.settings.emergenceEnabled;
  const max = Number(state.sim.settings.emergenceMaxSpawnsPerTick || 2);

  const maxInp = el("input",{type:"number", min:"0", step:"1", value:String(max)});
  maxInp.onchange = ()=>{
    state.sim.settings.emergenceMaxSpawnsPerTick = Math.max(0, Math.min(50, Number(maxInp.value||2)));
    saveState(); renderPreserveFocus();
  };

  card.appendChild(el("div",{class:"row"},[
    el("div",{class:"pill", text: enabled ? "enabled" : "disabled"}),
    el("label",{class:"chip"},[el("span",{text:"Max / tick"}), maxInp])
  ]));

  const last = state.sim.lastEmergence;
  if (!last || !(last.spawns||[]).length){
    card.appendChild(el("div",{class:"muted", text:"No emergent spawns yet."}));
    return card;
  }

  card.appendChild(el("div",{class:"muted", text:`Last spawns (tick ${last.tick})`}));
  (last.spawns||[]).slice(0, 8).forEach(s=>{
    card.appendChild(el("div",{class:"item"},[
      el("div",{style:"flex:1;"},[
        el("div",{text: entityLabel(s.entityId)}),
        el("div",{class:"muted", text:`${s.kind} • ${s.key}`})
      ]),
      el("button",{class:"small", text:"Explain", onclick: ()=>{
        state.sim.ui.selectedEntityId = s.entityId;
        saveState(); renderPreserveFocus();
      }})
    ]));
  });

  return card;
}


function renderInspectorPanel(){
  const ui = state.sim.ui;
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"},[
    el("div",{text:"Inspector"}),
    el("div",{class:"muted", text: ui.selectedEntityId ? entityLabel(ui.selectedEntityId) : "Select an entity to explain"})
  ]));

  if (!ui.selectedEntityId){
    card.appendChild(el("div",{class:"muted", text:"Tip: click Explain in Candidates or Graph."}));
    return card;
  }

  const trace = Inspector.traceEntity(ui.selectedEntityId, {limit: 120});
  if (!trace.events.length){
    card.appendChild(el("div",{class:"muted", text:"No events touched this entity yet."}));
    return card;
  }

  if (trace.birth){
    card.appendChild(el("div",{class:"muted", text:`Born: ${formatEvent(trace.birth)}`}));
  }

  card.appendChild(el("div",{class:"muted", text:"Top rules affecting this entity (by event count)"}));
  (trace.topRules||[]).forEach(x=>{
    card.appendChild(el("div",{class:"item"},[
      el("div",{text:x.ruleId}),
      el("div",{class:"mono muted", text:String(x.n)}),
      el("button",{class:"small", text:"Filter", onclick: ()=>{
        state.sim.ui.eventFilter.ruleId = x.ruleId;
        saveState(); renderPreserveFocus();
      }})
    ]));
  });

  card.appendChild(el("div",{class:"hr"}));
  card.appendChild(el("div",{class:"muted", text:"Recent related events"}));
  trace.events.slice(0, 30).forEach(ev=>{
    card.appendChild(el("div",{class:"item"},[
      el("div",{text: ev.type}),
      el("div",{class:"muted", text: formatEvent(ev)})
    ]));
  });

  return card;
}

function formatEvent(ev){
  if (ev.type==="TICK_START") return `tick ${ev.tick}`;
  if (ev.type==="RUNAWAY_DETECTED") return `runaway: fired ${ev.fired||0}, links +${ev.linksAdded||0}, maxΔ ${ev.maxAbsDelta||0}`;
  if (ev.type==="TICK_END") return `tick ${ev.tick} fired ${ev.fired||0}, links +${ev.linksAdded||0}`;
  if (ev.type==="RULE_FIRED") return `${ev.name || ev.ruleId} on ${entityLabel(ev.entityId)}`;
  if (ev.type==="RESOURCE_DELTA") return `${ev.resource} ${(ev.delta>=0?"+":"")}${ev.delta} (rule ${ev.ruleId})`;
  if (ev.type==="LINK_ADDED") return `${entityLabel(ev.fromId)} → ${entityLabel(ev.toId)} (${ev.kindId})`;
  if (ev.type==="FACET_DELTA") return `${entityLabel(ev.entityId)} ${ev.facet}: ${ev.before}→${ev.after}`;
  if (ev.type==="TAG_ADDED") return `${entityLabel(ev.entityId)} +${tagName(ev.tagId)}`;
  if (ev.type==="TAG_REMOVED") return `${entityLabel(ev.entityId)} -${tagName(ev.tagId)}`;

  if (ev.type==="FORGE_ATTEMPT") return `${entityLabel(ev.itemId)} ${ev.mode||"production"} attempt (risk ${ev.risk})${ev.ready?"" :" [not ready]"}`;
  if (ev.type==="FORGE_RESULT") return `${entityLabel(ev.itemId)} → ${String(ev.outcome||"").toUpperCase()} [${ev.mode||"production"}] (roll ${(Number(ev.roll)||0).toFixed(3)} risk ${ev.riskAfterUpgrades??ev.risk})`;
if (ev.type==="FEED_ATTEMPT") return `${entityLabel(ev.itemId)} feed ${entityLabel(ev.componentId)} [${ev.componentType||"component"}]`;
if (ev.type==="FEED_RESULT") return `${entityLabel(ev.itemId)} feed result: ${ev.matchAffinity ? "affinity match" : "mismatch"}`;
if (ev.type==="QUIRK_GAINED") return `${entityLabel(ev.itemId)} gained quirk ${String(ev.quirk||"")}`;
if (ev.type==="ARTIFACT_PROMOTED") return `${entityLabel(ev.itemId)} became artifact-grade`;
if (ev.type==="TIER_UP") return `${entityLabel(ev.itemId)} tier up (${ev.before}→${ev.after})`;
  if (ev.type==="UNLOCK_APPLIED") return `unlock applied: ${ev.unlockId}${ev.packId?(" → "+ev.packId):""}`;

  if (ev.type==="ENTITY_FROZEN") return `${entityLabel(ev.entityId)} frozen`;
  if (ev.type==="ENTITY_UNFROZEN") return `${entityLabel(ev.entityId)} unfrozen`;
  if (ev.type==="FROZEN_CLEARED") return `cleared frozen (${ev.count||0})`;
  if (ev.type==="LINK_CAP_REACHED") return `${entityLabel(ev.fromId)} cap(${ev.kindId})=${ev.cap}`;
  if (ev.type==="RUNAWAY_DETECTED") return `fired=${ev.fired}, linksAdded=${ev.linksAdded}, maxAbsDelta=${ev.maxAbsDelta}`;
  if (ev.type==="OBJECTIVE_PROGRESS") return `${ev.objectiveId}: ${ev.progress||""}`;
  if (ev.type==="OBJECTIVE_COMPLETED") return `${ev.objectiveId} completed`;
  if (ev.type==="REWARD_GRANTED") {
    const d = (ev.deltas||[]).map(x=>`${x.key}${x.delta>=0?"+":""}${x.delta}`).join(", ");
    return `${ev.objectiveId} reward: ${d}`;
  }

  if (ev.type==="UNLOCK_PURCHASED") return `${ev.unlockId} purchased`;
  if (ev.type==="UNLOCK_APPLIED") return `${ev.unlockId} applied (${ev.kind||""})`;
  if (ev.type==="ENTITY_SPAWNED") {
    const cause = ev.causedBy?.kind ? ` because ${ev.causedBy.kind}` : "";
    return `${entityLabel(ev.entityId)} spawned${cause}`;
  }
  if (ev.type==="EMERGENCE_TRIGGERED") return `${ev.kind} → ${entityLabel(ev.entityId)} (${ev.key})`;
  return JSON.stringify(ev);
}

function eventsForEntity(entityId, limit=80){
  const out = [];
  const list = state.sim.events || [];
  for (let i=list.length-1; i>=0 && out.length<limit; i--){
    const ev = list[i];
    if (ev.entityId === entityId || ev.fromId === entityId || ev.toId === entityId) out.push(ev);
  }
  return out;
}


/** -------------------- WORLD -------------------- */
function renderWorld() {
  const left = $("#leftPane"), main = $("#mainPane"), right = $("#rightPane");
  left.innerHTML = main.innerHTML = right.innerHTML = "";

  const typeSel = el("select", {id:"world-type"});
  for (const t of state.index.entityTypes) typeSel.appendChild(el("option", {value:t.id, text:t.name}));
  typeSel.value = state.world.filter.typeId;
  typeSel.onchange = () => { state.world.filter.typeId = typeSel.value; state.world.selectedEntityId=null; saveState(); renderPreserveFocus(); };

  const search = el("input", {id:"world-search", placeholder:"Search.", value: state.world.filter.text || ""});
  search.oninput = () => { state.world.filter.text = search.value; saveState(); renderPreserveFocus(); };

  const pinOnly = el("input", {type:"checkbox"});
  pinOnly.checked = !!state.world.filter.pinnedOnly;
  pinOnly.onchange = ()=> { state.world.filter.pinnedOnly = pinOnly.checked; saveState(); renderPreserveFocus(); };

  const btnNew = el("button", {class:"primary", text:"New entry", onclick: () => {
    const typeId = state.world.filter.typeId;
    const e = seedEntity(typeId, "Untitled", {}, []);
    state.world.entities.unshift(e);
    state.world.selectedEntityId = e.id;
    saveState();
    renderPreserveFocus();
  }});

  left.appendChild(el("div", {class:"col"}, [
    el("div", {class:"muted", text:"World Browser"}),
    typeSel,
    search,
    el("label", {class:"row", style:"gap:8px"}, [pinOnly, el("span",{text:"Pinned only"})]),
    btnNew,
    el("div", {class:"hr"}),
    el("div", {class:"muted", text:"Filter tags"}),
  ]));

  const filterTags = state.world.filter.tags || [];
  left.appendChild(renderTagChips(filterTags, (tid) => {
    const i = filterTags.indexOf(tid);
    if (i>=0) filterTags.splice(i,1); else filterTags.push(tid);
    state.world.filter.tags = filterTags;
    saveState();
    renderPreserveFocus();
  }));

  
  // -------------------- BULK TAG OPERATIONS --------------------
  if (!state.world.bulkMode) state.world.bulkMode = { enabled: false, selected: new Set() };
  // If loaded from JSON, selected may be an array; normalize to Set
  const bulkMode = state.world.bulkMode;
  // Normalize persisted selection (Set cannot be JSON-stringified)
  if (!(bulkMode.selected instanceof Set)) {
    const arr = Array.isArray(bulkMode.selected) ? bulkMode.selected : (bulkMode.selectedArr || []);
    bulkMode.selected = new Set(arr);
  }

  const toggleBulk = el("input", {type:"checkbox"});
  toggleBulk.checked = !!bulkMode.enabled;
  toggleBulk.onchange = () => {
    bulkMode.enabled = toggleBulk.checked;
    if (!bulkMode.enabled) bulkMode.selected.clear();
    // persist selected as array (Sets don't JSON stringify)
    bulkMode.selectedArr = Array.from(bulkMode.selected);
    saveState(); renderPreserveFocus();
  };

  left.appendChild(el("label", {class:"row", style:"gap:8px"}, [
    toggleBulk,
    el("span", {text:"Bulk edit mode"})
  ]));

  if (bulkMode.enabled) {
    const count = bulkMode.selected.size;
    const bulkTagIds = [];

    const applyTags = () => {
      if (!bulkTagIds.length || !count) return;
      bulkMode.selected.forEach(id => {
        const e = entityById(id);
        if (!e) return;
        e.tagIds = Array.from(new Set([...(e.tagIds||[]), ...bulkTagIds]));
        e.updatedAt = nowISO();
      });
      bulkMode.selected.clear();
      bulkMode.enabled = false;
      bulkMode.selectedArr = [];
      saveState();
      toast(`Applied tags to ${count} entities`);
      renderPreserveFocus();
    };

    const removeTags = () => {
      if (!bulkTagIds.length || !count) return;
      bulkMode.selected.forEach(id => {
        const e = entityById(id);
        if (!e) return;
        e.tagIds = (e.tagIds||[]).filter(t => !bulkTagIds.includes(t));
        e.updatedAt = nowISO();
      });
      bulkMode.selected.clear();
      bulkMode.enabled = false;
      bulkMode.selectedArr = [];
      saveState();
      toast(`Removed tags from ${count} entities`);
      renderPreserveFocus();
    };

    left.appendChild(el("div", {class:"card"}, [
      el("div", {class:"muted", text:`${count} selected`}),
      renderTagChips(bulkTagIds, (tid) => {
        const i = bulkTagIds.indexOf(tid);
        if (i>=0) bulkTagIds.splice(i,1); else bulkTagIds.push(tid);
        renderPreserveFocus();
      }),
      el("div", {class:"row", style:"margin-top:8px"}, [
        el("button", {class:"primary small", text:"Apply to selected", onclick: applyTags}),
        el("button", {class:"danger small", text:"Remove from selected", onclick: removeTags})
      ])
    ]));
  }

const filtered = state.world.entities
    .filter(e => e.typeId === state.world.filter.typeId)
    .filter(e => !state.world.filter.pinnedOnly || e.pinned)
    .filter(e => {
      const q = (state.world.filter.text||"").toLowerCase().trim();
      if (!q) return true;
      return (e.name||"").toLowerCase().includes(q) || Object.values(e.fields||{}).join(" ").toLowerCase().includes(q);
    })
    .filter(e => !filterTags.length || filterTags.every(tid => (e.tagIds||[]).includes(tid)))
    .sort((a,b) => (b.pinned===true) - (a.pinned===true) || (b.updatedAt||"").localeCompare(a.updatedAt||""));

  const list = el("div", {class:"list"});
  filtered.forEach(e => {
    const active = state.world.selectedEntityId === e.id;
    const hasInternalConflict = internalConflictPairs(e.tagIds||[]).length > 0;
    const itemClass = "item" + (active?" active":"") + (hasInternalConflict?" has-conflict":"");

    const itemEl = el("div", {
      class: itemClass,
      "data-world-id": e.id,
      onclick: (ev)=>{
        if (ev.target && ev.target.type === 'checkbox') return; // don't select if clicking checkbox
        state.world.selectedEntityId = e.id;
        saveState();
        renderPreserveFocus();
      }
    }, [
      bulkMode.enabled ? el("input", {
        type:"checkbox",
        checked: bulkMode.selected.has(e.id),
        onclick: (ev) => ev.stopPropagation(),
        onchange: (ev) => {
          if (ev.target.checked) bulkMode.selected.add(e.id);
          else bulkMode.selected.delete(e.id);
          bulkMode.selectedArr = Array.from(bulkMode.selected);
          saveState();
          renderPreserveFocus();
        }
      }) : null,
      el("div", {style:"flex:1"}, [
        el("div", {text: e.name + (hasInternalConflict ? " ⚠️" : "")}),
        el("div", {class:"muted", text:(e.tagIds||[]).slice(0,6).map(tagName).join(", ")})
      ])
    ].filter(Boolean));

    list.appendChild(itemEl);
  });
  left.appendChild(el("div", {class:"card"}, [
    el("div", {class:"muted", text:`${filtered.length} entries`}),
    list
  ]));

  // Sprint 18: after jumping via search/recents, scroll + flash the selected row.
  applyWorldNavFocus();

  const sel = state.world.entities.find(e => e.id === state.world.selectedEntityId) || null;
  if (!sel) {
    main.appendChild(el("div",{class:"card"}, [
      el("div",{text:"Select an entry to edit, or create a new one."}),
      el("div",{class:"muted", text:"World entries can link to each other like a tiny wiki."})
    ]));
    return;
  }

  const name = el("input",{id:`world-name-${sel.id}`, value: sel.name});
  name.oninput = (ev)=>{ sel.name = ev.target.value; sel.updatedAt=nowISO(); saveState();
    const row = document.querySelector(`[data-world-id="${sel.id}"]`);
    if (row) row.querySelector("div").textContent = sel.name;
  };

  const btnPin = el("button",{text: sel.pinned ? "Unpin" : "Pin", onclick: ()=>{
    sel.pinned = !sel.pinned; sel.updatedAt=nowISO(); saveState(); renderPreserveFocus();
  }});
  const btnDel = el("button",{class:"danger", text:"Delete", onclick: ()=>{
    if (!confirm(`Delete "${sel.name}"?`)) return;
    state.world.entities = state.world.entities.filter(x=>x.id!==sel.id);
    if (state.world.selectedEntityId === sel.id) state.world.selectedEntityId = null;
    saveState(); renderPreserveFocus();
  }});

  main.appendChild(el("div",{class:"card"}, [
    el("div",{class:"row"}, [
      el("div",{class:"col", style:"flex:1"}, [
        el("div",{class:"muted", text:`Type: ${entityTypeName(sel.typeId)}`}),
        el("label",{text:"Name"}), name
      ]),
      btnPin, btnDel
    ])
  ]));

  main.appendChild(el("div",{class:"card"}, [
    el("div",{class:"muted", text:"Tags"}),
    renderTagChips(sel.tagIds||[], (tid)=>{
      sel.tagIds = sel.tagIds || [];
      const i = sel.tagIds.indexOf(tid);
      if (i>=0) sel.tagIds.splice(i,1); else sel.tagIds.push(tid);
      sel.updatedAt=nowISO();
      saveState(); renderPreserveFocus();
    }, { showCreate:true })
  ]));

  // Warn if this entry contains conflicting tags (inverse synergy inside itself)
  main.appendChild(renderConflictWarning(sel.tagIds||[]));

  main.appendChild(renderEntityFacets(sel));
  main.appendChild(renderEntityFields(sel));
  main.appendChild(renderLinksEditor(sel));

    // World rollables: roll from current filter (and biome->monsters helper)
  right.appendChild(renderWorldRollerCard({
    title: "Roll from current filter",
    subtitle: `${filtered.length} options • uses filter tags for synergy`,
    entities: filtered,
    contextTagIds: (state.world.filter.tags||[])
  }));

  if (sel && sel.typeId === "biome") {
    const biomeTags = sel.tagIds || [];
    const monsters = state.world.entities.filter(e => e.typeId==="monster");
    const inBiome = monsters.filter(m => biomeTags.length && (m.tagIds||[]).some(t=>biomeTags.includes(t)));
    right.appendChild(renderWorldRollerCard({
      title: "Roll Monster for this Biome",
      subtitle: inBiome.length ? `Monsters sharing biome tags (${biomeTags.slice(0,5).map(tagName).join(", ") || "no tags"})` : "No tagged monsters match this biome yet.",
      entities: inBiome,
      contextTagIds: biomeTags
    }));
  }

  right.appendChild(el("div",{class:"card"}, [
    el("div",{class:"muted", text:"Tip"}),
    el("div",{text:"Add tags that match your generator context (race/domain/magic) to make rolls feel coherent."})
  ]));
}



function renderWorldRollerCard({ title="Roll", subtitle="", entities=[], contextTagIds=[] }={}) {
  const card = el("div", {class:"card"});
  const header = el("div", {class:"col"}, [
    el("div", {class:"row"}, [
      el("div", {class:"col", style:"flex:1"}, [
        el("div", {text:title}),
        el("div", {class:"muted", text: subtitle || ""}),
      ])
    ])
  ]);

  const btnRoll3 = el("button", {class:"primary", text:"ROLL 3", onclick: ()=>{
    if (!entities.length) return;
    const opts = entities.map(ent => ({ id: ent.id, label: ent.name, tagIds: ent.tagIds||[], baseWeight: 1, refId: ent.id }));
    const out = Roller.softRollDetailed(opts, null, contextTagIds, 3);
    state.world.lastRoll = { title, at: nowISO(), results: out.map(r=>({ id: r.picked.refId || r.picked.id, name: r.picked.label || "Untitled", explain: r.explain })) };
    saveState();
    renderPreserveFocus();
  }});

  const btnSpin1 = el("button", {text:"SPIN WHEEL (1)", onclick: async ()=>{
    if (!entities.length) return;
    const opts = entities.map(ent => ({ id: ent.id, label: ent.name, tagIds: ent.tagIds||[], baseWeight: 1, refId: ent.id }));
    const { weights, explainFor } = Roller.computeWeights(opts, null, contextTagIds);
    if (state.quant?.visualWheel) {
      const res = await wheelModalPick({ title, subtitle: "Weighted slices", options: opts.map(o=>o.label), weights });
      if (!res) return;
      const picked = opts[res.index];
      state.world.lastRoll = { title, at: nowISO(), results: [{ id: picked.refId || picked.id, name: picked.label, explain: explainFor(res.index) }] };
    } else {
      const wp = Roller.pickWeighted(opts, null, contextTagIds);
      state.world.lastRoll = { title, at: nowISO(), results: [{ id: wp.picked.refId || wp.picked.id, name: wp.picked.label, explain: wp.explainFor(wp.index) }] };
    }
    saveState();
    renderPreserveFocus();
  }});

  const btnClear = el("button", {class:"ghost", text:"Clear", onclick: ()=>{
    if (state.world.lastRoll && state.world.lastRoll.title === title) {
      state.world.lastRoll = null;
      saveState(); renderPreserveFocus();
    }
  }});

  const btns = el("div", {class:"row"}, [btnRoll3, btnSpin1, btnClear]);
  header.appendChild(btns);

  const resWrap = el("div", {class:"col"});
  const lr = state.world.lastRoll;
  if (lr && lr.title === title && (lr.results||[]).length) {
    resWrap.appendChild(el("div", {class:"hr"}));
    resWrap.appendChild(el("div", {class:"muted", text:`Last roll • ${new Date(lr.at).toLocaleString()}`}));
    (lr.results||[]).forEach((r, idx) => {
      const row = el("div", {class:"item", style:"cursor:pointer"}, [
        el("div", {text: `${idx+1}. ${r.name}`}),
        el("div", {class:"muted", text: r.explain || ""})
      ]);
      row.onclick = ()=>{
        // jump to selected entity in World list
        state.world.selectedEntityId = r.id;
        saveState();
        renderPreserveFocus();
      };
      resWrap.appendChild(row);
    });
    resWrap.appendChild(el("div",{class:"muted", text:"Tip: tap a result to select it in the World browser."}));
  } else {
    resWrap.appendChild(el("div", {class:"muted", text: entities.length ? "Roll to pick something from this filtered set." : "No options available yet."}));
  }

  card.appendChild(header);
  card.appendChild(resWrap);
  return card;
}

function renderEntityFacets(entity){
  if (!entity || entity.typeId==="quant_profile") return el("div");
  ensureEntityFacets(entity);
  const fx = entity.fields.__facets;
  const defs = getFacetDefsForType(entity.typeId);
  if (!defs.length) {
    return el("div",{class:"card"},[
      el("div",{style:"font-weight:700; margin-bottom:6px;", text:"Facets"}),
      el("div",{class:"muted", text:"No facets configured for this type yet. Go to Index → Facet sets to add some."})
    ]);
  }
  const facetDefs = defs.map(d=>[d.key, d.label||d.key]);
  const rows = facetDefs.map(([k,label])=>{
    const inp = el("input", {
      type:"number", min:"0", max:"10", step:"1",
      value: (fx[k] ?? ""),
      oninput:(e)=>{
        const v = e.target.value===""? "" : clamp(Number(e.target.value),0,10);
        fx[k]=v;
        saveState();
        render();
      },
      style:"width:70px;"
    });
    const lab = el("div",{class:"muted", style:"font-size:12px; margin-top:4px;", text: (fx[k]===""||fx[k]==null) ? "—" : facetLabel(entity.typeId, k, fx[k])});
    return el("div",{class:"card", style:"padding:10px; min-width:170px;"},[
      el("div",{style:"display:flex; justify-content:space-between; align-items:center; gap:8px;"},[
        el("div",{text:label}),
        inp
      ]),
      lab
    ]);
  });

  // Quant profile selector
  const profiles = getQuantProfiles();
  const select = el("select", {
    onchange:(e)=>{
      const v = e.target.value;
      entity.fields.quantProfileId = v || "";
      saveState(); render();
    }
  }, [
    el("option",{value:"", text:"(Use world default)"}),
    ...profiles.map(p=>el("option",{value:p.id, text:p.name, selected: entity.fields.quantProfileId===p.id}))
  ]);

  const q = Quant.compute(entity);
  const tier = Quant.tierFromUsefulness(q.usefulness, q.facets.scope);

  return el("div",{},[
    el("div",{class:"card"},[
      el("div",{class:"row", style:"justify-content:space-between; align-items:center;"},[
        el("div",{class:"muted", text:"Quant Profile"}),
        select
      ]),
      el("div",{class:"muted", style:"margin-top:6px;", text: q.profileId ? "Active profile: "+(getQuantProfileById(q.profileId)?.name||"") : "No profile found (using defaults)."})
    ]),
    el("div",{class:"card"},[
      el("div",{style:"font-weight:700; margin-bottom:8px;", text:"Facets (0–10)"}),
      el("div",{style:"display:flex; flex-wrap:wrap; gap:10px;"}, rows)
    ]),
    el("div",{class:"card"},[
      el("div",{style:"font-weight:700; margin-bottom:8px;", text:"Quantified summary"}),
      el("div",{class:"row", style:"gap:14px; flex-wrap:wrap;"},[
        el("div",{text:`Potency: ${q.potencyUnits.toFixed(2)} units`}),
        el("div",{text:`Influence: ${q.influenceUnits.toFixed(2)} units`}),
        el("div",{text:`Usefulness: ${Math.round(q.usefulness)}`}),
        el("div",{text:`Effort: ${Math.round(q.effort)}`}),
        el("div",{text:`Net: ${Math.round(q.netValue)}`}),
        el("div",{text:`Prestige: ${Math.round(q.prestige)} (rarity x${q.rarityFactor.toFixed(2)})`}),
        el("div",{text:`Tier: ${tier}`}),
      ]),
      el("div",{class:"muted", style:"margin-top:8px;", text:
        `Usefulness channels: ${q.usedKeys?.usefulness?.join(", ") || "(none)"} • Effort channels: ${q.usedKeys?.effort?.join(", ") || "(none)"}`
      })
    ])
  ]);
}

function renderEntityFields(entity) {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"}, [
    el("div",{text:"Fields"}),
    el("div",{class:"muted", text:"(optional; used for follow-up prompts + browsing)"})
  ]));
  const template = (state.index.templates[entity.typeId] || []);
  if (!template.length) {
    card.appendChild(el("div",{class:"muted", text:"No template for this entity type yet. Add one in Index."}));
    return card;
  }

  entity.fields = entity.fields || {};
  // Skill helper: generate sensible numeric fields from tags
  if (entity.typeId === "skill") {
    const btnGen = el("button",{text:"Generate defaults from tags", onclick: ()=>{
      SkillGen.applyToSkillEntity(entity, []);
      saveState();
      renderPreserveFocus();
    }});
    const btnGenCtx = el("button",{text:"Generate using current Generator locks", onclick: ()=>{
      const ctx = contextTagIdsFromLocks(state.generator || {locks:{}});
      SkillGen.applyToSkillEntity(entity, ctx);
      saveState();
      renderPreserveFocus();
    }});
    card.appendChild(el("div",{class:"row"}, [
      btnGen,
      btnGenCtx,
      el("div",{class:"muted", text:"Fills power/utility/risk/cooldown/scope/evolves (keeps description)."})
    ]));
    card.appendChild(el("div",{class:"hr"}));
  }

  template.forEach(f=>{
    const v = entity.fields?.[f.key] ?? "";
    if (f.kind==="textarea") {
      const ta = el("textarea",{id:`field-${entity.id}-${f.key}`}, [v]);
      ta.oninput = (ev)=>{ entity.fields[f.key]=ev.target.value; entity.updatedAt=nowISO(); saveState(); };
      card.appendChild(el("div",{class:"col"}, [el("label",{text:f.label}), ta]));
    } else {
      const inp = el("input",{id:`field-${entity.id}-${f.key}`, value:v});
      inp.oninput = (ev)=>{ entity.fields[f.key]=ev.target.value; entity.updatedAt=nowISO(); saveState(); };
      card.appendChild(el("div",{class:"col"}, [el("label",{text:f.label}), inp]));
    }
  });
  return card;
}

function renderLinksEditor(entity) {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"}, [
    el("div",{text:"Links / Relationships"}),
    el("div",{class:"muted", text:"connect entries like a wiki"}),
    el("button",{class:"small", text:"Explain", onclick: ()=>{
      const evs = eventsForEntity(entity.id, 40);
      const lines = evs.map(e=>`[t${e.tick}] ${e.type} — ${formatEvent(e)}`);
      alert(lines.length ? lines.join("\n") : "No sim events touched this entity yet.");
    }})
  ]));

  const kindSel = el("select");
  for (const k of state.index.linkTypes) kindSel.appendChild(el("option",{value:k.id, text:k.name}));

  const targetSel = el("select");
  for (const e of state.world.entities) {
    if (e.id === entity.id) continue;
    targetSel.appendChild(el("option",{value:e.id, text:entityLabel(e.id)}));
  }
  const note = el("input",{placeholder:"Note (optional)"});
  const btnAdd = el("button",{class:"primary", text:"Add link", onclick: ()=>{
    const link = { kindId: kindSel.value, toId: targetSel.value, note: note.value || "" };
    entity.links = entity.links || [];
    entity.links.push(link);
    entity.updatedAt=nowISO();
    saveState();
    renderPreserveFocus();
  }});

  card.appendChild(el("div",{class:"grid2"}, [
    el("div",{class:"col"}, [el("label",{text:"Link type"}), kindSel]),
    el("div",{class:"col"}, [el("label",{text:"Target"}), targetSel]),
  ]));
  card.appendChild(el("div",{class:"row"}, [note, btnAdd]));
  card.appendChild(el("div",{class:"hr"}));

  const links = entity.links || [];
  if (!links.length) card.appendChild(el("div",{class:"muted", text:"No links yet."}));
  else {
    links.forEach((l, idx)=>{
      const kindName = state.index.linkTypes.find(k=>k.id===l.kindId)?.name || l.kindId;
      card.appendChild(el("div",{class:"item"}, [
        el("div",{text:`${kindName} → ${entityLabel(l.toId)}`}),
        el("div",{class:"muted", text:l.note || ""}),
        el("button",{class:"danger small", text:"Remove", onclick: ()=>{
          links.splice(idx,1);
          entity.updatedAt=nowISO();
          saveState(); renderPreserveFocus();
        }})
      ]));
    });
  }
  return card;
}

/** -------------------- CHARACTERS -------------------- */
function renderChars() {
  const left = $("#leftPane"), main = $("#mainPane"), right = $("#rightPane");
  left.innerHTML = main.innerHTML = right.innerHTML = "";

  const search = el("input", {id:"char-search", placeholder:"Search characters.", value: state.characters.filterText || ""});
  search.oninput = ()=>{ state.characters.filterText = search.value; saveState(); renderPreserveFocus(); };

  const pinOnly = el("input", {type:"checkbox"});
  pinOnly.checked = !!state.characters.pinnedOnly;
  pinOnly.onchange = ()=>{ state.characters.pinnedOnly = pinOnly.checked; saveState(); renderPreserveFocus(); };

  const btnNew = el("button",{class:"primary", text:"New character", onclick: ()=>{
    const c = seedCharacter("Unnamed");
    state.characters.list.unshift(c);
    state.characters.selectedId = c.id;
    saveState(); renderPreserveFocus();
  }});

  left.appendChild(el("div",{class:"col"}, [
    el("div",{class:"muted", text:"Characters"}),
    search,
    el("label", {class:"row", style:"gap:8px"}, [pinOnly, el("span",{text:"Pinned only"})]),
    btnNew,
    el("div",{class:"hr"})
  ]));

  const q = (state.characters.filterText||"").toLowerCase().trim();
  const filtered = state.characters.list
    .filter(c => !state.characters.pinnedOnly || c.pinned)
    .filter(c => !q || c.name.toLowerCase().includes(q) || (c.notes||"").toLowerCase().includes(q))
    .sort((a,b) => (b.pinned===true) - (a.pinned===true) || (b.updatedAt||"").localeCompare(a.updatedAt||""));

  const list = el("div",{class:"list"});
  filtered.forEach(c=>{
    const active = state.characters.selectedId===c.id;
    list.appendChild(el("div",{
      class:"item"+(active?" active":""),
      "data-char-id": c.id,
      onclick: ()=>{ state.characters.selectedId=c.id; saveState(); renderPreserveFocus(); }
    },[
      el("div",{text:c.name}),
      el("div",{class:"muted", text:(c.tagIds||[]).slice(0,6).map(tagName).join(", ")}),
    ]));
  });
  left.appendChild(el("div",{class:"card"}, [
    el("div",{class:"muted", text:`${filtered.length} characters`}),
    list
  ]));

  const sel = state.characters.list.find(c => c.id===state.characters.selectedId) || null;
  if (!sel) {
    main.appendChild(el("div",{class:"card"}, [
      el("div",{text:"Select a character or create a new one."}),
      el("div",{class:"muted", text:"This sheet supports huge stat arrays by grouping stats."})
    ]));
    return;
  }

  const nameInput = el("input",{id:`char-name-${sel.id}`, value: sel.name});
  nameInput.oninput = (ev)=> {
    sel.name = ev.target.value;
    sel.updatedAt = nowISO();
    saveState();
    const row = document.querySelector(`[data-char-id="${sel.id}"]`);
    if (row) row.querySelector("div").textContent = sel.name;
  };

  const btnPin = el("button",{text: sel.pinned ? "Unpin" : "Pin", onclick: ()=>{
    sel.pinned = !sel.pinned; sel.updatedAt=nowISO(); saveState(); renderPreserveFocus();
  }});
  const btnDel = el("button",{class:"danger", text:"Delete", onclick: ()=>{
    if (!confirm(`Delete "${sel.name}"?`)) return;
    state.characters.list = state.characters.list.filter(x=>x.id!==sel.id);
    if (state.characters.selectedId === sel.id) state.characters.selectedId = null;
    saveState(); renderPreserveFocus();
  }});

  main.appendChild(el("div",{class:"card"}, [
    el("div",{class:"row"}, [
      el("div",{class:"col", style:"flex:1"}, [el("label",{text:"Name"}), nameInput]),
      btnPin, btnDel
    ])
  ]));

  main.appendChild(el("div",{class:"card"}, [
    el("div",{class:"muted", text:"Character tags"}),
    renderTagChips(sel.tagIds||[], (tid)=>{
      sel.tagIds = sel.tagIds || [];
      const i = sel.tagIds.indexOf(tid);
      if (i>=0) sel.tagIds.splice(i,1); else sel.tagIds.push(tid);
      sel.updatedAt=nowISO();
      saveState(); renderPreserveFocus();
    }, { showCreate:true })
  ]));

  main.appendChild(renderCharacterRefs(sel));
  main.appendChild(renderCharacterSkills(sel));
  main.appendChild(renderStatsEditor(sel));

  main.appendChild(el("div",{class:"card"}, [
    el("div",{class:"muted", text:"Notes"}),
    (()=> {
      const ta = el("textarea",{id:`char-notes-${sel.id}`}, [sel.notes || ""]);
      ta.oninput = (ev)=>{ sel.notes = ev.target.value; sel.updatedAt=nowISO(); saveState(); };
      return ta;
    })()
  ]));

  main.appendChild(el("div",{class:"card"}, [
    el("div",{class:"row"}, [
      el("div",{text:"Draft / Writing"}),
      el("div",{class:"muted", text:"(keep it close to the rolls)"})
    ]),
    (()=> {
      const ta = el("textarea",{id:`char-draft-${sel.id}`}, [sel.draft || ""]);
      ta.oninput = (ev)=>{ sel.draft = ev.target.value; sel.updatedAt=nowISO(); saveState(); };
      return ta;
    })()
  ]));

  right.appendChild(el("div",{class:"card"}, [
    el("div",{class:"muted", text:"Quick actions"}),
    el("button",{class:"primary", text:"Open Skill Library", onclick: ()=>{
      state.world.filter.typeId="skill";
      state.world.filter.text="";
      state.ui.tab="world";
      saveState(); renderPreserveFocus();
    }}),
    el("button",{text:"Open Class Library", onclick: ()=>{
      state.world.filter.typeId="class";
      state.world.filter.text="";
      state.ui.tab="world";
      saveState(); renderPreserveFocus();
    }}),
    el("div",{class:"hr"}),
    el("div",{class:"muted", text:"Tip: Tag classes/skills with Domain tags. Tag characters with Race/Domain/Magic tags. The generator and skill suggestions will start tilting automatically."})
  ]));
}

function renderCharacterRefs(char) {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{text:"Class & Magic"}));

  const classSel = el("select",{id:`char-class-${char.id}`});
  classSel.appendChild(el("option",{value:"", text:"(no class)"}));
  state.world.entities.filter(e=>e.typeId==="class")
    .slice().sort((a,b)=>a.name.localeCompare(b.name))
    .forEach(e=> classSel.appendChild(el("option",{value:e.id, text:e.name})));
  classSel.value = char.classId || "";
  classSel.onchange = ()=>{ char.classId = classSel.value || null; char.updatedAt=nowISO(); saveState(); renderPreserveFocus(); };

  const magicSel = el("select",{id:`char-magic-${char.id}`});
  magicSel.appendChild(el("option",{value:"", text:"(no magic school)"}));
  state.world.entities.filter(e=>e.typeId==="magic_school")
    .slice().sort((a,b)=>a.name.localeCompare(b.name))
    .forEach(e=> magicSel.appendChild(el("option",{value:e.id, text:e.name})));
  magicSel.value = char.magicSchoolId || "";
  magicSel.onchange = ()=>{ char.magicSchoolId = magicSel.value || null; char.updatedAt=nowISO(); saveState(); renderPreserveFocus(); };

  card.appendChild(el("div",{class:"grid2"}, [
    el("div",{class:"col"}, [el("label",{text:"Class"}), classSel]),
    el("div",{class:"col"}, [el("label",{text:"Magic School"}), magicSel]),
  ]));

  // Auto-populate stats from tags
  const btnAutoStats = el("button", {class:"btn small", text:"Auto-populate stats from tags", onclick: () => {
    if (!confirm("This will adjust stats based on character tags. Continue?")) return;

    const tagSet = new Set((char.tagIds||[]).map(tid => {
      const t = tagById(tid);
      return t?.name?.toLowerCase();
    }).filter(Boolean));

    const adj = { Physical: {}, Mental: {}, Social: {}, Metaphysical: {} };

    if (tagSet.has("martial")) { adj.Physical.STR = 2; adj.Physical.DUR = 1; }
    if (tagSet.has("scouting") || tagSet.has("scout")) { adj.Physical.AGI = 2; adj.Physical.REF = 1; }
    if (tagSet.has("arcane")) { adj.Mental.INT = 2; adj.Mental.WIT = 1; }
    if (tagSet.has("primal")) { adj.Physical.DUR = (adj.Physical.DUR||0)+1; adj.Metaphysical.WILL = 1; }
    if (tagSet.has("social")) { adj.Social.CHA = 2; adj.Social.EMP = 1; }
    if (tagSet.has("crafting") || tagSet.has("crafter")) { adj.Mental.FOC = 1; adj.Physical.REF = (adj.Physical.REF||0)+1; }
    if (tagSet.has("orc")) { adj.Physical.STR = (adj.Physical.STR||0)+1; adj.Physical.END = 1; }
    if (tagSet.has("elf")) { adj.Physical.AGI = (adj.Physical.AGI||0)+1; adj.Mental.INT = (adj.Mental.INT||0)+1; }
    if (tagSet.has("dwarf")) { adj.Physical.DUR = (adj.Physical.DUR||0)+1; adj.Metaphysical.RES = 1; }

    Object.keys(adj).forEach(group => {
      if (!char.stats[group]) char.stats[group] = {};
      Object.keys(adj[group]).forEach(stat => {
        const current = char.stats[group][stat] || 4;
        char.stats[group][stat] = clamp(current + adj[group][stat], 1, 10);
      });
    });

    char.updatedAt = nowISO();
    saveState();
    toast("Stats adjusted based on tags");
    renderPreserveFocus();
  }});

  card.appendChild(el("div", {class:"row", style:"margin-top:8px"}, [btnAutoStats]));

  const cls = char.classId ? entityById(char.classId) : null;
  const mag = char.magicSchoolId ? entityById(char.magicSchoolId) : null;
  if (cls) card.appendChild(el("div",{class:"muted", text:(cls.fields?.role || "").slice(0,140)}));
  if (mag) card.appendChild(el("div",{class:"muted", text:(mag.fields?.kind || "").slice(0,140)}));
  return card;
}

function renderCharacterSkills(char) {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"}, [
    el("div",{text:"Skills"}),
    el("div",{class:"muted", text:"(fixed count for now; strength varies per skill)"})
  ]));

  // Context = character tags + class/magic tags
  const context = new Set([...(char.tagIds||[])]);
  if (char.classId) (entityById(char.classId)?.tagIds||[]).forEach(t=>context.add(t));
  if (char.magicSchoolId) (entityById(char.magicSchoolId)?.tagIds||[]).forEach(t=>context.add(t));
  const ctxTags = Array.from(context);

  // Build a relevance-sorted list for the manual picker
  const skills = state.world.entities.filter(e=>e.typeId==="skill");
  const scored = skills.map(s=>{
    const overlap = countOverlap(s.tagIds||[], ctxTags);
    return {s, overlap};
  }).sort((a,b)=>b.overlap-a.overlap || a.s.name.localeCompare(b.s.name));

  const sel = el("select",{id:`char-skill-sel-${char.id}`});
  sel.appendChild(el("option",{value:"", text:"Select a skill…"}));
  scored.slice(0,200).forEach(({s, overlap})=>{
    const suffix = overlap>0 ? ` (+${overlap} tag match)` : "";
    sel.appendChild(el("option",{value:s.id, text:`${s.name}${suffix}`}));
  });

  const btnAdd = el("button",{class:"primary", text:"Add skill", onclick: ()=>{
    if (!sel.value) return;
    const sid = sel.value;
    char.skillIds = char.skillIds || [];
    if (!char.skillIds.includes(sid)) char.skillIds.push(sid);
    // Clear offers so you don't accidentally add twice from stale suggestions
    char._skillCandidates = null;
    char.updatedAt=nowISO();
    saveState(); renderPreserveFocus();
  }});

  const btnOffer = el("button",{text:"Soft reroll: offer 3", onclick: ()=>{
    const gen = state.generator;
    const fakeStep = {source:"library:skill"};
    const opts = getStepOptions(fakeStep);
    if (!opts.length) { alert("No skills in the library yet. Create some under World → Skill."); return; }
    const picks = Roller.softRollDetailed(opts, gen, ctxTags, 3)
      .map(x=>normalizeResult(fakeStep, x.picked, gen, ctxTags, x.explain));
    char._skillCandidates = picks;
    char.updatedAt=nowISO();
    saveState(); renderPreserveFocus();
  }});

  const btnWheelAddSkill = el("button",{text:"SPIN WHEEL: add 1", onclick: async ()=>{
    const gen = state.generator;
    const fakeStep = {source:"library:skill"};
    const opts = getStepOptions(fakeStep);
    if (!opts.length) { alert("No skills in the library yet. Create some under World → Skill."); return; }

    // Compute weights once (same logic everywhere)
    const w = Roller.computeWeights(opts, gen, ctxTags);
    let winner = null;
    if (state.quant.visualWheel) {
      winner = await wheelModalPick({
        title: "SPIN SKILL",
        subtitle: "Weighted by tags + rarity",
        options: opts,
        weights: w.weights
      });
    } else {
      winner = Roller.pickWeighted(opts, gen, ctxTags).picked;
    }
    if (!winner) return;
    const res = normalizeResult(fakeStep, winner, gen, ctxTags, w.explainFor(opts.indexOf(winner)));
    if (!res.refId) return;
    char.skillIds = char.skillIds || [];
    if (!char.skillIds.includes(res.refId)) char.skillIds.push(res.refId);
    char._skillCandidates = null;
    char.updatedAt=nowISO();
    saveState(); renderPreserveFocus();
  }});

  const btnClearOffers = el("button",{class:"ghost", text:"Clear offers", onclick: ()=>{
    char._skillCandidates = null;
    saveState(); renderPreserveFocus();
  }});

  const btnNewSkill = el("button",{class:"ghost", text:"Create new skill", onclick: ()=>{
    const e = seedEntity("skill", "Untitled Skill", {}, []);
    state.world.entities.unshift(e);
    state.world.filter.typeId="skill";
    state.world.selectedEntityId = e.id;
    state.ui.tab="world";
    saveState(); renderPreserveFocus();
  }});

  card.appendChild(el("div",{class:"row"}, [sel, btnAdd, btnOffer, btnWheelAddSkill, btnClearOffers, btnNewSkill]));

  // QUICK SKILL GENERATION (module-backed)
  const genSkillName = el("input",{id:`skillgen-name-${char.id}`, placeholder:"Generated skill name (optional)"});
  const btnGenSkill = el("button",{class:"primary", text:"Generate + add skill", onclick: ()=>{
    const name = (genSkillName.value || "").trim() || "Untitled Skill";
    const e = SkillGen.createGeneratedSkill({ name, tagIds: ctxTags, contextTagIds: ctxTags });
    // store in world library
    state.world.entities.unshift(e);
    // add to character
    char.skillIds = char.skillIds || [];
    if (!char.skillIds.includes(e.id)) char.skillIds.push(e.id);
    char.updatedAt = nowISO();
    genSkillName.value = "";
    saveState(); renderPreserveFocus();
  }});
  card.appendChild(el("div",{class:"createBox"}, [
    el("div",{class:"title", text:"CREATE NEW GENERATED SKILL"}),
    el("div",{class:"muted", text:"Uses character context tags to set power/utility/risk/cooldown/scope. Edit afterwards in World → Skill."}),
    el("div",{class:"row"}, [genSkillName, btnGenSkill])
  ]));
  card.appendChild(el("div",{class:"hr"}));

  // Show skill offers (persisted in state, so they don't vanish on re-render)
  if (char._skillCandidates?.length) {
    card.appendChild(el("div",{class:"muted", text:"Offered skills (pick one or delete offers):"}));
    char._skillCandidates.forEach((c, idx)=>{
      card.appendChild(el("div",{class:"item"}, [
        el("div",{class:"row"}, [
          el("div",{style:"flex:1; font-weight:800", text:c.label}),
          el("button",{class:"primary small", text:"Add", onclick: ()=>{
            if (!c.refId) return;
            char.skillIds = char.skillIds || [];
            if (!char.skillIds.includes(c.refId)) char.skillIds.push(c.refId);
            char._skillCandidates = null;
            char.updatedAt=nowISO();
            saveState(); renderPreserveFocus();
          }}),
          el("button",{class:"danger small", text:"Remove offer", onclick: ()=>{
            char._skillCandidates.splice(idx,1);
            if (!char._skillCandidates.length) char._skillCandidates = null;
            saveState(); renderPreserveFocus();
          }})
        ]),
        c.why ? el("div",{class:"muted", text:c.why}) : el("div"),
        (c.tagIds?.length ? el("div",{class:"muted", text:"tags: " + c.tagIds.slice(0,8).map(tagName).join(", ")}) : el("div"))
      ]));
    });
    card.appendChild(el("div",{class:"row"}, [
      el("button",{text:"Offer 3 again", onclick: ()=>{ btnOffer.onclick(); }}),
      el("button",{class:"ghost", text:"Keep none", onclick: ()=>{ char._skillCandidates=null; saveState(); renderPreserveFocus(); }})
    ]));
    card.appendChild(el("div",{class:"hr"}));
  }

  // Current skills
  const ids = char.skillIds || [];
  if (!ids.length) card.appendChild(el("div",{class:"muted", text:"No skills yet."}));
  else {
    ids.forEach((sid, idx)=>{
      const s = entityById(sid);
      card.appendChild(el("div",{class:"item"}, [
        el("div",{class:"row"}, [
          el("div",{style:"flex:1", text: s ? s.name : "(missing)"}),
          el("button",{class:"danger small", text:"Remove", onclick: ()=>{
            ids.splice(idx,1);
            char.updatedAt=nowISO();
            saveState(); renderPreserveFocus();
          }})
        ]),
        s ? el("div",{class:"muted", text: (s.fields?.description || "").slice(0,160) }) : el("div")
      ]));
    });
  }
  return card;
}


function renderStatsEditor(char) {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"}, [
    el("div",{text:"Stats"}),
    el("div",{class:"muted", text:"Add categories + keys freely (big arrays welcome)"})
  ]));

  char.stats = char.stats || {};

  // Add group
  const addGroupName = el("input",{id:`stat-add-group-${char.id}`, placeholder:"New stat group name (e.g., Survival)"});
  const btnAddGroup = el("button",{class:"primary", text:"Add group", onclick: ()=>{
    const g = addGroupName.value.trim();
    if (!g) return;
    if (char.stats[g]) return alert("Group already exists.");
    char.stats[g] = {};
    addGroupName.value = "";
    char.updatedAt=nowISO();
    saveState(); renderPreserveFocus();
  }});
  card.appendChild(el("div",{class:"row"}, [addGroupName, btnAddGroup]));
  card.appendChild(el("div",{class:"hr"}));

  // Render groups
  Object.keys(char.stats).forEach(groupName=>{
    const group = char.stats[groupName] || {};
    const groupCard = el("div",{class:"card"});

    const btnDelGroup = el("button",{class:"danger small", text:"Remove group", onclick: ()=>{
      if (!confirm(`Remove group "${groupName}"?`)) return;
      delete char.stats[groupName];
      char.updatedAt=nowISO();
      saveState(); renderPreserveFocus();
    }});

    groupCard.appendChild(el("div",{class:"row"}, [
      el("div",{style:"flex:1; font-weight:700", text:groupName}),
      btnDelGroup
    ]));

    // Add stat key
    const keyInp = el("input",{id:`stat-add-key-${char.id}-${groupName}`, placeholder:"New stat key (e.g., STEALTH)"});
    const valInp = el("input",{id:`stat-add-val-${char.id}-${groupName}`, placeholder:"Value (number)", value:"4"});
    const btnAddKey = el("button",{class:"primary small", text:"Add stat", onclick: ()=>{
      const k = keyInp.value.trim();
      if (!k) return;
      const v = Number(valInp.value);
      group[k] = isNaN(v) ? 0 : v;
      keyInp.value = "";
      char.updatedAt=nowISO();
      saveState(); renderPreserveFocus();
    }});
    groupCard.appendChild(el("div",{class:"row"}, [keyInp, valInp, btnAddKey]));
    groupCard.appendChild(el("div",{class:"hr"}));

    // Existing stats
    const rows = el("div",{class:"grid3"});
    Object.keys(group).forEach(key=>{
      const inp = el("input",{id:`stat-${char.id}-${groupName}-${key}`, value:String(group[key])});
      inp.oninput = (ev)=>{ group[key]=Number(ev.target.value)||0; char.updatedAt=nowISO(); saveState(); };
      const btnDel = el("button",{class:"danger small", text:"X", onclick: ()=>{
        delete group[key];
        char.updatedAt=nowISO();
        saveState(); renderPreserveFocus();
      }});
      rows.appendChild(el("div",{class:"col"}, [
        el("label",{text:key}),
        el("div",{class:"row"}, [inp, btnDel])
      ]));
    });
    if (!Object.keys(group).length) groupCard.appendChild(el("div",{class:"muted", text:"No stats in this group yet."}));
    else groupCard.appendChild(rows);

    card.appendChild(groupCard);
  });

  return card;
}

/** -------------------- GENERATOR -------------------- */

/** -------------------- WEIGHTED WHEEL MODULE (Canvas) --------------------
 * Based on user's wheel function draft, adapted for weighted slices and reuse. */
const Wheel = (() => {
  let angle = 0;
  let velocity = 0;
  const friction = 0.985;
  let rafId = null;

  function computeSegments(options, weights){
    const total = weights.reduce((a,b)=>a+Math.max(0,b), 0) || 1;
    let acc = 0;
    const segs = options.map((opt,i)=>{
      const w = Math.max(0, weights[i] ?? 0);
      const start = acc;
      const span = (w/total) * (2*Math.PI);
      acc += span;
      return { opt, i, w, start, end: acc };
    });
    // If rounding left a gap, extend last end to 2π
    if (segs.length) segs[segs.length-1].end = 2*Math.PI;
    return segs;
  }

  function draw(canvas, segments){
    const ctx = canvas.getContext("2d");
    const cx = canvas.width/2, cy = canvas.height/2;
    const radius = Math.min(cx, cy) - 18;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // slices
    segments.forEach((s, idx)=>{
      const a0 = angle + s.start;
      const a1 = angle + s.end;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, radius, a0, a1);
      ctx.closePath();
      // simple alternating + slight hue shift
      const hue = (360/Math.max(segments.length,1))*idx;
      ctx.fillStyle = `hsl(${hue}, 65%, ${idx%2===0?82:76}%)`;
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.12)";
      ctx.stroke();

      // label
      const mid = (a0+a1)/2;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(mid);
      ctx.textAlign = "right";
      ctx.fillStyle = "#222";
      ctx.font = "600 13px system-ui";
      const label = (s.opt.label||"").slice(0, 22);
      ctx.fillText(label, radius - 10, 5);
      ctx.restore();
    });

    // hub
    ctx.beginPath();
    ctx.arc(cx, cy, 10, 0, 2*Math.PI);
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.fill();
  }

  function pickWinner(segments){
    // pointer at top: 1.5π in canvas coords
    const pointer = 1.5*Math.PI;
    const normalized = (pointer - angle) % (2*Math.PI);
    const a = normalized < 0 ? normalized + 2*Math.PI : normalized;

    for (const s of segments){
      if (a >= s.start && a < s.end) return s.opt;
    }
    return segments[0]?.opt || null;
  }

  function stop(){
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    velocity = 0;
  }

  function spin(canvas, segments, onDone){
    if (!canvas || !segments?.length) return;
    if (velocity > 0) return;

    // Anticipation bounce
    velocity = -0.05;
    const anticipate = () => {
      velocity += 0.02;
      angle += velocity;
      draw(canvas, segments);
      if (velocity < 0.5) {
        rafId = requestAnimationFrame(anticipate);
      } else {
        // Main spin with easing
        velocity = Math.random() * 0.55 + 0.65;
        const tick = ()=>{
          velocity *= 0.982; // smoother deceleration
          angle += velocity;
          draw(canvas, segments);

          if (velocity > 0.001){
            rafId = requestAnimationFrame(tick);
          } else {
            velocity = 0;
            rafId = null;
            const winner = pickWinner(segments);
            onDone && onDone(winner);
          }
        };
        rafId = requestAnimationFrame(tick);
      }
    };
    rafId = requestAnimationFrame(anticipate);
  }
  function reset(){ stop(); angle = 0; }

  return { computeSegments, draw, spin, reset };
})();

function renderGen() {
  const left = $("#leftPane"), main = $("#mainPane"), right = $("#rightPane");
  left.innerHTML = main.innerHTML = right.innerHTML = "";

  const gen = state.generator;
  const steps = gen.steps || [];
  const cur = steps[gen.currentStepIndex] || null;

  // Left: steps list
  left.appendChild(el("div",{class:"col"}, [
    el("div",{class:"muted", text:"Character Generator"}),
    el("div",{class:"muted", text:"Soft reroll: ROLL 3 → pick 1"}),
    el("div",{class:"muted", html:`Undo: <span class="kbd">UNDO</span>`}),
    el("div",{class:"hr"})
  ]));
  const stepList = el("div",{class:"list"});
  steps.forEach((s, idx)=>{
    const active = idx===gen.currentStepIndex;
    stepList.appendChild(el("div",{class:"item"+(active?" active":""), onclick: ()=>{
      gen.currentStepIndex = idx;
      gen.candidates = null;
      saveState(); renderPreserveFocus();
    }}, [
      el("div",{class:"row", style:"justify-content:space-between; align-items:center;"}, [
        el("div",{style:"flex:1", text:s.name}),
        (gen.locks[s.id] ? el("div",{class:"badge", text:"LOCKED"}) : null)
      ].filter(Boolean)),
      el("div",{class:"muted", text:`${gen.locks[s.id] ? ("locked: " + gen.locks[s.id].label + " • ") : ""}source: ${s.source}`})
    ]));
  });
  left.appendChild(stepList);

  // Right: run controls, locks, history, writing prompt
  right.appendChild(renderRunControls());
  right.appendChild(renderLocksPanel());
  right.appendChild(renderHistoryPanel());
  right.appendChild(renderRunDraftPanel());
  right.appendChild(renderInspirationPanel(cur));

  if (!cur) {
    main.appendChild(el("div",{class:"card"}, [el("div",{text:"No steps yet."})]));
    return;
  }

  const contextTags = contextTagIdsFromLocks(gen);
  const options = getStepOptions(cur);
  const hasOptions = options.length > 0;

  const stepNum = gen.currentStepIndex + 1;
  const pct = steps.length ? Math.round((stepNum / steps.length) * 100) : 0;
  const next = steps[gen.currentStepIndex + 1] || null;
  const lockedPairs = steps.filter(s=>gen.locks[s.id]).map(s=>({ name: s.name, label: gen.locks[s.id].label }));

  // Main: step controls
  const btnSpin = el("button",{class:"primary", text:"SPIN", onclick: ()=>{
    if (!hasOptions) return;
    pushUndo(gen);
    const wp = weightedPick(options, gen, contextTags);
    const picked = wp.picked;
    const res = normalizeResult(cur, picked, gen, contextTags, wp.explainFor(wp.index));
    gen.lastResult = res;
    gen.candidates = null;
    gen.history.unshift({ at: nowISO(), stepName: cur.name, resultLabel: res.label, kind:"spin" });
    saveState(); renderPreserveFocus();
  }});

  const btnRoll3 = el("button",{text:`ROLL ${gen.rules.softRollCount} (pick 1)`, onclick: ()=>{
    if (!hasOptions) return;
    pushUndo(gen);
    gen.candidates = Roller.softRollDetailed(options, gen, contextTags, gen.rules.softRollCount)
      .map(x => normalizeResult(cur, x.picked, gen, contextTags, x.explain));
    gen.lastResult = null;
    saveState(); renderPreserveFocus();
  }});

  const btnUndo = el("button",{class:"ghost", text:"UNDO", onclick: ()=>{
    undo(gen);
    saveState(); renderPreserveFocus();
  }});

  const btnLock = el("button",{text:"LOCK + Next", onclick: ()=>{
    if (!gen.lastResult) return;
    pushUndo(gen);
    gen.locks[cur.id] = deep(gen.lastResult);
    gen.currentStepIndex = clamp(gen.currentStepIndex + 1, 0, steps.length-1);
    gen.candidates = null;
    gen.lastResult = null;
    saveState(); renderPreserveFocus();
  }});

  // Optional: animated weighted wheel (visual)
  const btnWheelSpin = el("button",{class:"primary", text:"SPIN WHEEL", onclick: ()=>{
    if (!state.quant.visualWheel) return;
    if (!hasOptions) return;
    pushUndo(gen);

    const w = Roller.computeWeights(options, gen, contextTags);
    const segs = Wheel.computeSegments(options, w.weights);

    const canvas = document.getElementById("wheelCanvas");
    if (canvas) {
      Wheel.reset();
      Wheel.draw(canvas, segs);
      Wheel.spin(canvas, segs, (winner)=>{
        const winnerIdx = options.indexOf(winner);
        const res = normalizeResult(cur, winner, gen, contextTags, w.explainFor(winnerIdx));
        gen.lastResult = res;
        gen.candidates = null;
        gen.history.unshift({ at: nowISO(), stepName: cur.name, resultLabel: res.label, kind:"wheel" });
        saveState(); renderPreserveFocus();
      });
    } else {
      // fallback: normal pick if canvas missing
      const wp2 = Roller.pickWeighted(options, gen, contextTags);
      const res = normalizeResult(cur, wp2.picked, gen, contextTags, wp2.explainFor(wp2.index));
      gen.lastResult = res;
      gen.candidates = null;
      gen.history.unshift({ at: nowISO(), stepName: cur.name, resultLabel: res.label, kind:"spin" });
      saveState(); renderPreserveFocus();
    }
  }});


  // Disable roll controls if no options
  btnSpin.disabled = !hasOptions;
  btnWheelSpin.disabled = (!hasOptions) || (!state.quant.visualWheel);
  btnRoll3.disabled = !hasOptions;

  // Pick dropdown (dev / cheat)
  const pickSel = el("select",{id:`pick-${cur.id}`});
  pickSel.appendChild(el("option",{value:"", text:"PICK (dev)…"}));
  options.slice().sort((a,b)=>a.label.localeCompare(b.label)).forEach(o=>{
    const val = (o.refId || o.id) + "::" + o.label;
    pickSel.appendChild(el("option",{value: val, text: o.label}));
  });
  const btnPick = el("button",{text:"Pick", onclick: ()=>{
    if (!hasOptions) return;
    if (!pickSel.value) return;
    pushUndo(gen);
    const [ref, label] = pickSel.value.split("::");
    const chosen = options.find(o => (o.refId===ref) || (o.id===ref && o.label===label) || (o.label===label));
    const res = normalizeResult(cur, chosen || {label}, gen, contextTags, null);
    gen.lastResult = res;
    gen.candidates = null;
    gen.history.unshift({ at: nowISO(), stepName: cur.name, resultLabel: res.label, kind:"pick" });
    saveState(); renderPreserveFocus();
  }});

  // Disable dev pick if no options
  pickSel.disabled = !hasOptions;
  btnPick.disabled = !hasOptions;

  main.appendChild(el("div",{class:"card"}, [
    el("div",{class:"row", style:"justify-content:space-between; align-items:flex-start; gap:14px;"}, [
      el("div",{class:"col", style:"flex:1; min-width:220px;"}, [
        el("div",{class:"muted", text:`Step ${stepNum} of ${steps.length}`}),
        el("div",{style:"font-size:22px; font-weight:800", text: cur.name}),
        el("div",{class:"muted", text:`source: ${cur.source} • options: ${options.length} • context tags: ${contextTags.length}`}),
        el("div",{class:"progress", style:"margin-top:8px;"}, [
          el("div",{class:"progressFill", style:`width:${pct}%`})
        ]),
        el("div",{class:"muted", style:"margin-top:6px;", text: next ? `Next: ${next.name}` : "Next: (end)"})
      ]),
      el("div",{class:"col", style:"min-width:220px; align-items:flex-end;"}, [
        el("div",{class:"actions"}, [ (state.quant.visualWheel?btnWheelSpin:null), btnSpin, btnRoll3, btnUndo, btnLock ].filter(Boolean)),
        el("div",{class:"row", style:"width:100%; justify-content:flex-end; margin-top:8px;"}, [
          el("div",{style:"flex:1; min-width:180px; max-width:260px;"}, [pickSel]),
          btnPick
        ])
      ])
    ]),
    el("div",{class:"hr"}),
    el("div",{class:"muted", text:"Locked context (so far)"}),
    (lockedPairs.length
      ? el("div",{class:"chips"}, lockedPairs.map(p=>el("div",{class:"chip", text:`${p.name}: ${p.label}`})))
      : el("div",{class:"muted", text:"(none yet)"}))
  ]));



  if (state.quant.visualWheel) {
    const wpPreview = Roller.computeWeights(options, gen, contextTags);
    const segs = Wheel.computeSegments(options, wpPreview.weights);
    const canvas = el("canvas",{id:"wheelCanvas", width:380, height:380});
    const container = el("div",{class:"card", style:"text-align:center; position:relative;"},[
      el("div",{style:"position:absolute; top:12px; left:50%; transform:translateX(-50%); z-index:5; font-size:22px;", text:"▼"}),
      canvas,
      el("div",{class:"muted", style:"margin-top:8px;", text:"Weighted wheel: slice size reflects weight (synergy/conflict + rarity)."})
    ]);
    main.appendChild(container);
    Wheel.reset();
    Wheel.draw(canvas, segs);
  }
  if (!hasOptions) {
    main.appendChild(el("div",{class:"card"}, [
      el("div",{text:"No options for this step yet."}),
      el("div",{class:"muted", text:"Library step? Create entries under World. Manual step? Add options in the Step editor below."})
    ]));
  }

  // Result area
  main.appendChild(renderResultArea(cur, options, contextTags));

  // Follow-up questions (inspiration)
  main.appendChild(renderFollowUps(cur));

  // Step editor
  main.appendChild(renderStepEditor(cur));
}

function renderRunControls() {
  const gen = state.generator;
  const steps = gen.steps || [];
  const card = el("div",{class:"card"}, [
    el("div",{class:"row"}, [
      el("div",{text:"Run controls"}),
      el("div",{class:"muted", text:"(build then commit)"})
    ]),
  ]);

  const chk = el("input",{type:"checkbox"});
  chk.checked = !!gen.rules.explainWeights;
  chk.onchange = ()=>{ gen.rules.explainWeights = chk.checked; saveState(); renderPreserveFocus(); };

  const btnReset = el("button",{class:"danger", text:"Reset run", onclick: ()=>{
    if (!confirm("Clear locks + history?")) return;
    gen.currentStepIndex = 0;
    gen.lastResult = null;
    gen.candidates = null;
    gen.history = [];
    gen.locks = {};
    gen.undoStack = [];
    gen.run = {draft:""};
    saveState(); renderPreserveFocus();
  }});

  const btnCommit = el("button",{class:"primary", text:"Commit Character", onclick: ()=>{
    const c = seedCharacter(locksName(gen));
    // Apply refs from locks
    const classStep = steps.find(s=>s.source==="library:class");
    const magicStep = steps.find(s=>s.source==="library:magic_school");
    if (classStep && gen.locks[classStep.id]?.refId) c.classId = gen.locks[classStep.id].refId;
    if (magicStep && gen.locks[magicStep.id]?.refId) c.magicSchoolId = gen.locks[magicStep.id].refId;

    // Character tags = union of lock tags (+ entity tags)
    const tags = new Set();
    for (const v of Object.values(gen.locks||{})) {
      (v.tagIds||[]).forEach(t=>tags.add(t));
      if (v.refId) (entityById(v.refId)?.tagIds||[]).forEach(t=>tags.add(t));
    }
    c.tagIds = Array.from(tags);

    // Put the run draft into character draft
    c.draft = gen.run?.draft || "";
    c.notes = `Generated on ${new Date().toLocaleString()}`;
    c.updatedAt = nowISO();

    state.characters.list.unshift(c);
    state.characters.selectedId = c.id;
    state.ui.tab = "chars";
    saveState(); renderPreserveFocus();
  }});

  card.appendChild(el("label",{class:"row", style:"gap:8px"}, [chk, el("span",{text:"Explain weights"})]));
  card.appendChild(el("div",{class:"row"}, [btnReset, btnCommit]));
  return card;
}

function renderLocksPanel() {
  const gen = state.generator;
  const steps = gen.steps || [];
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{text:"Locked results"}));
  const locks = gen.locks || {};
  const keys = Object.keys(locks);
  if (!keys.length) {
    card.appendChild(el("div",{class:"muted", text:"No locks yet. Lock results to build a coherent character."}));
    return card;
  }
  keys.forEach(stepId=>{
    const step = steps.find(s=>s.id===stepId);
    const v = locks[stepId];
    card.appendChild(el("div",{class:"item"}, [
      el("div",{class:"row"}, [
        el("div",{style:"flex:1"}, [
          el("div",{text:`${step ? step.name : "(step)"}`}),
          el("div",{class:"muted", text:v.label})
        ]),
        el("button",{class:"danger small", text:"Unlock", onclick: ()=>{
          pushUndo(gen);
          delete gen.locks[stepId];
          saveState(); renderPreserveFocus();
        }})
      ]),
      v.why ? el("div",{class:"muted", text:v.why}) : el("div"),
      (v.tagIds?.length ? el("div",{class:"muted", text:"tags: " + v.tagIds.slice(0,8).map(tagName).join(", ")}) : el("div"))
    ]));
  });
  return card;
}

function renderHistoryPanel() {
  const gen = state.generator;
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{text:"Run history"}));
  const h = gen.history || [];
  if (!h.length) { card.appendChild(el("div",{class:"muted", text:"No history yet."})); return card; }
  h.slice(0,30).forEach(x=>{
    card.appendChild(el("div",{class:"item"}, [
      el("div",{text:`${x.stepName}: ${x.resultLabel}`}),
      el("div",{class:"muted", text:`${x.kind || ""} • ${x.at}`})
    ]));
  });
  return card;
}

function renderRunDraftPanel() {
  const gen = state.generator;
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"}, [
    el("div",{text:"Draft box"}),
    el("div",{class:"muted", text:"(write while you roll)"})
  ]));
  const ta = el("textarea",{id:"run-draft"}, [gen.run?.draft || ""]);
  ta.oninput = (ev)=>{ gen.run.draft = ev.target.value; saveState(); };
  card.appendChild(ta);
  return card;
}


/** -------------------- INSPIRATION PANEL (Dynamic Prompts) -------------------- */
function hashStrFNV1a(str) {
  let h = 2166136261;
  for (let i=0;i<str.length;i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0);
}
// mulberry32 PRNG
function makeRng(seed) {
  let a = seed >>> 0;
  return function() {
    a += 0x6D2B79F5;
    let t = a;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function pickOne(arr, rng) {
  if (!arr?.length) return null;
  return arr[Math.floor(rng() * arr.length)];
}
function tagName(id) {
  const t = state.index.tags.find(x=>x.id===id);
  return t ? t.name : "tag";
}
function entitySnippet(ent) {
  if (!ent) return "";
  const fields = ent.fields || {};
  const candidates = [
    fields.description, fields.notes, fields.hook, fields.role, fields.vibe, fields.legend, fields.effect, fields.training
  ].filter(Boolean).map(s=>String(s).trim()).filter(Boolean);
  if (!candidates.length) return "";
  const s = candidates[0];
  return s.length > 140 ? (s.slice(0, 140).trim() + "…") : s;
}
function conflictPairs(optTags, ctxTags) {
  const ctx = new Set(ctxTags || []);
  const opt = new Set(optTags || []);
  const pairs = [];
  for (const pair of (state.index.tagConflicts || [])) {
    const a = pair.a, b = pair.b;
    if ((opt.has(a) && ctx.has(b)) || (opt.has(b) && ctx.has(a))) {
      pairs.push([a,b]);
    }
  }
  return pairs;
}

// Conflicts within a single tag set (useful for warnings in editors)
function internalConflictPairs(tagIds) {
  const set = new Set(tagIds || []);
  const pairs = [];
  for (const pair of (state.index.tagConflicts || [])) {
    const a = pair.a, b = pair.b;
    if (set.has(a) && set.has(b)) pairs.push([a,b]);
  }
  return pairs;
}

function renderConflictWarning(tagIds, opts={}) {
  const pairs = internalConflictPairs(tagIds);
  if (!pairs.length) return el("div");
  const maxShow = opts.maxShow ?? 3;
  const shown = pairs.slice(0, maxShow).map(([a,b])=>`${tagName(a)} ↔ ${tagName(b)}`);
  const more = pairs.length > maxShow ? ` +${pairs.length-maxShow} more` : "";

  const resolveBtn = el("button", {class:"small", text:"Suggest resolution", onclick: () => {
    const suggestions = pairs.map(([a,b]) => {
      return `Remove either "${tagName(a)}" or "${tagName(b)}"`;
    });
    alert("Conflict suggestions:\n\n" + suggestions.join("\n"));
  }});

  return el("div",{class:"card", style:"padding:10px; border-left:4px solid #f59e0b;"},[
    el("div",{style:"font-weight:700;", text:"⚠️ Conflicting tags"}),
    el("div",{class:"muted", style:"margin-top:4px;", text: shown.join(" • ") + more}),
    el("div",{class:"muted", style:"margin-top:6px;", text:"This doesn't break anything — it's a signal that the concept may want a justification."}),
    el("div", {class:"row", style:"margin-top:8px"}, [resolveBtn])
  ]);
}

function generateInspirationPrompts(gen, curStep, focus) {
  const steps = gen.steps || [];
  const locks = gen.locks || {};
  const ctxTags = contextTagIdsFromLocks(gen);
  const focusTags = focus.tagIds || [];

  const overlap = focusTags.filter(t=>ctxTags.includes(t));
  const conflicts = conflictPairs(focusTags, ctxTags);

  // Try to identify race/class locks for flavor prompts
  const raceStep = steps.find(s=>s.name.toLowerCase().includes("race"));
  const classStep = steps.find(s=>s.name.toLowerCase().includes("class")) || steps.find(s=>s.source==="library:class");
  const race = raceStep && locks[raceStep.id] ? locks[raceStep.id].label : null;
  const cls = classStep && locks[classStep.id] ? locks[classStep.id].label : null;

  const focusEnt = focus.refId ? entityById(focus.refId) : null;
  const focusSnippet = entitySnippet(focusEnt);
  const focusName = focus.label || "this";

  const nonce = Number(gen.run?._inspNonce || 0);
  const seedStr = JSON.stringify({ step: curStep?.id, focus: focus.label, locks: Object.values(locks).map(x=>x.label), tags: focusTags.slice().sort(), nonce });
  const rng = makeRng(hashStrFNV1a(seedStr));

  const prompts = [];

  // 1) Identity / training prompts
  if (race && cls) {
    prompts.push(`As a ${race} ${cls}, what did they have to unlearn to make "${focusName}" work for them?`);
  } else if (race) {
    prompts.push(`What about being ${race} changes how "${focusName}" looks, feels, or is perceived by others?`);
  } else if (cls) {
    prompts.push(`What is the ${cls}-specific “rule of thumb” that makes "${focusName}" succeed when others fail?`);
  } else {
    prompts.push(`What’s the first impression someone gets when they witness "${focusName}" up close?`);
  }

  // 2) Tag overlap prompt
  if (overlap.length) {
    const t = pickOne(overlap, rng);
    prompts.push(`The shared theme "${tagName(t)}" ties this to earlier choices. What is the *connecting detail* that makes it feel inevitable?`);
  } else {
    prompts.push(`How does "${focusName}" unexpectedly connect to one earlier locked choice (race/class/magic/etc.)?`);
  }

  // 3) Conflict prompt
  if (conflicts.length) {
    const [a,b] = pickOne(conflicts, rng);
    prompts.push(`There’s tension between "${tagName(a)}" and "${tagName(b)}". What’s the cost *in effort or attention* to reconcile them?`);
  } else {
    prompts.push(`What is the built-in limitation of "${focusName}" that keeps it from solving *everything*?`);
  }

  // 4) Concrete sensory + signature detail prompt
  prompts.push(`Describe "${focusName}" with one sensory anchor (sound/smell/texture/light) and one signature detail people remember.`);

  // 5) Wandering-Inn-ish growth/evolution prompt
  const stepName = (curStep?.name || "").toLowerCase();
  const isSkillish = stepName.includes("skill") || focusTags.some(t=>["martial","magic","stealth","scouting","crafting"].includes((tagName(t)||"").toLowerCase()));
  if (isSkillish) {
    prompts.push(`If "${focusName}" evolves through practice, what changes first: speed, precision, scope, subtlety, or autonomy—and what triggers that change?`);
  } else {
    prompts.push(`If "${focusName}" becomes central to their story, what *future escalation* would feel earned rather than random?`);
  }

  // 6) Library-snippet prompt (if we have text)
  if (focusSnippet) {
    prompts.push(`Given: “${focusSnippet}” — what personal twist turns this from generic into *theirs*?`);
  } else {
    prompts.push(`Write a one-sentence “personal doctrine” that explains why they chose "${focusName}" (or why it chose them).`);
  }

  // Keep it tight: return 6–7 prompts
  return prompts.slice(0, 7);
}
function appendToDraft(text) {
  const gen = state.generator;
  gen.run = gen.run || { draft: "" };
  const cur = gen.run.draft || "";
  gen.run.draft = (cur ? (cur + "\n\n") : "") + text;
  saveState();
  renderPreserveFocus();
}
function renderInspirationPanel(curStep) {
  const gen = state.generator;
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"}, [
    el("div",{text:"Inspiration"}),
    el("div",{class:"muted", text:"(context-aware prompts)"})
  ]));

  const focus = gen.lastResult || null;
  if (!focus) {
    card.appendChild(el("div",{class:"muted", text:"Roll an outcome (or pick a soft reroll candidate) to generate prompts."}));
    const btn = el("button",{class:"ghost", text:"Regenerate (after roll)", onclick: ()=>{
      gen.run = gen.run || { draft:"" };
      gen.run._inspNonce = (gen.run._inspNonce||0)+1;
      saveState(); renderPreserveFocus();
    }});
    card.appendChild(el("div",{class:"row"}, [btn]));
    return card;
  }

  const prompts = generateInspirationPrompts(gen, curStep, focus);

  prompts.forEach((p, i)=>{
    card.appendChild(el("div",{class:"item"}, [
      el("div",{style:"white-space:pre-wrap", text:p}),
      el("div",{class:"row", style:"justify-content:flex-end; margin-top:8px;"}, [
        el("button",{class:"ghost", text:"Send to Draft", onclick: ()=>appendToDraft(p)}),
        el("button",{text:"Answer", onclick: ()=>appendToDraft(`### Prompt
${p}

`)})
      ])
    ]));
  });

  const btnReg = el("button",{class:"ghost", text:"Regenerate", onclick: ()=>{
    gen.run = gen.run || { draft:"" };
    gen.run._inspNonce = (gen.run._inspNonce||0)+1;
    saveState(); renderPreserveFocus();
  }});
  card.appendChild(el("div",{class:"row"}, [btnReg]));
  return card;
}


function renderResultArea(step, options, contextTags) {
  const gen = state.generator;
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"muted", text:"Outcome"}));

  if (gen.candidates?.length) {
    card.appendChild(el("div",{text:"Soft reroll: pick one"}));
    gen.candidates.forEach((c, idx)=>{
      card.appendChild(el("div",{class:"item"}, [
        el("div",{class:"row"}, [
          el("div",{style:"flex:1; font-weight:800", text:c.label}),
          el("button",{class:"primary small", text:"Pick this", onclick: ()=>{
            pushUndo(gen);
            gen.lastResult = c;
            gen.candidates = null;
            gen.history.unshift({ at: nowISO(), stepName: step.name, resultLabel: c.label, kind:"soft-pick" });
            saveState(); renderPreserveFocus();
          }}),
          el("button",{class:"danger small", text:"Remove", onclick: ()=>{
            pushUndo(gen);
            gen.candidates.splice(idx,1);
            if (!gen.candidates.length) gen.candidates = null;
            saveState(); renderPreserveFocus();
          }})
        ]),
        c.why ? el("div",{class:"muted", text:c.why}) : el("div"),
        (c.tagIds?.length ? el("div",{class:"muted", text:"tags: " + c.tagIds.slice(0,8).map(tagName).join(", ")}) : el("div"))
      ]));
    });
    card.appendChild(el("button",{text:"Cancel offers", onclick: ()=>{
      pushUndo(gen);
      gen.candidates = null;
      saveState(); renderPreserveFocus();
    }}));
    return card;
  }

  if (!gen.lastResult) {
    card.appendChild(el("div",{class:"muted", text:"No result yet. Spin or roll 3."}));
    return card;
  }

  const r = gen.lastResult;
  card.appendChild(el("div",{style:"font-size:18px; font-weight:900", text:r.label}));
  if (r.why) card.appendChild(el("div",{class:"muted", text:r.why}));
  if (r.tagIds?.length) card.appendChild(el("div",{class:"muted", text:"tags: " + r.tagIds.slice(0,8).map(tagName).join(", ")}));

  // If library-backed, show a quick snippet
  if (r.refId) {
    const ent = entityById(r.refId);
    if (ent) {
      const tpl = state.index.templates[ent.typeId] || [];
      const firstLong = tpl.find(x=>x.kind==="textarea")?.key || null;
      const snippet = firstLong ? (ent.fields?.[firstLong] || "") : "";
      if (snippet) card.appendChild(el("div",{class:"muted", text:snippet.slice(0,220)}));
      card.appendChild(el("button",{text:"Open in World", onclick: ()=>{
        state.world.filter.typeId = ent.typeId;
        state.world.selectedEntityId = ent.id;
        state.ui.tab = "world";
        saveState(); renderPreserveFocus();
      }}));
    }
  }

  return card;
}

function renderFollowUps(step) {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{text:"Follow-up prompts"}));
  card.appendChild(el("div",{class:"muted", text:"These are small questions to keep the roll inspiring without forcing mandatory fields."}));

  const promptsByStep = {
    "Race": [
      "What stereotype about this race is wrong for this character?",
      "What physical tell gives away their upbringing?",
      "What do they envy about other races?"
    ],
    "Home": [
      "What did they learn there that still helps them daily?",
      "Who would recognize them instantly back home?",
      "What smell does 'home' bring back?"
    ],
    "Class": [
      "How did they first realize they were good at this?",
      "What does this class look like at low level (humble, practical)?",
      "What would make their class evolve over time?"
    ],
    "Magic School": [
      "What is the cost of using this magic (fatigue, social, bodily)?",
      "What would mastery change: efficiency, scope, or weird side effects?",
      "What does this magic look like when it fails?"
    ],
    "Trait": [
      "Where did this trait come from: fear, love, pride, necessity?",
      "What is the trait’s ‘shadow’ version when stressed?"
    ],
    "Immediate Goal": [
      "What would success look like in 48 hours?",
      "What is the first obstacle they’ll hit?"
    ]
  };

  const list = promptsByStep[step.name] || [
    "What detail would make this feel specific?",
    "What is the hidden cost?",
    "What might evolve if practiced long enough?"
  ];

  const ul = el("div",{class:"list"});
  list.forEach(q => ul.appendChild(el("div",{class:"item"}, [el("div",{text:q})])));
  card.appendChild(ul);
  return card;
}

function renderStepEditor(step) {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{class:"row"}, [
    el("div",{text:"Step editor"}),
    el("div",{class:"muted", text:"(add options; tag them; weights; library-backed steps edit via World tab)"})
  ]));

  // Step order and add/remove steps
  const gen = state.generator;
  const idx = gen.steps.findIndex(s=>s.id===step.id);

  const btnUp = el("button",{class:"small", text:"↑", onclick: ()=>{
    if (idx<=0) return;
    const tmp = gen.steps[idx-1]; gen.steps[idx-1] = gen.steps[idx]; gen.steps[idx]=tmp;
    saveState(); renderPreserveFocus();
  }});
  const btnDown = el("button",{class:"small", text:"↓", onclick: ()=>{
    if (idx<0 || idx>=gen.steps.length-1) return;
    const tmp = gen.steps[idx+1]; gen.steps[idx+1] = gen.steps[idx]; gen.steps[idx]=tmp;
    saveState(); renderPreserveFocus();
  }});
  const btnRemoveStep = el("button",{class:"danger small", text:"Remove step", onclick: ()=>{
    if (!confirm(`Remove step "${step.name}"?`)) return;
    gen.steps = gen.steps.filter(s=>s.id!==step.id);
    gen.currentStepIndex = clamp(gen.currentStepIndex, 0, gen.steps.length-1);
    saveState(); renderPreserveFocus();
  }});

  const stepName = el("input",{id:`step-name-${step.id}`, value: step.name});
  stepName.oninput = (ev)=>{ step.name = ev.target.value; saveState(); };

  const srcSel = el("select",{id:`step-src-${step.id}`});
  ["manual","library:class","library:magic_school","library:skill"].forEach(s=>{
    srcSel.appendChild(el("option",{value:s, text:s}));
  });
  srcSel.value = step.source;
  srcSel.onchange = ()=>{ step.source = srcSel.value; saveState(); renderPreserveFocus(); };

  card.appendChild(el("div",{class:"row"}, [
    el("div",{class:"col", style:"flex:1"}, [el("label",{text:"Step name"}), stepName]),
    el("div",{class:"col", style:"width:220px"}, [el("label",{text:"Source"}), srcSel]),
    btnUp, btnDown, btnRemoveStep
  ]));

  // Add new step block
  const newStepName = el("input",{placeholder:"New step name (e.g., Background)"});
  const newStepSrc = el("select");
  ["manual","library:class","library:magic_school","library:skill"].forEach(s=>newStepSrc.appendChild(el("option",{value:s, text:s})));
  const btnAddStep = el("button",{class:"primary", text:"Add step", onclick: ()=>{
    const n = newStepName.value.trim();
    if (!n) return;
    gen.steps.push(seedStep(n, newStepSrc.value, []));
    newStepName.value = "";
    saveState(); renderPreserveFocus();
  }});
  card.appendChild(el("div",{class:"createBox"}, [
    el("div",{class:"title", text:"CREATE NEW STEP"}),
    el("div",{class:"muted", text:"(optional; keep it character-first for now)"}),
    el("div",{class:"row"}, [newStepName, newStepSrc, btnAddStep])
  ]));

  card.appendChild(el("div",{class:"hr"}));

  // Manual options editor
  if (step.source === "manual") {
    const list = el("div",{class:"list"});
    (step.options||[]).forEach((o, oi)=>{
      const row = el("div",{class:"item"});
      const lab = el("input",{id:`opt-label-${step.id}-${o.id}`, value:o.label});
      lab.oninput = (ev)=>{ o.label = ev.target.value; saveState(); };
      const w = el("input",{id:`opt-w-${step.id}-${o.id}`, value:String(o.baseWeight ?? 1)});
      w.oninput = (ev)=>{ o.baseWeight = Number(ev.target.value)||0; saveState(); };

      const btnDel = el("button",{class:"danger small", text:"Delete", onclick: ()=>{
        step.options.splice(oi,1);
        saveState(); renderPreserveFocus();
      }});

      row.appendChild(el("div",{class:"grid2"}, [
        el("div",{class:"col"}, [el("label",{text:"Label"}), lab]),
        el("div",{class:"col"}, [el("label",{text:"Base weight"}), w]),
      ]));

      // tags
      o.tagIds = o.tagIds || [];
      row.appendChild(el("div",{class:"muted", text:"Tags"}));
      row.appendChild(renderTagChips(o.tagIds, (tid)=>{
        const i = o.tagIds.indexOf(tid);
        if (i>=0) o.tagIds.splice(i,1); else o.tagIds.push(tid);
        saveState(); renderPreserveFocus();
      }, { showCreate:true }));

      row.appendChild(btnDel);
      list.appendChild(row);
    });
    if (!(step.options||[]).length) list.appendChild(el("div",{class:"muted", text:"No options yet."}));
    card.appendChild(list);

    // Create new option box (very visible)
    const newLab = el("input",{placeholder:"Option label (e.g., Half-Orc)"});
    const newW = el("input",{placeholder:"Base weight (e.g., 1.0)", value:"1.0"});
    const btnAdd = el("button",{class:"primary", text:"Add option", onclick: ()=>{
      const lab = newLab.value.trim();
      if (!lab) return;
      step.options = step.options || [];
      step.options.push({ id: uid(), label: lab, baseWeight: Number(newW.value)||1, tagIds: [], notes:"" });
      newLab.value = "";
      saveState(); renderPreserveFocus();
    }});
    card.appendChild(el("div",{class:"createBox"}, [
      el("div",{class:"title", text:"CREATE NEW OPTION"}),
      el("div",{class:"muted", text:"(tag it for synergy; example: race=orc, domain=martial)"}),
      el("div",{class:"row"}, [newLab, newW, btnAdd])
    ]));
  } else {
    // Library steps: create a new library entry + nudge to tag it
    const typeId = step.source.split(":")[1];
    const btnNew = el("button",{class:"primary", text:`Create new ${typeId}`, onclick: ()=>{
      const e = seedEntity(typeId, "Untitled", {}, []);
      state.world.entities.unshift(e);
      state.world.filter.typeId = typeId;
      state.world.selectedEntityId = e.id;
      state.ui.tab = "world";
      saveState(); renderPreserveFocus();
    }});
    card.appendChild(el("div",{class:"createBox"}, [
      el("div",{class:"title", text:`CREATE NEW ${typeId.toUpperCase()} ENTRY`}),
      el("div",{class:"muted", text:"Library steps pull options from World. Create entries there, then come back here to roll them."}),
      btnNew
    ]));
  }

  return card;
}

/** -------------------- INDEX TAB -------------------- */
/** -------------------- CREATE ENTRY WIZARD -------------------- */
function ensureWizard() {
  if (!state.ui) state.ui = { tab:"gen" };
  if (!state.ui.wizard) state.ui.wizard = deep(DEFAULT_WIZARD);
  // Ensure required keys exist (lightweight normalization)
  const w = state.ui.wizard;
  if (!w.typeId) w.typeId = "skill";
  if (!Array.isArray(w.tagIds)) w.tagIds = [];
  if (!w.facets) w.facets = deep(DEFAULT_WIZARD.facets);
  if (!w.fields) w.fields = {};
  if (w.quantProfileId === undefined) w.quantProfileId = null;
  return w;
}

function wizardToEntityPreview() {
  const w = ensureWizard();
  const fields = deep(w.fields || {});
  fields.__facets = deep(w.facets || {});
  if (w.quantProfileId) fields.quantProfileId = w.quantProfileId;
  if (w.notes) fields.notes = w.notes;
  return {
    id: "preview",
    typeId: w.typeId,
    name: w.name || "(unnamed)",
    tagIds: deep(w.tagIds || []),
    fields
  };
}

function commitWizardEntity(opts={}) {
  const w = ensureWizard();
  const name = (w.name || "").trim();
  if (!name) { alert("Please give it a name first."); return; }

  const fields = deep(w.fields || {});
  fields.__facets = deep(w.facets || {});
  if (w.quantProfileId) fields.quantProfileId = w.quantProfileId;
  if (w.notes) fields.notes = w.notes;

  const ent = seedEntity(w.typeId, name, fields, deep(w.tagIds || []));
  state.world.entities.unshift(ent);

  // Select and jump to World filtered view for this type
  state.world.filter.typeId = w.typeId;
  state.world.filter.text = "";
  state.world.filter.tags = [];
  state.world.selectedEntityId = ent.id;

  saveState();
  if (!opts.stay) setTab("world");
}

function renderCreate() {
  ensureWizard();
  const w = state.ui.wizard;

  const left = $("#leftPane"), main = $("#mainPane"), right = $("#rightPane");
  left.innerHTML = main.innerHTML = right.innerHTML = "";

  // LEFT: quick help + actions
  left.appendChild(el("div",{class:"card"},[
    el("div",{class:"row"},[
      el("div",{class:"col", style:"flex:1;"},[
        el("div",{class:"pill", text:"Create Entry Wizard"}),
        el("div",{class:"muted", text:"Fast intake for new races, skills, classes, monsters, etc. Generates a clean, rollable entity."})
      ]),
    ]),
    el("div",{class:"hr"}),
    el("div",{class:"row"},[
      el("button",{class:"primary", text:"Commit to World", onclick: commitWizardEntity}),
      el("button",{text:"Clear", onclick: ()=>{ state.ui.wizard = deep(DEFAULT_WIZARD); saveState(); renderPreserveFocus(); }}),
    ]),
    el("div",{class:"muted", style:"margin-top:8px;"},[
      el("div",{text:"Tip: keep fields optional. Tags + facets do most of the work."}),
      el("div",{text:"Quant Profile changes how numbers ‘mean’ in your world."}),
    ])
  ]));

  // MAIN: wizard form
  const card = el("div",{class:"card"});
  card.appendChild(el("h3",{text:"Create new entity"}));

  const typeSel = el("select");
  state.index.entityTypes.forEach(t=>{
    typeSel.appendChild(el("option",{value:t.id, text:t.name}));
  });
  typeSel.value = w.typeId;
  typeSel.onchange = () => {
    w.typeId = typeSel.value;
    // Keep name/tags; reset fields to template keys so it's not confusing
    const tmpl = state.index.templates[w.typeId] || [];
    const nextFields = {};
    tmpl.forEach(f=>{ if (w.fields && (f.key in w.fields)) nextFields[f.key]=w.fields[f.key]; else nextFields[f.key]=""; });
    w.fields = nextFields;
    saveState(); renderPreserveFocus();
  };

  const nameInp = el("input",{placeholder:"Name (required)", value: w.name || ""});
  nameInp.oninput = ()=>{ w.name = nameInp.value; saveState(); };

  // Quant profile selector
  const qpSel = el("select");
  qpSel.appendChild(el("option",{value:"", text:"World default"}));
  getQuantProfiles().forEach(p=>{
    qpSel.appendChild(el("option",{value:p.id, text:p.name}));
  });
  qpSel.value = w.quantProfileId || "";
  qpSel.onchange = ()=>{ w.quantProfileId = qpSel.value || null; saveState(); renderPreserveFocus(); };

  card.appendChild(el("div",{class:"grid2"},[
    el("div",{class:"col"},[
      el("label",{text:"Entity Type"}), typeSel,
    ]),
    el("div",{class:"col"},[
      el("label",{text:"Quant Profile"}), qpSel,
    ])
  ]));
  card.appendChild(el("div",{class:"col"},[
    el("label",{text:"Name"}), nameInp
  ]));

  // Tags
  card.appendChild(el("div",{class:"hr"}));
  card.appendChild(el("h4",{text:"Tags"}));
  const tagsUI = renderTagChips(w.tagIds, (id)=>{
    const i = w.tagIds.indexOf(id);
    if (i>=0) w.tagIds.splice(i,1); else w.tagIds.push(id);
    saveState(); renderPreserveFocus();
  }, { showCreate:true, createInputId:"wizAddTag" });
  card.appendChild(tagsUI);

  // Warn if wizard tag set has internal conflicts (helps justify weird combos)
  card.appendChild(renderConflictWarning(w.tagIds||[]));

  // Facets
  card.appendChild(el("div",{class:"hr"}));
  card.appendChild(el("h4",{text:"Facets (0–10)"}));

  const facetDefs = getFacetDefsForType(w.typeId);
  const facetKeys = facetDefs.map(d=>d.key);
  // ensure wizard has all keys
  for (const k of facetKeys){ if (w.facets[k]==null) w.facets[k]=0; }
  const facetGrid = el("div",{class:"grid3"});
  facetKeys.forEach(key=>{
    const sel = el("select");
    for (let i=0;i<=10;i++) sel.appendChild(el("option",{value:String(i), text: facetLabel(w.typeId, key, i)}));
    sel.value = String(w.facets?.[key] ?? 0);
    sel.onchange = ()=>{ w.facets[key] = Number(sel.value)||0; saveState(); renderPreserveFocus(); };

    facetGrid.appendChild(el("div",{class:"col"},[
      el("label",{text: key}),
      sel
    ]));
  });
  card.appendChild(facetGrid);

  // Template fields (optional)
  const tmpl = state.index.templates[w.typeId] || [];
  if (tmpl.length) {
    card.appendChild(el("div",{class:"hr"}));
    card.appendChild(el("h4",{text:"Fields (optional)"}));
    tmpl.forEach(f=>{
      const kind = f.kind || "text";
      const v = (w.fields && (f.key in w.fields)) ? w.fields[f.key] : "";
      const input = (kind==="textarea")
        ? el("textarea",{value:v})
        : el("input",{value:v});
      input.oninput = ()=>{ w.fields[f.key] = input.value; saveState(); };
      card.appendChild(el("div",{class:"col"},[
        el("label",{text:f.label || f.key}),
        input
      ]));
    });
  }

  // Notes
  card.appendChild(el("div",{class:"hr"}));
  const notes = el("textarea",{placeholder:"Notes (optional)", value: w.notes || ""});
  notes.oninput = ()=>{ w.notes = notes.value; saveState(); };
  card.appendChild(el("div",{class:"col"},[ el("label",{text:"Notes"}), notes ]));

  // Actions
  card.appendChild(el("div",{class:"row", style:"margin-top:8px;"},[
    el("button",{class:"primary", text:"Commit to World", onclick: commitWizardEntity}),
    el("button",{text:"Commit (stay here)", onclick: ()=>{ commitWizardEntity({stay:true}); }}),
  ]));

  main.appendChild(card);

  // RIGHT: computed quant + JSON preview
  const preview = wizardToEntityPreview();
  const Q = Quant.compute(preview);
  const tier = Quant.tierFromUsefulness(Q.usefulness, Q.facets.scope);

  right.appendChild(el("div",{class:"card"},[
    el("h3",{text:"Quantified preview"}),
    el("div",{class:"row"},[
      el("span",{class:"pill", text:`Tier: ${tier}`}),
      el("span",{class:"pill", text:`Rarity x${Q.rarityFactor.toFixed(2)}`}),
    ]),
    el("div",{class:"grid2"},[
      el("div",{class:"col"},[
        el("div",{class:"muted", text:"Potency Units"}),
        el("div",{text:String(Q.potencyUnits)})
      ]),
      el("div",{class:"col"},[
        el("div",{class:"muted", text:"Influence Units"}),
        el("div",{text:Q.influenceUnits.toFixed(2)})
      ]),
      el("div",{class:"col"},[
        el("div",{class:"muted", text:"Usefulness"}),
        el("div",{text:Q.usefulness.toFixed(1)})
      ]),
      el("div",{class:"col"},[
        el("div",{class:"muted", text:"Effort"}),
        el("div",{text:Q.effort.toFixed(1)})
      ]),
      el("div",{class:"col"},[
        el("div",{class:"muted", text:"Net Value"}),
        el("div",{text:Q.netValue.toFixed(1)})
      ]),
      el("div",{class:"col"},[
        el("div",{class:"muted", text:"Prestige"}),
        el("div",{text:Q.prestige.toFixed(1)})
      ]),
    ]),
    el("div",{class:"muted", style:"margin-top:8px;"},[
      el("div",{text:"Note: Scope affects Influence (reach), not Potency (strength)."}),
      el("div",{text:"Prestige affects roll rarity, not strength."}),
    ]),
  ]));

  const jsonCard = el("div",{class:"card"});
  jsonCard.appendChild(el("h3",{text:"JSON preview"}));
  const pre = el("pre",{class:"mono", style:"white-space:pre-wrap;word-break:break-word;max-height:340px;overflow:auto;"});
  pre.textContent = JSON.stringify({ entity: preview, quant: Q, tier }, null, 2);
  jsonCard.appendChild(pre);
  right.appendChild(jsonCard);
}


function ensureIntake() {
  if (!state.ui) state.ui = { tab:"gen" };
  if (!state.ui.intake) state.ui.intake = deep(DEFAULT_INTAKE);
  const it = state.ui.intake;
  if (!it.typeId) it.typeId = "skill";
  if (typeof it.includeTags !== "boolean") it.includeTags = true;
  if (typeof it.includeFacetSet !== "boolean") it.includeFacetSet = true;
  if (typeof it.includeQuantProfiles !== "boolean") it.includeQuantProfiles = false;
  if (typeof it.includeTemplates !== "boolean") it.includeTemplates = true;
  if (typeof it.generateCount !== "number") it.generateCount = 6;
  if (!it.richness) it.richness = "balanced";
  if (typeof it.aiJson !== "string") it.aiJson = "";
  if (!it.commitMode) it.commitMode = "create";
  if (!it.updateBehavior) it.updateBehavior = "merge";
  if (!Array.isArray(it.drafts)) it.drafts = [];
  return it;
}

function buildAIPromptForType(typeId, opts={}) {
  const type = byId(state.index.entityTypes, typeId);
  const typeName = type?.name || typeId;
  const includeTags = (opts.includeTags !== false);
  const includeFacetSet = (opts.includeFacetSet !== false);
  const includeQuantProfiles = !!opts.includeQuantProfiles;
  const includeTemplates = (opts.includeTemplates !== false);
  const richness = (opts.richness || "balanced");
  const wantCount = clamp(Number(opts.generateCount||6), 1, 30);

  const defs = (state.index.facetDefsByType?.[typeId] || []).filter(d=>d && d.enabled!==false);
  const canon = ["power","utility","reliability","scope","frequency","complexity","upkeep","access","rarity"];

  const facetLines = defs.length ? defs.map(d=>{
    const key = (d.key||"").trim();
    const mapsTo = (d.mapsTo||"").trim();
    const channel = mapsTo ? mapsTo : (canon.includes(key)? key : "");
    return `- ${key}${d.label?` ("${d.label}")`:""}${channel?`  mapsTo:${channel}`:""}  value: 0..10`;
  }).join("\n") : "- (no facets defined for this type)";

  // tags summary
  const cats = state.index.tagCategories || [];
  const tags = state.index.tags || [];
  const catToTags = {};
  tags.forEach(t=>{
    if (!t) return;
    (catToTags[t.categoryId] ||= []).push(t.name);
  });
  const tagLines = cats.map(c=>{
    const names = (catToTags[c.id]||[]);
    if (!names.length) return null;
    const sample = names.slice(0, 30).join(", ");
    const more = names.length>30 ? ` …(+${names.length-30} more)` : "";
    return `- ${c.name}: ${sample}${more}`;
  }).filter(Boolean).join("\n");

  // quant profile names
  const qps = (state.world.entities||[]).filter(e=>e.typeId==="quant_profile");
  const qpLine = qps.length ? qps.map(q=>q.name).slice(0, 12).join(", ") + (qps.length>12?` …(+${qps.length-12} more)`:"") : "(none)";

  // template fields
  const tmpl = (state.index.templates?.[typeId] || []);
  const templateLines = tmpl.length ? tmpl.map(f=>{
    const k = (f.key||"").trim();
    const lab = (f.label||"").trim();
    return `- ${k}${lab?` ("${lab}")`:""}`;
  }).join("\n") : "- (no template fields defined for this type)";

  const detailGuide = (()=>{
    if (richness==="short") return [
      "- Keep every text field to 1 sentence (max ~35 words).",
      "- Prefer punchy, concrete phrases over lore dumps."
    ].join("\n");
    if (richness==="rich") return [
      "- Description/summary: 3–7 sentences, vivid and specific.",
      "- Other text fields: 1–3 sentences each.",
      "- Still avoid long exposition; show hooks and texture."
    ].join("\n");
    return [
      "- Description/summary: 2–4 sentences.",
      "- Other text fields: 1–2 sentences each.",
      "- Concise but evocative."
    ].join("\n");
  })();

  const sections = [];
  sections.push(`You are generating new world entries for a fantasy setting database.`);
  sections.push(`Return ONLY valid JSON (no markdown, no commentary).`);
  sections.push(`\nGOAL:\nCreate exactly ${wantCount} "${typeName}" entries that fit the world's existing taxonomy.`);
  sections.push(`\nINPUT RULES:\n- Output JSON must match the schema below exactly.\n- All numeric facet values are integers 0..10 (clamp if unsure).\n- Use existing tags when possible. If you need a tag that doesn't exist, add it under "tagsToCreate".\n${detailGuide}`);

  if (includeTags) {
    sections.push(`\nWORLD TAGS (use these when relevant):\n${tagLines || "- (no tags found)"}`);
  } else {
    sections.push(`\nWORLD TAGS:\n- (omitted: prompt set to short mode — rely on your own tags or add under tagsToCreate)`);
  }

  if (includeFacetSet) {
    sections.push(`\nFACETS FOR TYPE "${typeId}":\n${facetLines}`);
  } else {
    sections.push(`\nFACETS FOR TYPE "${typeId}":\n- (omitted)`);
  }

  if (includeTemplates) {
    sections.push(`\nFIELDS / TEMPLATE (put these under fields, omit any you truly can't fill):\n${templateLines}`);
  }

  if (includeQuantProfiles) {
    sections.push(`\nQUANT PROFILES (optional):\n- If you want to target a specific quant profile, set "quantProfileName" to one of: ${qpLine}\n- Otherwise omit it.`);
  }

  sections.push(`\nOUTPUT SCHEMA:\n{\n  "tagsToCreate": [\n    {"name": "tag_name_lowercase", "category": "Category Name (existing or new)"}\n  ],\n  "entities": [\n    {\n      "typeId": "${typeId}",\n      "name": "short name",\n      "tags": ["tag_name_lowercase", "..."],\n      "fields": {\n        // include template keys as needed\n        "__facets": { "facetKey": 0, "...": 0 }\n      },\n      "quantProfileName": "optional"\n    }\n  ]\n}\n`);
  sections.push(`Now generate exactly ${wantCount} entities.`);

  return sections.join("\n");
}


function parseAIIntakeJSON(txt) {
  const raw = JSON.parse(txt);
  const wrap = (obj)=>({ tagsToCreate: [], entities: [] , ...obj});
  if (Array.isArray(raw)) return { tagsToCreate: [], entities: raw };
  if (raw && typeof raw === "object") return wrap(raw);
  throw new Error("JSON must be an object or an array of entities.");
}

function validateAndPreviewIntake(payload, opts) {
  const it = ensureIntake();
  const commitMode = (opts?.commitMode || it.commitMode || "create");
  const updateBehavior = (opts?.updateBehavior || it.updateBehavior || "merge");

  const preview = { newTags: [], entities: [], warnings: [], commitMode, updateBehavior };
  const tagsToCreate = Array.isArray(payload.tagsToCreate) ? payload.tagsToCreate : [];
  const entities = Array.isArray(payload.entities) ? payload.entities : [];

  // Build category name map
  const catByName = {};
  (state.index.tagCategories||[]).forEach(c=>{ if (c?.name) catByName[c.name.toLowerCase()] = c.id; });

  // Collect tag creations (do not mutate state yet)
  tagsToCreate.forEach(t=>{
    const name = (t?.name||"").trim().toLowerCase();
    const catName = (t?.category||"").trim();
    if (!name) return;
    preview.newTags.push({ name, categoryName: catName || "Unsorted" });
  });

  // Prepare a tag lookup by name (existing + toCreate)
  const tagIdByName = {};
  (state.index.tags||[]).forEach(t=>{ if (t?.name) tagIdByName[t.name.toLowerCase()] = t.id; });

  preview.newTags.forEach(nt=>{
    if (tagIdByName[nt.name]) return;
    // reserve placeholder id for preview
    tagIdByName[nt.name] = "__NEW__:" + nt.name;
  });

  // Validate entity types
  const validTypeIds = new Set((state.index.entityTypes||[]).map(t=>t.id));
  const seen = new Set();

  // quant profile by name mapping (for warnings)
  const qps = (state.world.entities||[]).filter(e=>e.typeId==="quant_profile");
  const qpByName = {};
  qps.forEach(q=>{ if (q?.name) qpByName[q.name.toLowerCase()] = q.id; });

  // existing entity lookup by type+name
  const existingByKey = {};
  (state.world.entities||[]).forEach(e=>{
    if (!e?.typeId || !e?.name) return;
    existingByKey[`${e.typeId}::${e.name.toLowerCase()}`] = e.id;
  });

  // allowed facet keys (per type) for warnings
  const allowedFacetKeysFor = (typeId)=>{
    const defs = (state.index.facetDefsByType?.[typeId] || []).filter(d=>d && d.enabled!==false);
    return new Set(defs.map(d=>(d.key||"").trim()).filter(Boolean));
  };

  // Entities preview
  entities.forEach((e, i)=>{
    if (!e || typeof e !== "object") return;
    const typeId = String(e.typeId||"").trim();
    const name = String(e.name||e.label||"").trim();
    if (!typeId || !name) {
      preview.warnings.push(`Entity #${i+1} missing typeId or name.`);
      return;
    }
    if (!validTypeIds.has(typeId)) {
      preview.warnings.push(`Unknown typeId "${typeId}" on entity "${name}". (Is that entity type defined in Index?)`);
    }

    const key = `${typeId}::${name.toLowerCase()}`;
    if (seen.has(key)) {
      preview.warnings.push(`Duplicate entity in intake payload: "${name}" (${typeId}).`);
    }
    seen.add(key);

    // tags
    const tagNames = (Array.isArray(e.tags)? e.tags : []).map(x=>String(x||"").trim().toLowerCase()).filter(Boolean);
    const tagIds = [];
    tagNames.forEach(n=>{
      const id = tagIdByName[n];
      if (id) tagIds.push(id);
      else preview.warnings.push(`Unknown tag "${n}" on entity "${name}" (add to tagsToCreate).`);
    });

    // fields + facets clamping
    const fields = (e.fields && typeof e.fields==="object") ? deep(e.fields) : {};
    if (!fields.__facets || typeof fields.__facets!=="object") fields.__facets = {};
    for (const k of Object.keys(fields.__facets)) {
      const v = fields.__facets[k];
      fields.__facets[k] = (v==="" || v==null) ? "" : clamp(Number(v), 0, 10);
      if (!Number.isFinite(Number(fields.__facets[k])) && fields.__facets[k] !== "") fields.__facets[k] = "";
    }

    // warn on unknown facet keys (for this type)
    const allowed = allowedFacetKeysFor(typeId);
    Object.keys(fields.__facets||{}).forEach(fk=>{
      if (allowed.size && !allowed.has(fk)) preview.warnings.push(`Facet "${fk}" is not in the facet set for type "${typeId}" (entity "${name}").`);
    });

    const qpn = (e.quantProfileName==null?"":String(e.quantProfileName).trim());
    if (qpn && !qpByName[qpn.toLowerCase()]) {
      preview.warnings.push(`Unknown quantProfileName "${qpn}" on "${name}" (will be ignored).`);
    }

    const matchId = existingByKey[key] || null;
    let action = "create";
    if (commitMode === "draft") action = "draft";
    else if (commitMode === "update") {
      action = matchId ? "update" : "create";
      if (!matchId) preview.warnings.push(`Update mode: "${name}" (${typeId}) not found; it will be created instead.`);
    } else { // create
      if (matchId) preview.warnings.push(`Create mode: "${name}" (${typeId}) already exists; committing will create a duplicate.`);
    }

    preview.entities.push({ typeId, name, tagNames, tagIds, fields, quantProfileName:qpn, matchId, action });
  });

  return preview;
}

function commitIntakePreview(preview, opts) {
  const it = ensureIntake();
  const commitMode = (opts?.commitMode || preview?.commitMode || it.commitMode || "create");
  const updateBehavior = (opts?.updateBehavior || preview?.updateBehavior || it.updateBehavior || "merge");

  if (commitMode === "draft") {
    toast("Draft mode: nothing committed. Use 'Save Draft'.");
    return;
  }

  // Create missing categories if referenced by name
  const catByName = {};
  (state.index.tagCategories||[]).forEach(c=>{ if (c?.name) catByName[c.name.toLowerCase()] = c.id; });

  // create new tags
  const tagIdByName = {};
  (state.index.tags||[]).forEach(t=>{ if (t?.name) tagIdByName[t.name.toLowerCase()] = t.id; });

  preview.newTags.forEach(nt=>{
    if (tagIdByName[nt.name]) return;
    const cname = (nt.categoryName||"Unsorted").trim();
    let cid = catByName[cname.toLowerCase()];
    if (!cid) {
      // create category
      cid = uid();
      state.index.tagCategories.push({ id: cid, name: cname });
      catByName[cname.toLowerCase()] = cid;
    }
    const tid = uid();
    state.index.tags.push({ id: tid, name: nt.name, categoryId: cid });
    tagIdByName[nt.name] = tid;
  });

  // helper: map tagIds placeholders
  const mapTagIds = (tagIds)=>tagIds.map(id=>{
    if (typeof id==="string" && id.startsWith("__NEW__:")) {
      const nm = id.slice("__NEW__:".length);
      return tagIdByName[nm] || null;
    }
    return id;
  }).filter(Boolean);

  // quant profile by name mapping
  const qps = (state.world.entities||[]).filter(e=>e.typeId==="quant_profile");
  const qpByName = {};
  qps.forEach(q=>{ if (q?.name) qpByName[q.name.toLowerCase()] = q.id; });

  const findExisting = (matchId)=> matchId ? byId(state.world.entities, matchId) : null;

  const mergeFacets = (into, from)=>{
    if (!into.__facets || typeof into.__facets!=="object") into.__facets = {};
    const src = (from.__facets && typeof from.__facets==="object") ? from.__facets : {};
    Object.keys(src).forEach(k=>{
      const v = src[k];
      if (v==="" || v==null) return;
      into.__facets[k] = clamp(Number(v),0,10);
    });
  };

  // create or update entities
  preview.entities.forEach(pe=>{
    const fields = deep(pe.fields||{});
    // attach quant profile id if specified
    if (pe.quantProfileName) {
      const qid = qpByName[pe.quantProfileName.toLowerCase()];
      if (qid) fields.quantProfileId = qid;
    }
    const tagIds = mapTagIds(pe.tagIds);

    if (commitMode === "update" && pe.matchId) {
      const ex = findExisting(pe.matchId);
      if (!ex) return;

      if (updateBehavior === "replace") {
        ex.name = pe.name;
        ex.tagIds = tagIds.slice();
        ex.fields = deep(fields);
      } else {
        // merge
        ex.tagIds = Array.from(new Set([...(ex.tagIds||[]), ...tagIds]));
        if (!ex.fields || typeof ex.fields!=="object") ex.fields = {};
        const incoming = deep(fields);
        const incomingFacets = incoming.__facets;
        delete incoming.__facets;

        ex.fields = deepMerge(ex.fields, incoming);
        if (incomingFacets) mergeFacets(ex.fields, {__facets: incomingFacets});
      }

      state.world.selectedEntityId = ex.id;
      state.world.filter.typeId = ex.typeId;
    } else {
      const ent = seedEntity(pe.typeId, pe.name, fields, tagIds, []);
      state.world.entities.push(ent);
      state.world.selectedEntityId = ent.id;
      state.world.filter.typeId = pe.typeId;
    }
  });

  saveState();
  renderPreserveFocus();
}

function renderIntake() {
  const it = ensureIntake();
  const left = $("#leftPane"), main = $("#mainPane"), right = $("#rightPane");
  left.innerHTML = "";
  main.innerHTML = "";
  right.innerHTML = "";

  // Update prompt if needed
  const prompt = buildAIPromptForType(it.typeId, it);
  it.prompt = prompt;

  const typeSel = el("select",{ onchange:(e)=>{ it.typeId=e.target.value; it.lastPreview=null; it.lastError=""; saveState(); renderPreserveFocus(); }});
  (state.index.entityTypes||[]).forEach(t=>{
    typeSel.appendChild(el("option",{value:t.id, text:t.name, selected:t.id===it.typeId}));
  });

  left.appendChild(card("AI Intake",[
    el("div",{class:"muted", text:"Generate entries outside the program with any AI, then paste the JSON here. This avoids imports and gives you a guided prompt + safe commit."}),
    el("div",{style:"margin-top:10px;"},[
      el("label",{text:"Entity type to generate"}),
      typeSel
    ]),
    el("div",{class:"row", style:"margin-top:10px; gap:10px; align-items:center; flex-wrap:wrap;"},[
  el("div",{style:"min-width:180px;"},[
    el("label",{text:"How many entries?"}),
    (()=>{
      const wrap = el("div",{class:"row", style:"gap:8px; align-items:center; flex-wrap:nowrap;"});
      const rng = el("input",{type:"range", min:"1", max:"30", value:String(it.generateCount||6)});
      const out = el("div",{class:"pill", text:String(it.generateCount||6)});
      rng.oninput = (e)=>{ it.generateCount = clamp(Number(e.target.value||6),1,30); out.textContent = String(it.generateCount); };
      rng.onchange = ()=>{ saveState(); renderPreserveFocus(); };
      wrap.appendChild(rng); wrap.appendChild(out);
      return wrap;
    })()
  ]),
  el("div",{style:"min-width:180px;"},[
    el("label",{text:"Detail level"}),
    (()=>{
      const sel = el("select",{onchange:(e)=>{ it.richness = e.target.value; saveState(); renderPreserveFocus(); }},[
        el("option",{value:"short", text:"Short (punchy)", selected: it.richness==="short"}),
        el("option",{value:"balanced", text:"Balanced", selected: !it.richness || it.richness==="balanced"}),
        el("option",{value:"rich", text:"Rich (more texture)", selected: it.richness==="rich"}),
      ]);
      return sel;
    })()
  ])
]),
    el("div",{class:"row", style:"margin-top:10px; gap:8px;"},[
      el("label",{style:"display:flex; gap:8px; align-items:center;"},[
        el("input",{type:"checkbox", checked:!!it.includeTags, onchange:(e)=>{it.includeTags=!!e.target.checked; saveState(); renderPreserveFocus();}}),
        el("span",{text:"Include tag list"})
      ]),
      el("label",{style:"display:flex; gap:8px; align-items:center;"},[
        el("input",{type:"checkbox", checked:!!it.includeFacetSet, onchange:(e)=>{it.includeFacetSet=!!e.target.checked; saveState(); renderPreserveFocus();}}),
        el("span",{text:"Include facet set"})
      ]),
      el("label",{style:"display:flex; gap:8px; align-items:center;"},[
        el("input",{type:"checkbox", checked:!!it.includeTemplates, onchange:(e)=>{it.includeTemplates=!!e.target.checked; saveState(); renderPreserveFocus();}}),
        el("span",{text:"Include templates"})
      ]),
      el("label",{style:"display:flex; gap:8px; align-items:center;"},[
        el("input",{type:"checkbox", checked:!!it.includeQuantProfiles, onchange:(e)=>{it.includeQuantProfiles=!!e.target.checked; saveState(); renderPreserveFocus();}}),
        el("span",{text:"Include quant profiles"})
      ]),
    ]),
    el("div",{class:"muted", style:"margin-top:10px;"},[
      el("span",{text:"Tip: You can keep the prompt short for small additions, or detailed for bulk creation."})
    ]),
    el("div",{class:"hr"}),
    el("div",{style:"font-weight:700; margin-top:6px;", text:"Commit behavior"}),
    el("div",{class:"muted", text:"Choose whether incoming JSON creates new entries, updates existing ones by name+type, or is stored as a draft only."}),
    el("div",{class:"row", style:"gap:10px; flex-wrap:wrap; margin-top:8px;"},[
      el("label",{style:"display:flex; gap:8px; align-items:center;"},[
        el("input",{type:"radio", name:"intakeMode", checked: it.commitMode==="create", onchange:()=>{it.commitMode="create"; saveState(); renderPreserveFocus();}}),
        el("span",{text:"Create new"})
      ]),
      el("label",{style:"display:flex; gap:8px; align-items:center;"},[
        el("input",{type:"radio", name:"intakeMode", checked: it.commitMode==="update", onchange:()=>{it.commitMode="update"; saveState(); renderPreserveFocus();}}),
        el("span",{text:"Update existing"})
      ]),
      el("label",{style:"display:flex; gap:8px; align-items:center;"},[
        el("input",{type:"radio", name:"intakeMode", checked: it.commitMode==="draft", onchange:()=>{it.commitMode="draft"; saveState(); renderPreserveFocus();}}),
        el("span",{text:"Draft only"})
      ])
    ]),
    (it.commitMode==="update" ? el("div",{class:"row", style:"gap:10px; align-items:center; margin-top:8px;"},[
      el("div",{class:"muted", text:"Update mode:"}),
      (()=>{
        const sel = el("select",{onchange:(e)=>{it.updateBehavior=e.target.value; saveState(); renderPreserveFocus();}},[
          el("option",{value:"merge", text:"Merge (safe)", selected: it.updateBehavior==="merge"}),
          el("option",{value:"replace", text:"Replace (overwrite)", selected: it.updateBehavior==="replace"})
        ]);
        return sel;
      })()
    ]) : null)
  ]));

  // prompt area
  const promptArea = el("textarea",{readonly:true, value: prompt});
  const copyBtn = el("button",{class:"btn small", text:"Copy Prompt", onclick: async()=>{
    try { await navigator.clipboard.writeText(promptArea.value); toast("Prompt copied"); } catch { toast("Copy failed — select and copy manually"); }
  }});

  const aiArea = el("textarea",{placeholder:"Paste AI JSON output here…", value: it.aiJson||"", oninput:(e)=>{ it.aiJson = e.target.value; it.lastError=""; saveState(); }});

  const validateBtn = el("button",{class:"btn primary", text:"Validate & Preview", onclick:()=>{
    try{
      const payload = parseAIIntakeJSON(aiArea.value||"");
      const prev = validateAndPreviewIntake(payload, {commitMode: it.commitMode, updateBehavior: it.updateBehavior});
      it.lastPreview = prev;
      it.lastError = "";
      saveState();
      renderPreserveFocus();
    } catch(err){
      it.lastError = String(err?.message||err);
      it.lastPreview = null;
      saveState();
      renderPreserveFocus();
    }
  }});

  const commitBtn = el("button",{class:"btn", text: (it.commitMode==="update" ? "Commit (Update/Create)" : "Commit to World"), disabled: it.commitMode==="draft", onclick:()=>{
    if (it.commitMode==="draft") { toast("Draft mode is on — use Save Draft instead."); return; }
    if (!it.lastPreview) { toast("Validate first"); return; }
    commitIntakePreview(it.lastPreview, {commitMode: it.commitMode, updateBehavior: it.updateBehavior});
    it.aiJson = "";
    it.lastPreview = null;
    it.lastError = "";
    saveState();
  }});

  const saveDraftBtn = el("button",{class:"btn", text:"Save Draft", onclick:()=>{
    if (!it.aiJson.trim()) { toast("Nothing to save"); return; }
    // If not validated yet, try to validate for a richer draft.
    let prev = it.lastPreview;
    if (!prev) {
      try {
        const payload = parseAIIntakeJSON(aiArea.value||"");
        prev = validateAndPreviewIntake(payload, {commitMode: it.commitMode, updateBehavior: it.updateBehavior});
      } catch (err) {
        // Save raw anyway
        prev = null;
      }
    }
    const entry = { id: uid(), ts: Date.now(), typeId: it.typeId, aiJson: String(it.aiJson), prompt: String(it.prompt||""), preview: prev };
    it.drafts.unshift(entry);
    // cap drafts
    if (it.drafts.length > 30) it.drafts.length = 30;
    saveState();
    toast("Draft saved");
    renderPreserveFocus();
  }});

  const clearBtn = el("button",{class:"btn ghost", text:"Clear", onclick:()=>{ it.aiJson=""; it.lastPreview=null; it.lastError=""; saveState(); renderPreserveFocus(); }});

  main.appendChild(card("Prompt for external AI",[
    el("div",{class:"row", style:"justify-content:space-between; align-items:center;"},[
      el("div",{class:"muted", text:"Use this prompt in any AI. It is tailored to your current tags/facets."}),
      copyBtn
    ]),
    promptArea
  ]));

  main.appendChild(card("Paste AI JSON output",[
    aiArea,
    el("div",{class:"row"}, [
      el("button", {class:"ghost small", text:"Show example JSON", onclick: () => {
        const example = {
          tagsToCreate: [
            {name: "stealth", category: "Domain"}
          ],
          entities: [
            {
              typeId: it.typeId,
              name: "Shadow Step",
              tags: ["stealth", "martial"],
              fields: {
                description: "Briefly phase through shadows to reposition.",
                __facets: { power: 4, utility: 7, scope: 3, rarity: 6 }
              }
            }
          ]
        };
        aiArea.value = JSON.stringify(example, null, 2);
        it.aiJson = aiArea.value;
        saveState();
        renderPreserveFocus();
      }})
    ]),
    it.lastError ? el("div",{class:"warn", style:"margin-top:10px;", text:`Error: ${it.lastError}`}) : null,
    el("div",{class:"row", style:"margin-top:10px; gap:8px;"},[validateBtn, commitBtn, saveDraftBtn, clearBtn])
  ]));

  // right: preview
  if (it.lastPreview) {
    const fmt = (n)=>Number(n||0).toFixed(1);
    const p = it.lastPreview;
    right.appendChild(card("Preview",[
      el("div",{class:"row", style:"gap:8px; flex-wrap:wrap;"},[
        badge(`${p.entities.length} entities`),
        badge(`${p.newTags.length} new tags`)
      ]),
      p.warnings && p.warnings.length ? el("div",{class:"warn", style:"margin-top:10px;"},[
        el("b",{text:"Warnings:"}),
        el("ul",{}, p.warnings.slice(0,8).map(w=>el("li",{text:w}))),
        p.warnings.length>8? el("div",{class:"muted", text:`…and ${p.warnings.length-8} more`}) : null
      ]) : null,
      el("div",{style:"margin-top:10px;"}, p.entities.slice(0,8).map(pe=>{
        // Quant preview
        const fake = { typeId: pe.typeId, fields: pe.fields, tagIds: pe.tagIds.filter(x=>typeof x==="string" && !x.startsWith("__NEW__:")) };
        const q = Quant.compute(fake);
        return el("div",{class:"item", style:"cursor:default;"},[
          el("div",{class:"row", style:"justify-content:space-between;"},[
            el("b",{text: pe.name}),
            el("div",{class:"row", style:"gap:6px;"},[badge(pe.typeId), badge(String(pe.action||"create").toUpperCase())])
          ]),
          el("div",{class:"muted", text:`Tags: ${pe.tagNames.slice(0,8).join(", ")}${pe.tagNames.length>8?` …(+${pe.tagNames.length-8})`:""}`}),
          el("div",{class:"muted", text:`Potency: ${fmt(q.potencyUnits)} • Influence: ${fmt(q.influenceUnits)} • Prestige: ${fmt(q.prestige)} • NV: ${fmt(q.netValue)}`})
        ]);
      })),
      p.entities.length>8? el("div",{class:"muted", style:"margin-top:8px;", text:`Showing 8/${p.entities.length}. Commit will add all.`}) : null
    ]));
  } else {
    right.appendChild(card("Preview",[
      el("div",{class:"muted", text:"Validate JSON to see what will be added before committing."})
    ]));
  }
  // drafts panel
  const drafts = Array.isArray(it.drafts) ? it.drafts : [];
  right.appendChild(card("Drafts",[
    drafts.length ? el("div",{class:"muted", text:"Saved intakes you can reload later (raw JSON + optional preview)."}) : el("div",{class:"muted", text:"No drafts yet. Use 'Save Draft' to stash an intake without committing."}),
    drafts.length ? el("div",{style:"margin-top:10px; display:flex; flex-direction:column; gap:8px;"}, drafts.slice(0,12).map(d=>{
      const when = new Date(d.ts||Date.now()).toLocaleString();
      const cnt = d.preview?.entities?.length ?? 0;
      const t = d.typeId || "(type)";
      return el("div",{class:"item"},[
        el("div",{class:"row", style:"justify-content:space-between; gap:10px; align-items:flex-start;"},[
          el("div",{},[
            el("div",{style:"font-weight:700;", text:`${t} • ${when}`}),
            el("div",{class:"muted", text: cnt? `${cnt} entities (preview)` : "raw JSON only"})
          ]),
          el("div",{class:"row", style:"gap:6px; flex-wrap:wrap;"},[
            el("button",{class:"btn small", text:"Load", onclick:()=>{
              it.typeId = d.typeId || it.typeId;
              it.aiJson = String(d.aiJson||"");
              it.lastPreview = d.preview || null;
              it.lastError = "";
              saveState();
              renderPreserveFocus();
            }}),
            el("button",{class:"btn danger small", text:"Delete", onclick:()=>{
              const i = it.drafts.findIndex(x=>x.id===d.id);
              if (i>=0) it.drafts.splice(i,1);
              saveState();
              renderPreserveFocus();
            }})
          ])
        ])
      ]);
    })) : null,
    drafts.length>12 ? el("div",{class:"muted", style:"margin-top:6px;", text:`Showing 12/${drafts.length}.`}) : null,
    drafts.length ? el("div",{class:"row", style:"margin-top:10px; gap:8px;"},[
      el("button",{class:"btn ghost small", text:"Clear drafts", onclick:()=>{
        if (!confirm("Clear all drafts?")) return;
        it.drafts = [];
        saveState();
        renderPreserveFocus();
      }})
    ]) : null
  ]));

}


function renderIndex() {
  const left = $("#leftPane"), main = $("#mainPane"), right = $("#rightPane");
  left.innerHTML = main.innerHTML = right.innerHTML = "";

  left.appendChild(el("div",{class:"card"}, [
    el("div",{class:"muted", text:"Index"}),
    el("div",{text:"Edit tag categories, tags, and conflict rules."}),
    el("div",{class:"muted", text:"This is the ‘database schema’ side."})
  ]));

  main.appendChild(el("div",{class:"card"},[
    el("div",{style:"font-weight:700; margin-bottom:8px;", text:"Quant Profiles"}),
    el("div",{class:"row", style:"justify-content:space-between; align-items:center;"},[
      el("div",{class:"muted", text:"Default Quant Profile"}),
      (()=>{
        const profiles=getQuantProfiles();
        const sel=el("select",{onchange:(e)=>{state.quant.defaultProfileId=e.target.value||null; saveState(); render();}},[
          ...profiles.map(p=>el("option",{value:p.id, text:p.name, selected: state.quant.defaultProfileId===p.id}))
        ]);
        if (!profiles.length) sel.appendChild(el("option",{value:"", text:"(Create a Quant Profile first in World)"}));
        return sel;
      })()
    ]),
    el("label",{style:"display:flex; gap:8px; align-items:center; margin-top:10px;"},[
      el("input",{type:"checkbox", checked: !!state.quant.visualWheel, onchange:(e)=>{state.quant.visualWheel=!!e.target.checked; saveState(); render();}}),
      el("div",{text:"Enable visual wheel (canvas) when rolling"})
    ]),
    el("div",{class:"muted", style:"margin-top:8px;", text:"Tip: You can create/edit Quant Profiles as entities in World → Quant Profile."})
  ]));
  
  main.appendChild(renderTagIndex());
  main.appendChild(renderConflictIndex());
  main.appendChild(renderFacetIndex());

  right.appendChild(el("div",{class:"card"}, [
    el("div",{class:"muted", text:"How conflicts work"}),
    el("div",{text:"If a rolled option has a conflicting tag with your locked context, it gets a small weight penalty. Right now it counts up to 1 conflict match (configurable in code)."}),
    el("div",{class:"muted", text:"Example: pacifist ↔ martial. That would make Fighter less likely for pacifists."})
  ]));
}

function renderTagIndex() {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{text:"Tags"}));
  card.appendChild(el("div",{class:"muted", text:"Add tags freely. You’ll use them everywhere: world entries, generator options, classes, skills."}));

  const catSel = el("select");
  state.index.tagCategories.forEach(c=>catSel.appendChild(el("option",{value:c.id, text:c.name})));

  const nameInp = el("input",{placeholder:"New tag name"});
  const btnAdd = el("button",{class:"primary", text:"Add tag", onclick: ()=>{
    const n = nameInp.value.trim();
    if (!n) return;
    state.index.tags.push({id:uid(), name:n, categoryId:catSel.value});
    nameInp.value = "";
    saveState(); renderPreserveFocus();
  }});

  card.appendChild(el("div",{class:"row"}, [nameInp, catSel, btnAdd]));
  card.appendChild(el("div",{class:"hr"}));

  // list by category
  state.index.tagCategories.forEach(cat=>{
    const tags = state.index.tags.filter(t=>t.categoryId===cat.id).slice().sort((a,b)=>a.name.localeCompare(b.name));
    if (!tags.length) return;
    card.appendChild(el("div",{class:"muted", text:cat.name}));
    tags.forEach(t=>{
      const row = el("div",{class:"row"}, [
        el("div",{style:"flex:1", text:t.name}),
        el("button",{class:"danger small", text:"Delete", onclick: ()=>{
          if (!confirm(`Delete tag "${t.name}"?`)) return;
          // Remove from everywhere
          state.index.tags = state.index.tags.filter(x=>x.id!==t.id);
          state.world.entities.forEach(e=>e.tagIds = (e.tagIds||[]).filter(id=>id!==t.id));
          state.characters.list.forEach(c=>c.tagIds = (c.tagIds||[]).filter(id=>id!==t.id));
          state.generator.steps.forEach(s=>{
            (s.options||[]).forEach(o=>o.tagIds = (o.tagIds||[]).filter(id=>id!==t.id));
          });
          state.index.tagConflicts = (state.index.tagConflicts||[]).filter(p=>p.a!==t.id && p.b!==t.id);
          saveState(); renderPreserveFocus();
        }})
      ]);
      card.appendChild(row);
    });
    card.appendChild(el("div",{class:"hr"}));
  });

  return card;
}

function renderConflictIndex() {
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{text:"Tag conflicts (inverse synergy)"}));
  card.appendChild(el("div",{class:"muted", text:"Add pairs of tags that should ‘work badly together’ in rolls."}));

  const aSel = el("select");
  const bSel = el("select");
  state.index.tags.slice().sort((x,y)=>x.name.localeCompare(y.name)).forEach(t=>{
    aSel.appendChild(el("option",{value:t.id, text:t.name}));
    bSel.appendChild(el("option",{value:t.id, text:t.name}));
  });

  const btnAdd = el("button",{class:"primary", text:"Add conflict", onclick: ()=>{
    if (aSel.value===bSel.value) return;
    state.index.tagConflicts = state.index.tagConflicts || [];
    // avoid duplicates
    const exists = state.index.tagConflicts.some(p => (p.a===aSel.value && p.b===bSel.value) || (p.a===bSel.value && p.b===aSel.value));
    if (!exists) state.index.tagConflicts.push({a:aSel.value, b:bSel.value});
    saveState(); renderPreserveFocus();
  }});

  card.appendChild(el("div",{class:"row"}, [aSel, bSel, btnAdd]));
  card.appendChild(el("div",{class:"hr"}));

  const list = state.index.tagConflicts || [];
  if (!list.length) card.appendChild(el("div",{class:"muted", text:"No conflicts yet."}));
  else {
    list.forEach((p, idx)=>{
      card.appendChild(el("div",{class:"row"}, [
        el("div",{style:"flex:1", text:`${tagName(p.a)} ↔ ${tagName(p.b)}`}),
        el("button",{class:"danger small", text:"Remove", onclick: ()=>{
          list.splice(idx,1);
          saveState(); renderPreserveFocus();
        }})
      ]));
    });
  }
  return card;
}

function renderFacetIndex(){
  const card = el("div",{class:"card"});
  card.appendChild(el("div",{text:"Facet sets"}));
  card.appendChild(el("div",{class:"muted", text:"Define which facets exist per entity type. Editors and the Create Wizard will follow this. “Maps to” tells Quant which canonical channel this facet contributes to; set “(ignored by Quant)” if it’s flavor-only. Labels are optional (11 entries for 0..10)."}));

  const typeSel = el("select",{onchange:(e)=>{state.ui.facetType = e.target.value; saveState(); render();}});
  const typeId = state.ui.facetType || "skill";
  for (const t of state.index.entityTypes){
    typeSel.appendChild(el("option",{value:t.id, text:t.name, selected: t.id===typeId}));
  }

  const topRow = el("div",{class:"row", style:"justify-content:space-between; align-items:center; margin-top:10px;"},[
    el("div",{class:"muted", text:"Entity type"}),
    typeSel
  ]);
  card.appendChild(topRow);

  if (!state.index.facetDefsByType) state.index.facetDefsByType = deep(DEFAULT_FACET_DEFS_BY_TYPE);
  if (!state.index.facetDefsByType[typeId]) state.index.facetDefsByType[typeId] = deep(DEFAULT_FACET_DEFS_BY_TYPE[typeId]||[]);
  const defs = state.index.facetDefsByType[typeId];

  // Validation warnings (non-blocking)
  const canonOpts = ["","power","utility","reliability","scope","frequency","complexity","upkeep","access","rarity"];
  const enabledDefs = defs.filter(d=>d && d.enabled!==false);
  const keys = enabledDefs.map(d=>(d.key||"").trim()).filter(Boolean);
  const dupKeys = [...new Set(keys.filter((k,i)=>keys.indexOf(k)!==i))];
  const labelIssues = [];
  enabledDefs.forEach(d=>{
    const raw = d.labels;
    if (raw==null || raw==="") return;
    const lines = Array.isArray(raw) ? raw : String(raw).split("\n");
    const count = lines.filter(x=>String(x).trim().length>0).length;
    if (count !== 11) labelIssues.push({key:(d.key||"(no key)"), count});
  });

  if (dupKeys.length || labelIssues.length) {
    const warn = el("div",{class:"card", style:"border-left:4px solid #b45309; padding:10px; margin-top:10px;"});
    warn.appendChild(el("div",{style:"font-weight:700;", text:"⚠ Facet set warnings"}));
    if (dupKeys.length) warn.appendChild(el("div",{class:"muted", style:"margin-top:4px;", text:`Duplicate facet keys (enabled): ${dupKeys.join(", ")}` }));
    if (labelIssues.length) warn.appendChild(el("div",{class:"muted", style:"margin-top:4px;", text:`Label lists should have 11 lines (0..10). Issues: ${labelIssues.map(x=>x.key+"="+x.count).join(", ")}` }));
    card.appendChild(warn);
  }

  const list = el("div",{style:"margin-top:10px; display:flex; flex-direction:column; gap:10px;"});

  defs.forEach((d, idx)=>{
    const keyInp = el("input",{value:d.key||"", placeholder:"key", style:"width:140px;", oninput:(e)=>{d.key=e.target.value.trim(); saveState(); renderPreserveFocus();}});
    const labInp = el("input",{value:d.label||"", placeholder:"Label", style:"flex:1;", oninput:(e)=>{d.label=e.target.value; saveState(); renderPreserveFocus();}});

    const mapsSel = el("select",{style:"width:160px;", onchange:(e)=>{d.mapsTo = e.target.value; if (d.mapsTo==="") delete d.mapsTo; saveState(); renderPreserveFocus();}});
    const current = (d.mapsTo ?? (canonOpts.includes(d.key) ? d.key : ""));
    canonOpts.forEach(k=>{
      mapsSel.appendChild(el("option",{value:k, text:(k===""?"(ignored by Quant)":k), selected: k===current}));
    });

    const enabled = el("input",{type:"checkbox", checked: d.enabled!==false, onchange:(e)=>{d.enabled=!!e.target.checked; saveState(); renderPreserveFocus();}});
    const delBtn = el("button",{class:"btn", text:"Delete", onclick:()=>{defs.splice(idx,1); saveState(); renderPreserveFocus();}});

    const labelsArea = el("textarea",{value:(Array.isArray(d.labels)?d.labels.join("\\n"):(d.labels||"")), placeholder:"Optional: 11 labels (0..10), one per line", rows:"4", style:"width:100%; margin-top:8px;", oninput:(e)=>{d.labels=e.target.value; saveState(); renderPreserveFocus();}});

    const row = el("div",{class:"card"},[
      el("div",{class:"row", style:"gap:10px; align-items:center;"},[
        keyInp,
        labInp,
        mapsSel,
        el("label",{style:"display:flex; gap:6px; align-items:center;"},[enabled, el("span",{class:"muted", text:"enabled"})]),
        delBtn
      ]),
      labelsArea
    ]);
    list.appendChild(row);
  });

  // Add new facet
  const addKey = el("input",{placeholder:"new_key", style:"width:140px;"});
  const addLab = el("input",{placeholder:"New facet label", style:"flex:1;"});
  const addMapSel = el("select",{style:"width:160px;"});
  ["","power","utility","reliability","scope","frequency","complexity","upkeep","access","rarity"].forEach(k=>{
    addMapSel.appendChild(el("option",{value:k, text:(k===""?"(ignored by Quant)":k)}));
  });
  const addBtn = el("button",{class:"btn primary", text:"Add facet", onclick:()=>{
    const k = addKey.value.trim();
    if (!k) return;
    const exists = defs.some(d=> (d.key||"").trim()===k);
    if (exists) { alert(`Facet key "${k}" already exists for ${entityTypeName(typeId)}.`); return; }
    defs.push({key:k, label:addLab.value.trim()||k, mapsTo: (addMapSel.value||"")});
    addKey.value=""; addLab.value=""; addMapSel.value="";
    saveState(); render();
  }});
  const resetBtn = el("button",{class:"btn", text:"Reset to defaults", onclick:()=>{
    state.index.facetDefsByType[typeId]=deep(DEFAULT_FACET_DEFS_BY_TYPE[typeId]||[]);
    saveState(); render();
  }});

  card.appendChild(list);
  card.appendChild(el("div",{class:"hr"}));
  card.appendChild(el("div",{class:"row", style:"gap:10px;"},[addKey, addLab, addMapSel, addBtn, resetBtn]));
  return card;
}


// -------------------- SIM AUTO TICK LOOP --------------------
// Driven by SimClock; this is just a lightweight heartbeat.
setInterval(()=>{
  try{
    SimClock.maybeAutoTick();
  } catch(e) {
    console.warn("autoTick failed", e);
  }
}, 250);


// Initial render (guard against startup errors)
try { render(); } catch (e) {
  console.error(e);
  const main = document.getElementById('mainPane');
  if (main) main.innerHTML = `<div class='card'><div style='font-weight:800'>Startup error</div><div class='muted mono'>${String(e && e.stack || e)}</div><div class='muted'>Tip: Click Reset to clear old local data.</div></div>`;
}

</script>
</body>
</html>
